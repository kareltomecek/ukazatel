<!DOCTYPE html>
<html lang="cs">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Antigravity Scoreboard (SB)</title>
    <!-- SheetJS for Excel/CSV import -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <!-- QRCode library for PO2 -->
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-bg: #2d2d2d;
            --text-color: #ffffff;
            --accent-green: #4caf50;
            --accent-red: #f44336;
            --accent-yellow: #ffc107;
            --accent-blue: #2196f3;
            --border-radius: 8px;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
            /* Prevent body scroll if content fits */
        }

        #app-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            height: 100%;
        }

        /* Responsive Layout */
        @media (max-width: 1024px) {
            #app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                overflow-y: auto;
            }

            body {
                overflow-y: auto;
                height: auto;
            }
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        h2,
        h3 {
            margin-top: 0;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }

        /* --- Controls Section (Left Panel) --- */
        #game-controls {
            gap: 20px;
        }

        /* Phase Navigation */
        .phase-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #383838;
            padding: 10px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
        }

        .phase-steps {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .phase-btn {
            background: #555;
            border: none;
            color: #aaa;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .phase-btn.active {
            background: var(--accent-blue);
            color: white;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
        }

        .nav-arrow {
            background: #444;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
        }

        .nav-arrow:hover {
            background: #666;
        }

        /* Score & Time Area */
        .scoreboard-interface {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
            gap: 20px;
            flex-grow: 1;
            align-items: center;
        }

        .team-panel {
            text-align: center;
            background: #333;
            padding: 20px;
            border-radius: var(--border-radius);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 0;
            /* Allow shrinking for ellipsis */
            position: relative;
            z-index: 1;
            /* Below center panel */
        }

        .team-logo {
            width: 80px;
            height: 80px;
            object-fit: contain;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            display: block;
            /* Always visible to maintain layout */
            opacity: 0;
            /* Invisible by default, will be set to 1 when logo is loaded */
        }

        .team-name {
            font-size: 1.5em;
            font-weight: bold;
            color: #ddd;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .score-display {
            font-size: 4em;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
        }

        .score-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn-speaker {
            font-size: 0.8em;
            padding: 5px;
        }

        .btn-speaker svg {
            width: 24px;
            height: 24px;
        }

        .round-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .center-panel {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
            z-index: 2;
            /* Above team panels */
        }

        .timer-display {
            font-size: 5em;
            font-family: 'Courier New', monospace;
            background: #000;
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #444;
            color: var(--accent-yellow);
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #main-timer {
            outline: none;
            cursor: default;
        }

        #main-timer[contenteditable="true"]:hover {
            background: #111;
            cursor: text;
        }

        .timer-arrows {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .arrow-btn {
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 0.4em;
            padding: 0;
            line-height: 1;
            transition: color 0.2s;
        }

        .arrow-btn:hover {
            color: var(--accent-yellow);
        }

        .arrow-btn:disabled {
            color: #333;
            cursor: not-allowed;
        }

        .timer-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .music-mini-panel {
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
            background: #222;
            padding: 6px 12px;
            border-radius: 20px;
            margin-top: 10px;
            border: 1px solid #444;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            width: fit-content;
        }

        .music-mini-panel .round-btn {
            background: none !important;
            border: none !important;
            color: #888 !important;
            box-shadow: none !important;
            width: 32px;
            height: 32px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .music-mini-panel .round-btn:hover {
            color: #bbb !important;
        }

        #btn-music-toggle-mini {
            font-size: 1.5em;
        }


        #btn-music-toggle-mini.active {
            color: #00a2ff !important;
        }

        .small-btn {
            padding: 5px 10px;
            font-size: 0.9em;
            background: #555;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* --- Admin Section (Right Panel) --- */
        #admin-panel {
            overflow-y: auto;
        }

        .accordion {
            margin-bottom: 10px;
        }

        .accordion-header {
            background-color: #444;
            padding: 10px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }

        .accordion-content {
            padding: 10px;
            background: #383838;
            margin-top: 2px;
            border-radius: 0 0 4px 4px;
            display: none;
        }

        .accordion-content.open {
            display: block;
        }

        .form-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #ccc;
        }

        input,
        select {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .btn-full {
            width: 100%;
            padding: 10px;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .btn-projection {
            background: #9c27b0;
            margin-bottom: 20px;
        }

        /* Color Utilities (must be after layout classes) */
        .btn-green {
            background-color: var(--accent-green) !important;
        }

        .btn-red {
            background-color: var(--accent-red) !important;
        }

        .btn-yellow {
            background-color: var(--accent-yellow) !important;
            color: #000 !important;
        }

        .btn-orange {
            background-color: #ff9800 !important;
            color: white !important;
        }

        /* List Styling */
        .match-list {
            list-style: none;
            padding: 0;
        }

        .match-item {
            background: #444;
            margin-bottom: 5px;
            padding: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            position: relative;
            /* Required for ::before positioning */
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .match-item.drop-indicator-top::before,
        .match-item.drop-indicator-bottom::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 3px;
            background-color: #4caf50;
            z-index: 10;
        }

        .match-item.drop-indicator-top::before {
            top: -2px;
        }

        .match-item.drop-indicator-bottom::before {
            bottom: -2px;
        }

        .active-match {
            border-left: 5px solid var(--accent-green);
            background-color: #3e5e40;
        }

        .editing-match {
            background-color: #8c2a2a !important;
            /* Redish background for edit */
            border: 2px solid #f44336;
        }

        .selected-match {
            background-color: #2b4b7c !important;
            /* Blue for selection */
            border-left: 5px solid #2196f3;
        }

        .schedule-toolbar {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
            background: #2a2a2a;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .schedule-toolbar .small-btn {
            background: #444;
            min-width: 32px;
            font-weight: bold;
        }

        .schedule-toolbar .small-btn:hover {
            background: #555;
        }

        .schedule-toolbar .btn-red:hover {
            background: #d32f2f !important;
        }

        .schedule-toolbar .btn-green:hover {
            background: #388e3c !important;
        }

        /* --- Admin Footer --- */
        #admin-footer {
            display: grid;
            grid-template-columns: minmax(100px, auto) 1fr 1fr 1fr;
            align-items: center;
            background: #111;
            padding: 0 20px;
            color: #888;
            font-size: 0.85em;
            font-weight: bold;
            border-top: 1px solid #333;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 35px;
            box-sizing: border-box;
            z-index: 1000;
        }

        #admin-footer-end {
            text-align: center;
        }

        #admin-footer-time {
            text-align: right;
        }

        body {
            padding-bottom: 55px;
            /* 35px footer + 20px gap */
        }

        /* Space for fixed footer */

        /* PROJECTION MODE OVERRIDES */
        body.mode-projection {
            margin: 0;
            padding: 0 !important;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            background: #000;
            color: #fff;
            display: block;
            /* Overriding possible grid from other modes */
        }

        body.mode-projection #app-container,
        body.mode-projection #admin-footer {
            display: none !important;
        }

        #projection-layout {
            display: none;
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            grid-template-rows: 18vh 48vh 30vh 4vh;
        }

        body.mode-projection #projection-layout {
            display: grid;
        }

        /* Reuse projection styles from old window generation */
        .p-row {
            display: grid;
            align-items: center;
            padding: 0 4vw;
        }

        #p-row-top {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
        }

        #p-match-title {
            font-size: 3vw;
            text-align: left;
            font-weight: 500;
        }

        #p-phase-name {
            font-size: 4vw;
            font-weight: 800;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.1vw;
        }

        #p-timer {
            font-size: 6vw;
            font-family: 'Courier New', monospace;
            text-align: right;
            font-weight: bold;
        }

        #p-row-mid {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
        }

        .p-team {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2vh;
            min-width: 0;
        }

        .p-team-name {
            font-size: 4.5vw;
            font-weight: 900;
            text-align: center;
            line-height: 1.1;
            text-transform: uppercase;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .p-team-logo {
            width: 17vw;
            height: 17vw;
            object-fit: contain;
            border-radius: 2vw;
            display: block;
            opacity: 0;
            /* Always visible to maintain layout */
        }

        #p-score-box {
            font-size: 16vw;
            font-weight: 900;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #p-score-sep {
            margin: 0 1vw;
        }

        #p-event-content {
            display: none;
            grid-column: 1 / span 3;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 9vw;
            font-weight: 900;
            text-transform: uppercase;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 0 5vw;
            box-sizing: border-box;
        }

        #p-row-bot {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            padding: 0;
            overflow: hidden;
        }

        .p-sched-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        #p-upcoming-header {
            display: grid;
            grid-template-columns: 22% 56% 22%;
            align-items: flex-start;
            padding: 0.5vh 4vw 0 4vw;
            font-size: 1.8vw;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05vw;
            height: 5vh;
            margin-bottom: 1vh;
            box-sizing: border-box;
        }

        #p-match-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-column: 1 / span 3;
            width: 100%;
            height: 100%;
            align-items: center;
        }

        .p-sched-row {
            height: 5.5vh;
            font-size: 1.8vw;
        }

        .p-sched-col-match {
            width: 22%;
            text-align: left;
            font-weight: 500;
        }

        .p-sched-col-teams {
            width: 56%;
            font-weight: 700;
            padding: 0;
        }

        .p-sched-col-refs {
            width: 22%;
            text-align: right;
            font-size: 1.5vw;
        }

        .p-teams-flex {
            display: flex;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .p-teams-side-home {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            text-align: right;
            overflow: hidden;
        }

        .p-teams-side-guest {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            text-align: left;
            overflow: hidden;
        }

        .p-teams-sep {
            width: 4vw;
            text-align: center;
            flex-shrink: 0;
            font-size: 2vw;
            font-weight: 900;
        }

        .p-mini-logo {
            width: 2.5vw;
            height: 2.5vw;
            object-fit: contain;
            vertical-align: middle;
            margin: 0 0.8vw;
            border-radius: 0.5vw;
            display: inline-block;
            opacity: 0;
            /* Always visible to maintain layout */
        }

        #p-row-footer {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            align-items: center;
            padding: 0 4vw;
            font-size: 1.0vw;
            font-weight: bold;
            color: #888;
        }

        .p-footer-center {
            text-align: center;
            font-weight: bold;
        }

        .p-footer-right {
            text-align: right;
        }

        /* THEMES for Projection */
        body.mode-projection.theme-light {
            background: #ffffff;
            color: #333333;
        }

        body.mode-projection.theme-light #p-row-top {
            background: #fcfcfc;
        }

        body.mode-projection.theme-light #p-match-title {
            color: #777777;
        }

        body.mode-projection.theme-light #p-phase-name {
            color: #1a73e8;
        }

        body.mode-projection.theme-light #p-timer {
            color: #d32f2f;
        }

        body.mode-projection.theme-light #p-score-box,
        body.mode-projection.theme-light #p-event-content {
            color: #2e7d32;
        }

        body.mode-projection.theme-light #p-row-bot {
            background: #f8f9fa;
        }

        body.mode-projection.theme-light .p-sched-row {
            border-bottom: 1px solid #e9ecef;
            color: #3c4043;
        }

        body.mode-projection.theme-dark {
            background: #000000;
            color: #ffffff;
        }

        body.mode-projection.theme-dark #p-row-top {
            background: #0a0a0a;
        }

        body.mode-projection.theme-dark #p-match-title {
            color: #aaaaaa;
        }

        body.mode-projection.theme-dark #p-timer {
            color: #ffc107;
        }

        body.mode-projection.theme-dark #p-score-box,
        body.mode-projection.theme-dark #p-event-content {
            color: #4caf50;
        }

        body.mode-projection.theme-dark .p-sched-row {
            border-bottom: 1px solid #222222;
            color: #dddddd;
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }

            100% {
                opacity: 1;
            }
        }

        .p-row-blink {
            animation: blink 1s infinite;
        }

        /* Schedule Sections - Simplified */
        .sched-section {
            display: none;
            border: 1px solid var(--accent-blue);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            background: rgba(33, 150, 243, 0.03);
        }

        #sched-section-import {
            border-color: #555;
            background: rgba(255, 255, 255, 0.01);
        }

        .sched-section.active {
            display: block;
        }

        .sched-section h4 {
            margin: 0 0 12px 0;
            padding: 0;
            font-size: 0.85em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #sched-section-gen h4 {
            color: var(--accent-blue);
        }

        #sched-section-import h4 {
            color: #aaa;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: #222;
            padding: 2px;
            border-radius: 6px;
            margin-bottom: 12px;
            border: 1px solid #444;
        }

        .mode-toggle-btn {
            flex: 1;
            padding: 6px;
            border: none;
            background: none;
            color: #777;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .mode-toggle-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        .mode-toggle-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .icon-sq {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            background: var(--accent-blue);
            border-radius: 4px;
            color: white;
            flex-shrink: 0;
        }

        .mode-toggle-btn.active .icon-sq {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>

<body>

    <div id="admin-header-stripe"
        style="height: 4px; width: 100%; position: fixed; top: 0; left: 0; z-index: 1000; display: none;"></div>
    <div id="app-container">
        <!-- LEFT PANEL: Game Controls -->
        <div id="game-controls" class="panel">
            <button class="btn-full btn-projection" onclick="openProjectionWindow()">üìΩÔ∏è Otev≈ô√≠t Projekƒçn√≠ Okno</button>

            <div class="phase-nav">
                <button class="nav-arrow" onclick="game.step(-1)">‚óÑ</button>
                <div class="phase-steps" id="phase-controls">
                    <button class="phase-btn" data-phase="0">Nastupuje</button>
                    <button class="phase-btn" data-phase="1">1. Poloƒças</button>
                    <button class="phase-btn" data-phase="2">P≈ôest√°vka</button>
                    <button class="phase-btn" data-phase="3">2. Poloƒças</button>
                </div>
                <div id="event-label"
                    style="display:none; flex:1; text-align:center; font-weight:900; text-transform:uppercase; font-size:1.2em; color:var(--accent-blue); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                    Ud√°lost</div>
                <button class="nav-arrow" onclick="game.step(1)">‚ñ∫</button>
            </div>

            <div class="scoreboard-interface">
                <!-- Home Team -->
                <div class="team-panel" id="home-team-panel">
                    <div class="team-name" id="home-name-disp">Dom√°c√≠</div>
                    <img id="home-logo-disp" class="team-logo" src="" alt="Logo">
                    <div class="score-display" id="home-score-disp">0</div>
                    <div class="score-controls">
                        <button class="round-btn btn-green" onclick="game.adjustScore('home', 1)">+</button>
                        <button class="round-btn btn-green btn-speaker" onclick="game.adjustScore('home', 1, true)"
                            title="G√≥l s jingle">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z" />
                            </svg>
                        </button>
                        <button class="round-btn btn-red" onclick="game.adjustScore('home', -1)">-</button>
                    </div>
                </div>

                <!-- Timer & Center -->
                <div class="center-panel">
                    <div id="match-info-display" style="color:#aaa; margin-bottom:5px; font-weight:bold;">-</div>
                    <div class="timer-display">
                        <span id="main-timer" onblur="game.manualTimeEntry()"
                            onkeydown="if(event.key==='Enter'){this.blur(); event.preventDefault();}">00:00</span>
                        <div class="timer-arrows">
                            <button class="arrow-btn" id="btn-time-up" onclick="game.adjustTime(1)">‚ñ≤</button>
                            <button class="arrow-btn" id="btn-time-down" onclick="game.adjustTime(-1)">‚ñº</button>
                        </div>
                    </div>
                    <div class="timer-controls">
                        <button id="btn-timer-toggle" class="round-btn btn-yellow"
                            onclick="game.toggleTimer()">‚èØ</button>
                        <button class="round-btn btn-red" onclick="game.resetTimer()">‚Ü∫</button>
                    </div>

                    <div class="music-mini-panel" id="music-mini-panel" style="display:none;">
                        <div style="display:flex; align-items:center; gap:8px;">
                            <button class="round-btn" onclick="music.prev()">‚èÆ</button>
                            <button class="round-btn" id="btn-music-toggle-mini" onclick="music.toggle()">‚ô´</button>
                            <button class="round-btn" onclick="music.next()">‚è≠</button>
                        </div>
                        <div style="width: 100%; display: flex; align-items: center; padding: 0 4px;">
                            <input type="range" id="input-vol-music" min="0" max="1" step="0.05" value="0.5"
                                oninput="music.setVolume(this.value)"
                                style="margin:0; height:4px; accent-color:#888; cursor:pointer;">
                        </div>
                    </div>
                </div>

                <!-- Guest Team -->
                <div class="team-panel" id="guest-team-panel">
                    <div class="team-name" id="guest-name-disp">Host√©</div>
                    <img id="guest-logo-disp" class="team-logo" src="" alt="Logo">
                    <div class="score-display" id="guest-score-disp">0</div>
                    <div class="score-controls">
                        <button class="round-btn btn-green" onclick="game.adjustScore('guest', 1)">+</button>
                        <button class="round-btn btn-green btn-speaker" onclick="game.adjustScore('guest', 1, true)"
                            title="G√≥l s jingle">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z" />
                            </svg>
                        </button>
                        <button class="round-btn btn-red" onclick="game.adjustScore('guest', -1)">-</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT PANEL: Administration -->
        <div id="admin-panel" class="panel">
            <h3>Turnajov√° Spr√°va</h3>
            <!-- 1. Tournament Settings -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-settings')">
                    Nastaven√≠ Turnaje <span>‚ñº</span>
                </div>
                <div id="acc-settings" class="accordion-content">
                    <div class="form-group">
                        <label>N√°zev Turnaje</label>
                        <input type="text" id="input-tournament-name" placeholder="Nap≈ô. Zimn√≠ Poh√°r"
                            oninput="admin.saveSettings(false)">
                    </div>

                    <h4 style="margin: 15px 0 10px 0; border: none; padding: 0;">D√©lka krok≈Ø (s)</h4>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">Poloƒças</label>
                            <input type="number" id="time-play" value="420" min="0" max="3599" style="width: 100%;"
                                oninput="admin.validateTimeInput(this)">
                            <small id="hint-time-play"
                                style="color: #4caf50; font-size: 0.75em; display: block; margin-top: 2px;">-</small>
                        </div>
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">P≈ôest√°vka</label>
                            <input type="number" id="time-break" value="105" min="0" max="3599" style="width: 100%;"
                                oninput="admin.validateTimeInput(this)">
                            <small id="hint-time-break"
                                style="color: #4caf50; font-size: 0.75em; display: block; margin-top: 2px;">-</small>
                        </div>
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">Nastupuje</label>
                            <input type="number" id="time-setup" value="10" min="0" max="3599" style="width: 100%;"
                                oninput="admin.validateTimeInput(this)">
                            <small id="hint-time-setup"
                                style="color: #4caf50; font-size: 0.75em; display: block; margin-top: 2px;">-</small>
                        </div>
                    </div>

                    <h4 style="margin: 15px 0 10px 0; border: none; padding: 0;">Bodov√°n√≠</h4>
                    <div style="display: flex; gap: 10px; margin-bottom: 5px;">
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">V√Ωhra</label>
                            <input type="number" id="rule-win" value="3" min="0" style="width: 100%;"
                                oninput="admin.saveSettings(false)">
                        </div>
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">Rem√≠za</label>
                            <input type="number" id="rule-draw" value="1" min="0" style="width: 100%;"
                                oninput="admin.saveSettings(false)">
                        </div>
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">Prohra</label>
                            <input type="number" id="rule-loss" value="0" min="0" style="width: 100%;"
                                oninput="admin.saveSettings(false)">
                        </div>
                    </div>

                    <div class="form-group" style="margin-top: 15px; text-align: left;">
                        <label
                            style="display: flex; align-items: center; gap: 8px; cursor: pointer; justify-content: flex-start;">
                            <input type="checkbox" id="rule-mini-tables" onchange="admin.saveSettings(false)"
                                style="margin: 0; width: auto;">
                            Vz√°jemn√© z√°pasy (Minitabulky)
                        </label>
                        <small style="color: #888; display: block; margin-top: 4px;">P≈ôi rovnosti bod≈Ø rozhoduj√≠
                            vz√°jemn√© z√°pasy p≈ôed celkov√Ωm sk√≥re.</small>
                    </div>

                </div>
            </div>



            <!-- 3. Players -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-players')">
                    Hr√°ƒçi <span>‚ñº</span>
                </div>
                <div id="acc-players" class="accordion-content">
                    <div class="form-group">
                        <label>Seznam Hr√°ƒç≈Ø</label>
                        <div id="players-input-list"
                            style="display:flex; flex-direction:column; gap:5px; margin-bottom:10px;">
                            <!-- Dynamically populated -->
                        </div>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; gap:5px;">
                                <button class="small-btn btn-green" onclick="admin.addPlayerSlot()"
                                    title="P≈ôid√° nov√Ω pr√°zdn√Ω ≈ô√°dek pro zad√°n√≠ jm√©na a UCI-ID hr√°ƒçe.">+ P≈ôidat
                                    hr√°ƒçe</button>
                                <a href="https://portal.czechcyclingfederation.com/Racer" target="_blank"
                                    class="small-btn"
                                    title="Otev≈ôe ofici√°ln√≠ port√°l ƒåSC pro vyhled√°n√≠ UCI-ID podle jm√©na."
                                    style="background:#0056b3; display:flex; align-items:center; text-decoration:none; color:white; font-size:0.75em; padding:0 10px;">
                                    üåê Hledat UCI-ID
                                </a>
                            </div>
                            <div style="display:flex; gap:5px;">
                                <button class="small-btn" onclick="admin.updatePlayersFromCloud()"
                                    title="St√°hne nejnovƒõj≈°√≠ datab√°zi hr√°ƒç≈Ø z Google Disku a synchronizuje ji s va≈°√≠ lok√°ln√≠ verz√≠."
                                    style="background:#00a2ff; flex:1; font-weight:bold;">üîÑ Aktualizovat z
                                    cloudu</button>
                                <button class="small-btn" onclick="admin.exportPlayersWithPassword()"
                                    title="Vytvo≈ô√≠ z√°lohu va≈°√≠ aktu√°ln√≠ datab√°ze hr√°ƒç≈Ø do souboru. Vy≈æaduje heslo."
                                    style="background:#555; flex:1;">üì• Export datab√°ze</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 2. Team Logos & Anthems -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-logos')">
                    Dru≈æstva a Rozhodƒç√≠ <span>‚ñº</span>
                </div>
                <div id="acc-logos" class="accordion-content">
                    <div class="form-group">
                        <label>Seznam Dru≈æstev</label>
                        <div id="teams-input-list"
                            style="display:flex; flex-direction:column; gap:5px; margin-bottom:10px;">
                            <!-- Dynamically populated numbered inputs -->
                        </div>
                        <button class="small-btn btn-green" onclick="admin.addTeamSlot()"
                            title="P≈ôid√° nov√Ω ≈ô√°dek pro zad√°n√≠ n√°zvu dru≈æstva.">+ P≈ôidat dru≈æstvo</button>
                    </div>
                    <div id="team-logo-list"
                        style="margin-bottom:15px; border:1px solid #444; padding:10px; border-radius:4px; max-height:250px; overflow-y:auto;">
                        <!-- logo items here -->
                    </div>
                    <div class="form-group">
                        <label>Seznam Rozhodƒç√≠ch</label>
                        <div id="referees-input-list"
                            style="display:flex; flex-direction:column; gap:5px; margin-bottom:10px;">
                            <!-- Dynamically populated numbered inputs -->
                        </div>
                        <button class="small-btn btn-green" onclick="admin.addRefereeSlot()"
                            title="P≈ôid√° nov√Ω ≈ô√°dek pro zad√°n√≠ jm√©na rozhodƒç√≠ho.">+ P≈ôidat rozhodƒç√≠ho</button>
                    </div>
                </div>
            </div>

            <!-- 4. Schedule -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-schedule')">
                    Rozpis Z√°pas≈Ø <span>‚ñº</span>
                </div>
                <div id="acc-schedule" class="accordion-content">

                    <div class="mode-toggle" style="margin-top: 5px; background: #222;">
                        <button id="tab-sched-gen" class="mode-toggle-btn sched-tab-btn active"
                            onclick="admin.setScheduleMode('gen')"
                            title="Vytvo≈ôit rozpis automaticky podle ≈°ablony.">üõ†Ô∏è Gener√°tor</button>
                        <button id="tab-sched-import" class="mode-toggle-btn sched-tab-btn"
                            onclick="admin.setScheduleMode('import')"
                            title="Importovat rozpis z Excelu nebo CSV souboru.">üìä Import</button>
                    </div>


                    <!-- Generator Section -->
                    <div id="sched-section-gen" class="sched-section active">
                        <h4>üìã Gener√°tor rozpis≈Ø</h4>
                        <div id="sched-template-container">
                            <label
                                style="display:block; font-size:0.85em; color:var(--accent-blue); font-weight:bold; margin-bottom:12px;">Automatick√Ω
                                rozpis (podle vzor≈Ø)</label>
                            <div style="display:flex; gap:8px;">
                                <select id="sched-template-select" style="flex:1">
                                    <optgroup label="Vzory z√°kladn√≠">
                                        <option value="basic_1">1. Pro 3 dru≈æstva</option>
                                        <option value="basic_2">2. Pro 4 dru≈æstva</option>
                                        <option value="basic_3">3. Pro 5 dru≈æstev</option>
                                        <option value="basic_4">4. Pro 6 dru≈æstev</option>
                                        <option value="basic_5">5. Pro 7 dru≈æstev</option>
                                        <option value="basic_6">6. Pro 8 dru≈æstev</option>
                                    </optgroup>
                                    <optgroup label="Vzory kolov√° 2022">
                                        <!-- Bude doplnƒõno pozdƒõji -->
                                    </optgroup>
                                </select>
                                <button class="small-btn btn-blue" onclick="admin.generateScheduleFromTemplate()"
                                    title="Sma≈æe aktu√°ln√≠ rozpis a vytvo≈ô√≠ nov√Ω podle vybran√©ho vzoru a poƒçtu dru≈æstev."
                                    style="background:var(--accent-blue);">Generovat</button>
                            </div>
                        </div>
                    </div>

                    <!-- Import Section -->
                    <div id="sched-section-import" class="sched-section">
                        <h4>üìä Import z Excelu</h4>
                        <div>
                            <label
                                style="display:block; font-size:0.85em; color:#aaa; font-weight:bold; margin-bottom:12px;">Importovat
                                ze souboru (.xlsx, .xls, .csv)</label>

                            <input type="file" id="input-sched-import" accept=".xlsx, .xls, .csv" style="display:none"
                                onchange="admin.handleScheduleImport(this)">
                            <button class="btn-full" onclick="document.getElementById('input-sched-import').click()"
                                style="background:#555; margin-top:0;">Vybrat soubor...</button>

                            <div
                                style="margin-top:10px; font-size:0.75em; color:#888; border-top:1px solid #444; padding-top:8px;">
                                <b style="color:#bbb; display:block; margin-bottom:4px;">Oƒçek√°van√© sloupce (v
                                    po≈ôad√≠):</b>
                                1. N√°zev / Skupina (A)<br>
                                2. Dom√°c√≠ t√Ωm (B)<br>
                                3. Hostuj√≠c√≠ t√Ωm (C)<br>
                                4. Rozhodƒç√≠ (D)<br>
                                5. D√©lka v min. (E - volitelnƒõ)
                            </div>
                        </div>
                    </div>

                    <!-- Manual Add Section -->
                    <div id="sched-form-container"
                        style="display:none; border:1px solid #444; padding:10px; border-radius:4px; margin-bottom:15px; background:#2a2a2a;">
                        <div class="form-group">
                            <label>Typ polo≈æky</label>
                            <select id="sched-type" onchange="admin.onSchedTypeChange()">
                                <option value="match">Z√°pas</option>
                                <option value="event">Ud√°lost</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>N√°zev / Skupina</label>
                            <div style="display:flex; gap:5px;">
                                <select id="sched-title" style="flex:1">
                                    <option value="Skupina A">Skupina A</option>
                                    <option value="Skupina B">Skupina B</option>
                                    <option value="Skupina C">Skupina C</option>
                                    <option value="Skupina D">Skupina D</option>
                                    <option value="ƒåtvrtfin√°le">ƒåtvrtfin√°le</option>
                                    <option value="Semifin√°le">Semifin√°le</option>
                                    <option value="Fin√°le">Fin√°le</option>
                                    <option value="O um√≠stƒõn√≠">O um√≠stƒõn√≠</option>
                                </select>
                                <input type="text" id="sched-custom-title" placeholder="Vlastn√≠ n√°zev..."
                                    style="flex:1; display:none;">
                            </div>
                        </div>
                        <div id="sched-match-fields">
                            <div class="form-group">
                                <label>Dom√°c√≠</label>
                                <select id="sched-home"></select>
                            </div>
                            <div class="form-group">
                                <label>Host√©</label>
                                <select id="sched-guest"></select>
                            </div>
                            <div class="form-group">
                                <label>Rozhodƒç√≠</label>
                                <select id="sched-referee"></select>
                            </div>
                            <div class="form-group" style="display:flex; gap:10px;">
                                <div style="flex:1">
                                    <label>Sk√≥re Dom.</label>
                                    <input type="number" id="sched-home-score" placeholder="-" style="width:100%"
                                        min="0">
                                </div>
                                <div style="flex:1">
                                    <label>Sk√≥re Host.</label>
                                    <input type="number" id="sched-guest-score" placeholder="-" style="width:100%"
                                        min="0">
                                </div>
                            </div>
                        </div>
                        <div id="sched-event-fields" style="display:none;">
                            <div class="form-group">
                                <label>D√©lka trv√°n√≠ (sekundy)</label>
                                <input type="number" id="sched-duration" value="600" min="1" style="width:100%">
                            </div>
                        </div>
                        <div id="sched-controls-add" style="display:flex; gap:5px;">
                            <button class="btn-full" onclick="admin.addMatch()"
                                title="Ulo≈æit tento z√°pas nebo ud√°lost do rozpisu."
                                style="background: var(--accent-blue);">Ulo≈æit</button>
                            <button class="btn-full btn-yellow" onclick="admin.toggleAddMode()"
                                title="Zav≈ô√≠t formul√°≈ô bez ulo≈æen√≠ zmƒõn.">Zru≈°it</button>
                        </div>
                        <div id="sched-controls-edit" style="display:none; gap:5px; margin-top:10px;">
                            <button class="btn-full btn-green" onclick="admin.saveEditedMatch()">Ulo≈æit
                                Zmƒõny</button>
                            <button class="btn-full btn-red" onclick="admin.deleteMatch()">Smazat</button>
                            <button class="btn-full btn-yellow" onclick="admin.cancelEdit()">Zru≈°it</button>
                        </div>
                    </div>

                    <h4 id="sched-list-header" style="margin-top:5px; border:none;">Po≈ôad√≠:</h4>
                    <div class="schedule-toolbar">
                        <button class="small-btn btn-green" onclick="admin.toggleAddMode()"
                            title="P≈ôidat nov√Ω z√°pas nebo ud√°lost"><b>+</b></button>
                        <button class="small-btn" onclick="admin.moveSelected(-1)" title="Posunout nahoru">‚ñ≤</button>
                        <button class="small-btn" onclick="admin.moveSelected(1)" title="Posunout dol≈Ø">‚ñº</button>
                        <button class="small-btn btn-red" onclick="admin.deleteSelected()"
                            title="Odstranit vybran√©">x</button>
                        <button class="small-btn btn-yellow" onclick="admin.resetSelectedScores()"
                            title="Resetovat sk√≥re">Reset</button>
                        <button class="small-btn btn-yellow" onclick="admin.editSelected()" title="Upravit vybran√Ω"
                            style="margin-left: auto; background: #fbc02d; color: #000;">Upravit</button>
                        <button class="small-btn btn-blue" onclick="admin.loadSelected()" title="Naƒç√≠st vybran√Ω"
                            style="background: var(--accent-blue);">Naƒç√≠st</button>
                    </div>
                    <ul class="match-list" id="match-queue"></ul>
                </div>
            </div>

            <!-- 5. Unified Tables -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-standings')">
                    Tabulky <span>‚ñº</span>
                </div>
                <div id="acc-standings" class="accordion-content">
                    <div class="tab-switcher"
                        style="display: flex; gap: 5px; margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 8px;">
                        <button id="tab-btn-standings" class="small-btn" style="flex: 1;"
                            onclick="admin.setStandingsTab('standings')"
                            title="Zobrazit standardn√≠ tabulku s po≈ôad√≠m, body a sk√≥re.">Po≈ôad√≠</button>
                        <button id="tab-btn-cross" class="small-btn" style="flex: 1;"
                            onclick="admin.setStandingsTab('cross')"
                            title="Zobrazit k≈ô√≠≈æovou tabulku vz√°jemn√Ωch z√°pas≈Ø.">K≈ô√≠≈æov√°</button>
                    </div>
                    <div id="standings-container">
                        <!-- Standard standings or Cross table will be rendered here -->
                    </div>
                </div>
            </div>

            <!-- 4. Export -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-export')">
                    Exporty <span>‚ñº</span>
                </div>
                <div id="acc-export" class="accordion-content">
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                        <button class="btn-full" onclick="exporter.toXLSX()"
                            title="Exportovat rozpis, tabulky a seznam hr√°ƒç≈Ø do Excel souboru (.xlsx)."
                            style="background:#4caf50; margin-top:0;">üìä Excel</button>
                        <button class="btn-full" onclick="exporter.toPrintable()"
                            title="Vygenerovat tiskovou verzi rozpisu a tabulek (otev≈ôe se v nov√©m oknƒõ)."
                            style="background:#2196f3; margin-top:0;">üñ®Ô∏è Pro tisk</button>
                    </div>
                </div>
            </div>

            <!-- 6. Music Player -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-music')">
                    Hudba na pozad√≠ <span>‚ñº</span>
                </div>
                <div id="acc-music" class="accordion-content">
                    <div class="form-group">
                        <button class="btn-full" onclick="music.pickDirectory()"
                            title="Vyberte lok√°ln√≠ slo≈æku s MP3 soubory pro p≈ôehr√°v√°n√≠ na pozad√≠."
                            style="background:#444;">
                            üìÅ Vybrat slo≈æku s hudbou
                        </button>
                    </div>

                    <div id="music-controls"
                        style="display:none; margin-bottom:15px; background:#2a2a2a; padding:10px; border-radius:4px;">
                        <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                            <div style="color:#aaa; font-size:0.8em;">Pr√°vƒõ hraje:</div>
                            <div id="current-track-name"
                                style="flex:1; font-size:0.8em; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color:#4caf50;">
                                -</div>
                        </div>

                        <div class="form-group">
                            <label>Skladby p≈ôehr√°vat</label>
                            <select id="input-music-mode" onchange="music.setMode(this.value)">
                                <option value="continuous">Za sebou (podle seznamu)</option>
                                <option value="random">N√°hodnƒõ</option>
                            </select>
                        </div>
                        <div class="form-group"
                            style="border-top: 1px solid #444; padding-top: 10px; margin-top: 10px;">
                            <label
                                style="display:flex; align-items:center; gap:10px; cursor:pointer; font-weight: bold; color: #4caf50;">
                                <input type="checkbox" id="input-music-auto"
                                    onchange="music.setAutoEnabled(this.checked)" style="width:auto;">
                                Automatick√Ω re≈æim
                            </label>
                        </div>
                        <div class="form-group">
                            <label>Zmƒõna skladby</label>
                            <select id="input-music-auto-change" onchange="music.setAutoChangeStrategy(this.value)">
                                <option value="continuous">Nechat hr√°t celou skladbu</option>
                                <option value="per-step">Mƒõnit skladbu se zmƒõnou kroku</option>
                                <option value="per-match">Mƒõnit skladbu se zmƒõnou z√°pasu</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>D√©lka prolnut√≠: <span id="fade-dur-disp">1</span>s</label>
                            <input type="range" id="input-music-fade" min="0" max="5" step="0.5" value="1"
                                oninput="music.setFadeDuration(this.value)">
                        </div>
                    </div>

                    <ul class="match-list" id="music-list" style="max-height:300px; overflow-y:auto;">
                        <li style="color:#666; font-size:0.8em; text-align:center; padding:10px;">Slo≈æka nebyla
                            vybr√°na
                        </li>
                    </ul>
                </div>
            </div>


            <!-- 5. Application Settings -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-app-settings')">
                    Nastaven√≠ Aplikace <span>‚ñº</span>
                </div>
                <div id="acc-app-settings" class="accordion-content">
                    <h4 style="margin-bottom:10px; border:none;">Cloudov√° Synchronizace</h4>
                    <div class="form-group">
                        <label>Google Drive File ID (Hr√°ƒçi)</label>
                        <input type="text" id="input-cloud-file-id" placeholder="ID souboru z Google Disku"
                            oninput="admin.saveSettings(false)">
                        <small style="color:#888; font-size:0.75em; display:block; margin-top:4px;">
                            ID z√≠sk√°te z odkazu pro sd√≠len√≠ (nap≈ô. 19QC...e1f3). Soubor mus√≠ b√Ωt nastaven na ‚ÄûKdokoli m√°
                            odkaz‚Äú.
                        </small>
                    </div>

                    <h4 style="margin: 20px 0 10px 0; border:none;">Projekƒçn√≠ Okno</h4>
                    <div class="form-group">
                        <label>Vzhled (T√©ma)</label>
                        <select id="input-theme" onchange="admin.saveSettings(false); game.syncProjection()">
                            <option value="light">Svƒõtl√Ω re≈æim (Light Mode)</option>
                            <option value="dark">Tmav√Ω re≈æim (Dark Mode)</option>
                        </select>
                    </div>
                    <div class="form-group"
                        style="background: rgba(26, 115, 232, 0.1); padding: 10px; border-radius: 8px; border: 1px solid var(--accent-blue); margin-top: 10px;">
                        <label style="color: var(--accent-blue); font-weight: bold;">Projekƒçn√≠ URL (pro OBS / druh√Ω
                            monitor)</label>
                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                            <input type="text" id="projection-url-display" readonly
                                style="flex: 1; font-size: 0.8em; background: rgba(0,0,0,0.2); border: 1px solid #555; color: #fff; padding: 5px;">
                            <button class="small-btn"
                                onclick="const el = document.getElementById('projection-url-display'); el.select(); document.execCommand('copy'); alert('URL zkop√≠rov√°na!');"
                                title="Kop√≠rovat">üìã</button>
                        </div>
                        <small style="display: block; margin-top: 5px; color: #aaa; font-size: 0.75em;">Vlo≈æte tuto
                            adresu do OBS Browser Source nebo otev≈ôete v nov√©m oknƒõ.</small>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
                        <button class="btn-full" onclick="admin.openQRWindow()"
                            title="Otev≈ô√≠t samostatn√© okno s QR k√≥dem pro div√°ky."
                            style="background: #e91e63; color: white; font-weight: bold;">üì± Ve≈ôejn√Ω QR k√≥d</button>
                    </div>
                    <div class="form-group" style="margin-top: 10px; font-size: 0.8em; color: #888; text-align: right;">
                        ID Relace: <span id="session-id-display"
                            style="font-family: monospace; font-weight: bold; color: var(--accent-blue);">---</span>
                    </div>
                    <div class="form-group">
                        <label>Prodleva p≈ôed dal≈°√≠ polo≈ækou (s)</label>
                        <input type="number" id="input-po-delay" value="10" min="1" max="30"
                            oninput="admin.saveSettings(false)">
                    </div>


                    <h4 style="margin: 20px 0 10px 0; border:none;">Zvuky a Hlasitost</h4>
                    <div class="form-group">
                        <label>Vlastn√≠ sir√©na</label>
                        <input type="file" id="input-audio-file" accept="audio/*" onchange="admin.saveSettings(false)">
                    </div>

                    <div class="form-group">
                        <label>Hlasitost sir√©ny: <span id="vol-signal-disp">50</span>%</label>
                        <input type="range" id="input-vol-signal" min="0" max="1" step="0.05" value="0.5"
                            oninput="document.getElementById('vol-signal-disp').innerText = Math.round(this.value * 100); admin.saveSettings(false)">
                    </div>

                    <div class="form-group">
                        <label>Hlasitost jingl≈Ø: <span id="vol-anthem-disp">50</span>%</label>
                        <input type="range" id="input-vol-anthem" min="0" max="1" step="0.05" value="0.5"
                            oninput="document.getElementById('vol-anthem-disp').innerText = Math.round(this.value * 100); admin.saveSettings(false)">
                    </div>

                    <div class="form-group" style="padding-top: 10px; margin-top: 10px; border-top: 1px solid #444;">
                        <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
                            <input type="checkbox" id="input-show-footer" onchange="admin.saveSettings(false)"
                                style="width:auto;" checked>
                            Patiƒçka s informacemi
                        </label>
                    </div>

                    <button class="btn-full" style="margin-top:20px; background: var(--accent-blue);"
                        onclick="admin.saveSettings()">Ulo≈æit v≈°echna nastaven√≠</button>
                    <button class="btn-full btn-red" style="margin-top:10px;" onclick="admin.resetApp()">Resetovat
                        celou
                        aplikaci</button>
                </div>
            </div>
        </div> <!-- END of #admin-panel -->
    </div> <!-- END of #app-container -->


    <div id="admin-footer">
        <div id="admin-footer-session"
            style="font-weight:bold; color:var(--accent-blue); text-align:left; font-size:0.8em;">Relace: ---</div>
        <div id="admin-footer-progress">-</div>
        <div id="admin-footer-end">-</div>
        <div id="admin-footer-time">-</div>
    </div>

    <!-- CLEAN PROJECTION LAYOUT -->
    <div id="projection-layout">
        <div id="p-row-top" class="p-row">
            <div id="p-match-title">...</div>
            <div id="p-phase-name">...</div>
            <div id="p-timer">00:00</div>
        </div>

        <div id="p-row-mid" class="p-row">
            <div id="p-match-content">
                <div class="p-team">
                    <div class="p-team-name" id="p-home-name">DOM√ÅC√ç</div>
                    <img id="p-home-logo" class="p-team-logo" src="">
                </div>
                <div id="p-score-box">
                    <span id="p-home-score">0</span>
                    <span id="p-score-sep">:</span>
                    <span id="p-guest-score">0</span>
                </div>
                <div class="p-team">
                    <div class="p-team-name" id="p-guest-name">HOST√â</div>
                    <img id="p-guest-logo" class="p-team-logo" src="">
                </div>
            </div>
            <div id="p-event-content"></div>
        </div>

        <div id="p-row-bot" class="p-row">
            <div id="p-upcoming-header">
                <div></div>
                <div style="text-align:center;">N√ÅSLEDUJE</div>
                <div style="text-align:right;">ROZHODƒå√ç</div>
            </div>
            <div style="padding: 0 4vw; width: 100%; box-sizing: border-box;">
                <table class="p-sched-table">
                    <tbody id="p-upcoming-body"></tbody>
                </table>
            </div>
        </div>

        <div id="p-row-footer" class="p-row">
            <div id="p-footer-progress">Z√°pas: - / -</div>
            <div id="p-footer-end" class="p-footer-center">Konec: --:--</div>
            <div id="p-footer-time" class="p-footer-right">00:00:00</div>
        </div>
    </div>

    <script>
        let projectionWindow = null;
        let qrWindow = null;

        // --- SESSION HANDLING ---
        const SESSION_COLORS = {
            "MODR√Å": "#2196f3",
            "ZELEN√Å": "#4caf50",
            "ƒåERVEN√Å": "#f44336",
            "≈ΩLUT√Å": "#ffc107",
            "ORAN≈ΩOV√Å": "#ff9800",
            "FIALOV√Å": "#9c27b0",
            "B√çL√Å": "#ffffff",
            "≈†ED√Å": "#9e9e9e",
            "R≈Æ≈ΩOV√Å": "#e91e63",
            "TYRKYSOV√Å": "#00bcd4"
        };

        const urlParams = new URLSearchParams(window.location.search);
        const isPO = urlParams.has('projection');
        const isQR = urlParams.get('mode') === 'qr';
        let sessionId = urlParams.get('session');

        if (!sessionId) {
            // Check sessionStorage for persistence across refreshes
            sessionId = sessionStorage.getItem('sb_session_id');
            if (!sessionId) {
                // Generate new hybrid session ID [Mnemonic]-[Random4]
                const mnemonics = Object.keys(SESSION_COLORS);
                const mnemonic = mnemonics[Math.floor(Math.random() * mnemonics.length)];
                const randomPart = Math.random().toString(36).substring(2, 6).toUpperCase();
                sessionId = `${mnemonic}-${randomPart}`;
            }
        }

        // Persist session ID for ZO refreshes (only if not a PO window)
        if (!isPO) {
            sessionStorage.setItem('sb_session_id', sessionId);
        }

        const syncChannel = new BroadcastChannel('sb_sync_' + sessionId);
        // --- DATA STRUCTURES ---
        const PHASES = [
            { id: 0, name: "Nastupuje", timeKey: 'setup' },
            { id: 1, name: "1. Poloƒças", timeKey: 'play' },
            { id: 2, name: "P≈ôest√°vka", timeKey: 'break' },
            { id: 3, name: "2. Poloƒças", timeKey: 'play' }
        ];

        const SCHEDULE_TEMPLATES = {
            "basic_1": {
                name: "Pro 3 dru≈æstva",
                teams: 3,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"]]
            },
            "basic_2": {
                name: "Pro 4 dru≈æstva",
                teams: 4,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"]]
            },
            "basic_3": {
                name: "Pro 5 dru≈æstev",
                teams: 5,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"]]
            },
            "basic_4": {
                name: "Pro 6 dru≈æstev",
                teams: 6,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [5, 6, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 6, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [1, 6, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [3, 6, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"], [4, 6, "Z√°kladn√≠ skupina"]]
            },
            "basic_5": {
                name: "Pro 7 dru≈æstev",
                teams: 7,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [5, 6, "Z√°kladn√≠ skupina"], [1, 7, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [6, 7, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"], [4, 7, "Z√°kladn√≠ skupina"], [1, 6, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [2, 7, "Z√°kladn√≠ skupina"], [4, 6, "Zoladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [3, 7, "Z√°kladn√≠ skupina"], [2, 6, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [5, 7, "Z√°kladn√≠ skupina"], [3, 6, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"]]
            },
            "basic_6": {
                name: "Pro 8 dru≈æstev",
                teams: 8,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [5, 6, "Z√°kladn√≠ skupina"], [7, 8, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"], [3, 6, "Z√°kladn√≠ skupina"], [1, 7, "Z√°kladn√≠ skupina"], [5, 8, "Z√°kladn√≠ skupina"], [4, 6, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [5, 7, "Z√°kladn√≠ skupina"], [1, 8, "Z√°kladn√≠ skupina"], [2, 6, "Z√°kladn√≠ skupina"], [4, 7, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [1, 6, "Z√°kladn√≠ skupina"], [2, 8, "Z√°kladn√≠ skupina"], [3, 7, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [6, 8, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 7, "Z√°kladn√≠ skupina"], [4, 8, "Z√°kladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [6, 7, "Z√°kladn√≠ skupina"], [3, 8, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"]]
            }
        };

        let state = {
            isProjectionMode: isPO,
            sessionId: sessionId,
            tournamentName: "",
            times: { setup: 10, play: 420, break: 105 }, // in seconds
            teams: [],
            teamLogos: {}, // Mapping team name to Base64
            teamAnthems: {}, // Mapping team name to Base64 (MP3)
            volSignal: 0.5,
            volAnthem: 0.5,
            referees: [],
            players: [],
            currentMatch: {
                title: "",
                homeName: "Dom√°c√≠",
                guestName: "Host√©",
                homeScore: 0,
                guestScore: 0,
                referee: "",
                phaseIndex: 0, // 0-3
                isEvent: false,
                duration: 600
            },
            audioData: null, // Base64 string of the audio file
            timer: {
                running: false,
                timeLeft: 0,
                lastTick: 0,
                targetEndTime: 0
            },
            pendingEditIndex: -1, // Tracks which match is being edited
            schedule: [],
            activeMatchIndex: -1, // Track which match from schedule is active
            theme: "dark", // Default to dark for better initial projection appearance
            cloudFileId: "", // Google Drive File ID for players database
            poTransitionActive: false,
            poTransitionData: null,
            poTransitionDelay: 10,
            volMusic: 0.5,
            musicPlaylist: [], // { name: string, handle: FileSystemFileHandle }
            musicAutoEnabled: false,
            musicMode: 'continuous', // 'continuous' or 'random'
            musicFadeDuration: 1,
            musicAutoChangeStrategy: 'continuous', // 'continuous', 'per-step', 'per-match'
            musicPreviousPhase: -1, // Track previous phase for direction detection
            selectedIndices: [], // Track selected matches
            tournamentStartTime: null, // Timestamp when first timer starts
            playTimeAccumulated: 0, // Seconds of actual play time (halves) completed
            showFooter: true,
            rules: {
                winPoints: 3,
                drawPoints: 1,
                lossPoints: 0,
                useMiniTables: false
            },
            activeStandingsTab: 'standings' // 'standings' or 'cross'
        };


        let musicAudioA = new Audio();
        let musicAudioB = new Audio();
        let currentMusicAudio = musicAudioA; // Which one is currently playing
        let currentAnthemAudio = null;
        let currentMusicIndex = -1;
        let directoryHandle = null;

        let poTransitionTimeoutID = null;

        // --- CORE LOGIC CLASS ---
        const game = {
            init: () => {
                if (state.isProjectionMode) {
                    document.body.classList.add('mode-projection');

                    console.log("Projection: INIT starting");

                    ui.updateProjection();

                    // HANDLER for both BroadcastChannel and Direct window messages
                    const handleSync = (receivedState) => {
                        if (!receivedState || typeof receivedState !== 'object') return;
                        if (receivedState === 'REQUEST_SYNC') return; // Ignore strings

                        const mode = state.isProjectionMode;
                        Object.assign(state, receivedState);
                        state.isProjectionMode = mode;

                        // Data received
                        ui.updateProjection();
                    };

                    // 1. BroadcastChannel Listener (for OBS / different origins)
                    syncChannel.onmessage = (event) => handleSync(event.data);

                    // 2. Window Message Listener (for window.open direct communication)
                    window.addEventListener('message', (event) => handleSync(event.data));

                    // Request immediate sync from admin
                    syncChannel.postMessage('REQUEST_SYNC');

                    // Initial update for clock
                    setInterval(() => {
                        const now = new Date();
                        const dateStr = now.getFullYear() + '-' + (now.getMonth() + 1).toString().padStart(2, '0') + '-' + now.getDate().toString().padStart(2, '0');
                        const timeEl = document.getElementById('p-footer-time');
                        if (timeEl) timeEl.innerText = `${dateStr}\u00A0\u00A0\u00A0\u00A0${now.toLocaleTimeString('cs-CZ')}`;
                    }, 1000);
                    ui.updateProjection();
                    return;
                }

                try {
                    // Hybrid Session ID Branding
                    const colorCode = state.sessionId.split('-')[0];
                    const stripeColor = SESSION_COLORS[colorCode] || 'transparent';
                    const stripe = document.getElementById('admin-header-stripe');
                    if (stripe) {
                        stripe.style.background = stripeColor;
                        stripe.style.display = 'block';
                    }

                    // Display Session ID in settings
                    const sidDisp = document.getElementById('session-id-display');
                    if (sidDisp) sidDisp.innerText = state.sessionId;

                    // Update the URL display for OBS/copying
                    const purlDisp = document.getElementById('projection-url-display');
                    if (purlDisp) {
                        purlDisp.value = window.location.origin + window.location.pathname + '?projection&session=' + state.sessionId;
                    }

                    admin.loadFromStorage();
                    ui.renderSchedule();
                    ui.render();

                    // Listen for sync requests from projection windows
                    syncChannel.onmessage = (event) => {
                        if (event.data === 'REQUEST_SYNC') {
                            game.syncProjection();
                        }
                    };

                    setInterval(() => game.tick(), 100);
                    setInterval(() => ui.updateAdminFooter(), 1000);
                } catch (e) {
                    console.error("Initialization error:", e);
                }
            },

            tick: () => {
                if (!state.timer.running) return;

                const now = Date.now();
                const remainingMs = state.timer.targetEndTime - now;
                const newTimeLeft = Math.max(0, Math.floor(remainingMs / 1000));

                // Track play time accumulation
                if (state.currentMatch.phaseIndex === 1 || state.currentMatch.phaseIndex === 3) {
                    const elapsedSinceLastTick = (now - state.timer.lastTick) / 1000;
                    state.playTimeAccumulated += elapsedSinceLastTick;
                }
                state.timer.lastTick = now;

                if (newTimeLeft !== state.timer.timeLeft) {
                    state.timer.timeLeft = newTimeLeft;

                    if (state.timer.timeLeft <= 0) {
                        state.timer.timeLeft = 0;
                        game.toggleTimer(); // Stop at 0

                        // Play signal only for 1. Poloƒças (1) and 2. Poloƒças (3)
                        if (state.currentMatch.phaseIndex === 1 || state.currentMatch.phaseIndex === 3) {
                            game.playSignal();
                        }
                    }

                    ui.updateTimer();
                    game.syncProjection();
                    ui.updateAdminFooter();
                }
            },

            toggleTimer: () => {
                state.timer.running = !state.timer.running;
                if (state.timer.running) {
                    state.timer.lastTick = Date.now();
                    state.timer.targetEndTime = Date.now() + (state.timer.timeLeft * 1000) - 1;
                    // Set tournament start time if not already set
                    if (state.tournamentStartTime === null) {
                        state.tournamentStartTime = Date.now();
                    }
                    // Immediate first tick to reflect visual change (e.g. 7:00 -> 6:59)
                    game.tick();
                } else {
                    // When pausing, state.timer.timeLeft is already up to date from tick()
                    // but we capture the exact remaining time (float) to preserve precision for resume
                    const remainingMs = state.timer.targetEndTime - Date.now();
                    state.timer.timeLeft = Math.max(0, remainingMs / 1000);
                }
                ui.updateTimerBtn();
                game.syncProjection();
            },

            getPhaseCount: () => {
                return state.currentMatch.isEvent ? 1 : PHASES.length;
            },

            resetTimer: () => {
                state.timer.running = false;
                if (state.currentMatch.isEvent) {
                    state.timer.timeLeft = state.currentMatch.duration || 600;
                } else {
                    const currentPhase = PHASES[state.currentMatch.phaseIndex];
                    state.timer.timeLeft = state.times[currentPhase.timeKey];
                }
                state.timer.targetEndTime = Date.now() + (state.timer.timeLeft * 1000);

                ui.updateTimer();
                ui.updateTimerBtn();
                game.syncProjection();
            },

            adjustTime: (seconds) => {
                state.timer.timeLeft += seconds;
                if (state.timer.timeLeft < 0) state.timer.timeLeft = 0;
                if (state.timer.running) {
                    state.timer.targetEndTime += (seconds * 1000);
                }
                ui.updateTimer();
                game.syncProjection();
            },

            manualTimeEntry: () => {
                const el = document.getElementById('main-timer');
                const val = el.textContent.trim();
                const parts = val.split(':');
                if (parts.length === 2) {
                    const m = parseInt(parts[0]);
                    const s = parseInt(parts[1]);
                    if (!isNaN(m) && !isNaN(s)) {
                        state.timer.timeLeft = (m * 60) + s;
                        if (state.timer.running) {
                            state.timer.targetEndTime = Date.now() + (state.timer.timeLeft * 1000);
                        }
                    }
                }
                ui.updateTimer();
                game.syncProjection();
            },

            adjustScore: (team, delta, playSound = false) => {
                const isHome = team === 'home';
                if (isHome) {
                    state.currentMatch.homeScore += delta;
                    if (state.currentMatch.homeScore < 0) state.currentMatch.homeScore = 0;
                } else {
                    state.currentMatch.guestScore += delta;
                    if (state.currentMatch.guestScore < 0) state.currentMatch.guestScore = 0;
                }

                if (playSound && delta > 0) {
                    const teamName = isHome ? state.currentMatch.homeName : state.currentMatch.guestName;
                    game.playTeamAnthem(teamName);
                }

                ui.updateScores();
                game.syncProjection();
            },

            playTeamAnthem: (teamName) => {
                const audioData = state.teamAnthems[teamName];
                if (audioData) {
                    if (currentAnthemAudio) {
                        currentAnthemAudio.pause();
                        currentAnthemAudio = null;
                    }

                    // P≈ôeru≈°it hudbu na pozad√≠, pokud hraje
                    if (!currentMusicAudio.paused) {
                        currentMusicAudio.pause();
                        clearInterval(music.fadeInterval);
                        music.fadeInterval = null;
                    }

                    currentAnthemAudio = new Audio(audioData);
                    currentAnthemAudio.volume = state.volAnthem || 1.0;
                    currentAnthemAudio.play().catch(e => console.warn("Anthem play failed:", e));
                }
            },

            triggerPoTransition: (snapshot) => {
                if (poTransitionTimeoutID) clearTimeout(poTransitionTimeoutID);

                state.poTransitionData = snapshot;
                state.poTransitionActive = true;

                poTransitionTimeoutID = setTimeout(() => {
                    state.poTransitionActive = false;
                    state.poTransitionData = null;
                    game.syncProjection();
                }, (state.poTransitionDelay || 10) * 1000);
            },

            step: (direction) => {
                let newPhaseIndex = state.currentMatch.phaseIndex + direction;
                const phaseCount = game.getPhaseCount();

                // Moving Forward past last phase -> Next Match
                if (newPhaseIndex >= phaseCount) {
                    if (game.loadMatchByRelativeIndex(1)) {
                        // Match loaded, transition handled inside loadMatchByRelativeIndex
                        return;
                    } else {
                        // No next match, stay at end
                        // BUT still save the result of the current last match!
                        if (!state.currentMatch.isEvent && state.activeMatchIndex !== -1 && state.schedule[state.activeMatchIndex]) {
                            state.schedule[state.activeMatchIndex].homeScore = state.currentMatch.homeScore;
                            state.schedule[state.activeMatchIndex].guestScore = state.currentMatch.guestScore;
                            ui.renderSchedule();
                            ui.renderStandings(); // UPDATE STANDINGS
                            admin.saveToStorage(); game.syncProjection();
                            alert("Konec turnaje (nebo posledn√≠ z√°pas). V√Ωsledek ulo≈æen.");
                        }
                        newPhaseIndex = phaseCount - 1;
                    }
                }

                // Moving Backward before first phase -> Prev Match
                if (newPhaseIndex < 0) {
                    if (game.loadMatchByRelativeIndex(-1)) {
                        // Match loaded, phase set inside that function (to last)
                        return;
                    } else {
                        newPhaseIndex = 0;
                    }
                }

                if (newPhaseIndex !== state.currentMatch.phaseIndex) {
                    game.setPhase(newPhaseIndex, true);
                }
            },

            setPhase: (index, resetTime) => {
                // P≈ôeru≈°it prodlevu/blik√°n√≠, pokud zaƒç√≠n√° poloƒças (index 1 nebo 3)
                if ((index === 1 || index === 3) && state.poTransitionActive) {
                    if (poTransitionTimeoutID) clearTimeout(poTransitionTimeoutID);
                    state.poTransitionActive = false;
                    state.poTransitionData = null;
                }

                state.currentMatch.phaseIndex = index;
                if (resetTime) {
                    game.resetTimer();
                }

                // Auto music control
                const previousPhase = state.musicPreviousPhase;
                state.musicPreviousPhase = index; // Update for next time

                if (index === 0 || index === 2) {
                    music.resumeAuto(index, previousPhase); // Pass current and previous phase
                } else {
                    music.pauseAuto(); // Pause (not stop)
                }

                ui.renderPhase();
                game.syncProjection();
            },

            // Returns true if match change was successful
            loadMatchByRelativeIndex: (offset) => {
                // Auto-Save Score of currently active match before switching
                if (state.activeMatchIndex !== -1 && state.schedule[state.activeMatchIndex]) {
                    state.schedule[state.activeMatchIndex].homeScore = state.currentMatch.homeScore;
                    state.schedule[state.activeMatchIndex].guestScore = state.currentMatch.guestScore;
                }

                let targetIndex = state.activeMatchIndex;
                if (targetIndex === -1) {
                    if (offset > 0) targetIndex = 0;
                } else {
                    targetIndex += offset;
                }

                if (targetIndex >= 0 && targetIndex < state.schedule.length) {
                    // Capture snapshot for PO delay only when moving to NEXT match
                    let snapshot = null;
                    if (offset > 0) {
                        snapshot = JSON.parse(JSON.stringify(state));
                    }

                    admin.loadMatch(targetIndex, false, snapshot);

                    // Check if we should change track when loading new match
                    if (state.musicAutoChangeStrategy === 'per-match' && state.musicAutoEnabled) {
                        music.startNewTrack();
                    }

                    if (offset < 0) {
                        game.setPhase(game.getPhaseCount() - 1, true);
                    } else {
                        game.setPhase(0, true);
                    }
                    return true;
                }
                return false;
            },

            getTelemetry: () => {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('cs-CZ');
                const dateStr = now.getFullYear() + '-' + (now.getMonth() + 1).toString().padStart(2, '0') + '-' + now.getDate().toString().padStart(2, '0');
                const fullTimeStr = `${dateStr}\u00A0\u00A0\u00A0\u00A0${timeStr}`;

                const currentIdx = state.activeMatchIndex;
                const totalItems = (state.schedule || []).length;
                const progressStr = `Pr√°vƒõ se hraje: ${currentIdx + 1} z ${totalItems}`;

                // Average "Planned" overhead per match (Setup + Break)
                const s = state.times.setup || 0;
                const b = state.times.break || 0;
                const p = state.times.play || 0;
                const plannedOverhead = s + b;

                // Adjust based on real performance if tournament started
                if (state.tournamentStartTime && state.activeMatchIndex > 0) {
                    const realElapsed = (Date.now() - state.tournamentStartTime) / 1000;
                    const playElapsed = state.playTimeAccumulated || 0;
                    const totalOverhead = Math.max(0, realElapsed - playElapsed);
                    learnedOverhead = totalOverhead / state.activeMatchIndex;

                    // Lag is the delay compared to theoretical plan
                    avgLag = Math.max(0, learnedOverhead - plannedOverhead);

                    // Clamp to reasonable range (max 10 mins extra per match)
                    avgLag = Math.min(600, avgLag);
                }

                let remainingSeconds = state.timer.running
                    ? (state.timer.targetEndTime - Date.now()) / 1000
                    : state.timer.timeLeft;

                // Current item progress
                if (currentIdx !== -1 && state.schedule[currentIdx]) {
                    const m = state.schedule[currentIdx];
                    if (m.type === 'match') {
                        const curPhase = state.currentMatch.phaseIndex;
                        // Ph 0 (Setup): + P1, B, P2
                        if (curPhase === 0) remainingSeconds += (p * 2) + b + (avgLag * 0.8);
                        // Ph 1 (P1): + B, P2
                        else if (curPhase === 1) remainingSeconds += p + b + (avgLag * 0.5);
                        // Ph 2 (Break): + P2
                        else if (curPhase === 2) remainingSeconds += p + (avgLag * 0.2);
                        // Ph 3 (P2): already covered by timer
                    }
                }

                // Upcoming items
                (state.schedule || []).slice(currentIdx + 1).forEach(m => {
                    if (m.type === 'event') {
                        remainingSeconds += (m.duration || 600);
                        remainingSeconds += (avgLag * 0.5); // Add partial lag for events too
                    } else {
                        remainingSeconds += (p * 2) + plannedOverhead + avgLag;
                    }
                });

                const endTime = new Date(now.getTime() + remainingSeconds * 1000);
                const endStr = `P≈ôedpokl√°dan√Ω konec: ${endTime.toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' })}`;

                return {
                    progress: progressStr,
                    end: endStr,
                    time: fullTimeStr
                };
            },

            syncProjection: () => {
                const payload = { ...state, telemetry: game.getTelemetry() };
                // Send to BroadcastChannel for all listeners (OBS, other tabs)
                syncChannel.postMessage(JSON.parse(JSON.stringify(payload)));

                // Legacy window.postMessage for the specific window opened via button
                if (projectionWindow && !projectionWindow.closed) {
                    projectionWindow.postMessage(JSON.parse(JSON.stringify(payload)), '*');
                }
                ui.updateAdminFooter();
            },

            reorderSchedule: (fromIndex, toIndex) => {
                const item = state.schedule.splice(fromIndex, 1)[0];
                state.schedule.splice(toIndex, 0, item);

                // Adjust active match index if needed
                if (state.activeMatchIndex === fromIndex) {
                    state.activeMatchIndex = toIndex;
                } else if (state.activeMatchIndex > fromIndex && state.activeMatchIndex <= toIndex) {
                    state.activeMatchIndex--;
                } else if (state.activeMatchIndex < fromIndex && state.activeMatchIndex >= toIndex) {
                    state.activeMatchIndex++;
                }

                ui.renderSchedule();
                admin.saveToStorage(); game.syncProjection();
            },

            playSignal: () => {
                // P≈ôeru≈°it aktu√°lnƒõ hraj√≠c√≠ jingle, pokud nƒõjak√Ω hraje
                if (currentAnthemAudio) {
                    currentAnthemAudio.pause();
                    currentAnthemAudio = null;
                }

                // P≈ôeru≈°it hudbu na pozad√≠, pokud hraje
                if (!currentMusicAudio.paused) {
                    currentMusicAudio.pause();
                    clearInterval(music.fadeInterval);
                    music.fadeInterval = null;
                }

                if (state.audioData) {
                    try {
                        const snd = new Audio(state.audioData);
                        snd.volume = state.volSignal || 1.0;
                        snd.play().catch(e => console.error("Audio play failed:", e));
                    } catch (err) {
                        console.error("Invalid audio data", err);
                    }
                }
            }
        };

        // --- ADMIN HELPERS ---
        const admin = {
            saveSettings: (showAlert = true) => {
                state.tournamentName = document.getElementById('input-tournament-name').value;

                state.times.setup = Math.max(0, parseInt(document.getElementById('time-setup').value || 10));
                state.times.play = Math.max(0, parseInt(document.getElementById('time-play').value || 420));
                state.times.break = Math.max(0, parseInt(document.getElementById('time-break').value || 105));

                state.rules.winPoints = parseInt(document.getElementById('rule-win').value || 3);
                state.rules.drawPoints = parseInt(document.getElementById('rule-draw').value || 1);
                state.rules.lossPoints = parseInt(document.getElementById('rule-loss').value || 0);
                state.rules.useMiniTables = document.getElementById('rule-mini-tables').checked;

                // Save teams from dynamic list
                state.teams = [];
                const teamInputs = document.querySelectorAll('.team-name-input');
                teamInputs.forEach(input => {
                    const id = input.dataset.id;
                    const name = input.value.trim();
                    if (id) {
                        state.teams.push({ id, name: name || "Dru≈æstvo" });
                    }
                });

                // Save referees from dynamic list
                state.referees = [];
                const refInputs = document.querySelectorAll('.ref-name-input');
                refInputs.forEach(input => {
                    const id = input.dataset.id;
                    const name = input.value.trim();
                    if (id) {
                        state.referees.push({ id, name: name || "Rozhodƒç√≠" });
                    }
                });

                state.volSignal = parseFloat(document.getElementById('input-vol-signal').value);
                state.volAnthem = parseFloat(document.getElementById('input-vol-anthem').value);
                state.showFooter = document.getElementById('input-show-footer').checked;
                state.theme = document.getElementById('input-theme').value;
                state.cloudFileId = document.getElementById('input-cloud-file-id').value.trim();

                const fileInput = document.getElementById('input-audio-file');
                if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    if (file.size > 2 * 1024 * 1024) { // 2MB limit check
                        alert("Soubor je p≈ô√≠li≈° velk√Ω (>2MB). Zvolte men≈°√≠ MP3.");
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        state.audioData = e.target.result;
                        finishSave();
                    };
                    reader.readAsDataURL(file);
                } else {
                    finishSave();
                }

                function finishSave() {
                    admin.saveToStorage(); game.syncProjection();
                    ui.fillSelects();
                    ui.renderSchedule();
                    admin.renderIdentityInputs(); // Refresh labels
                    ui.updateFooterVisibility();
                    game.resetTimer();
                    game.syncProjection();
                    if (showAlert) alert("Nastaven√≠ ulo≈æeno.");
                }
            },

            formatTime: (totalSeconds) => {
                if (isNaN(totalSeconds) || totalSeconds < 0) return "0:00";
                if (totalSeconds >= 3600) return "59:59";
                const m = Math.floor(totalSeconds / 60);
                const s = totalSeconds % 60;
                // User requirement: no leading zero for whole minutes (e.g. 7:00 instead of 07:00)
                // m.toString() naturally has no leading zero.
                return `${m}:${s.toString().padStart(2, '0')}`;
            },

            validateTimeInput: (input) => {
                // Ensure max 4 digits
                if (input.value.length > 4) {
                    input.value = input.value.slice(0, 4);
                }

                let val = parseInt(input.value);
                if (!isNaN(val)) {
                    // Force cap at 3599
                    if (val > 3599) {
                        input.value = 3599;
                    }
                }

                // Save and update UI
                admin.saveSettings(false);
                ui.render();
            },

            renderIdentityInputs: () => {
                // Teams
                const teamList = document.getElementById('teams-input-list');
                teamList.innerHTML = "";
                state.teams.forEach((team, idx) => {
                    admin.renderIdentityRow(teamList, team, idx, 'team');
                });

                // Referees
                const refList = document.getElementById('referees-input-list');
                refList.innerHTML = "";
                state.referees.forEach((ref, idx) => {
                    admin.renderIdentityRow(refList, ref, idx, 'ref');
                });

                // Players
                const playerList = document.getElementById('players-input-list');
                if (playerList) {
                    playerList.innerHTML = "";
                    state.players.forEach((player, idx) => {
                        admin.renderPlayerRow(playerList, player, idx);
                    });
                }
            },

            renderPlayerRow: (container, item, index) => {
                const div = document.createElement('div');
                div.className = "player-input-row";
                div.style.display = "flex";
                div.style.gap = "5px";
                div.style.alignItems = "center";
                div.style.marginBottom = "8px";
                div.style.padding = "8px";
                div.style.background = "#333";
                div.style.borderRadius = "4px";

                const label = document.createElement('span');
                label.style.width = "40px";
                label.style.fontSize = "0.7em";
                label.style.color = "#888";
                label.innerText = "#" + (index + 1);

                // Surname
                const surnameInput = document.createElement('input');
                surnameInput.type = "text";
                surnameInput.placeholder = "P≈ô√≠jmen√≠";
                surnameInput.value = item.surname || "";
                surnameInput.style.flex = "2";
                surnameInput.oninput = () => {
                    item.surname = surnameInput.value;
                    admin.saveToStorage(); game.syncProjection();
                };

                // Name
                const nameInput = document.createElement('input');
                nameInput.type = "text";
                nameInput.placeholder = "Jm√©no";
                nameInput.value = item.firstName || "";
                nameInput.style.flex = "2";
                nameInput.oninput = () => {
                    item.firstName = nameInput.value;
                    admin.saveToStorage(); game.syncProjection();
                };

                // UCI-ID
                const uciInput = document.createElement('input');
                uciInput.type = "text";
                uciInput.placeholder = "UCI-ID";
                uciInput.value = item.uciId || "";
                uciInput.style.flex = "3";
                uciInput.maxLength = 11;
                uciInput.oninput = () => {
                    const newVal = uciInput.value.trim();
                    // Basic validation: check if UCI-ID is already taken by ANOTHER player
                    if (newVal && state.players.some(p => p.uciId === newVal && p.id !== item.id)) {
                        uciInput.style.border = "1px solid red";
                    } else {
                        uciInput.style.border = "";
                        item.uciId = newVal;
                        // If UCI-ID is set, we could potentially use it as ID, 
                        // but it's safer to keep the persistent internal ID for references 
                        // and just use UCI-ID for reconciling during import/export.
                        admin.saveToStorage(); game.syncProjection();
                    }
                };

                const removeBtn = document.createElement('button');
                removeBtn.className = "small-btn btn-red";
                removeBtn.innerText = "x";
                removeBtn.onclick = () => {
                    state.players = state.players.filter(p => p.id !== item.id);
                    admin.renderIdentityInputs();
                    admin.saveToStorage(); game.syncProjection();
                };

                div.appendChild(label);
                div.appendChild(surnameInput);
                div.appendChild(nameInput);
                div.appendChild(uciInput);
                div.appendChild(removeBtn);
                container.appendChild(div);
            },

            renderIdentityRow: (container, item, index, type) => {
                const div = document.createElement('div');
                div.style.display = "flex";
                div.style.gap = "5px";
                div.style.alignItems = "center";

                const label = document.createElement('span');
                label.style.width = "80px";
                label.style.fontSize = "0.8em";
                label.style.color = "#888";
                label.innerText = (type === 'team' ? "Dru≈æstvo " : "Rozhodƒç√≠ ") + (index + 1);

                const input = document.createElement('input');
                input.type = "text";
                input.className = type === 'team' ? "team-name-input" : "ref-name-input";
                input.dataset.id = item.id;
                input.value = item.name;
                input.maxLength = 20;
                input.style.flex = "1";
                input.oninput = () => {
                    item.name = input.value;
                    if (type === 'team') {
                        admin.renderLogoSettings();
                        ui.updateNames();
                    }
                    ui.fillSelects();
                    ui.renderSchedule();
                    admin.saveToStorage(); game.syncProjection(); // Auto-save on name change
                };

                const removeBtn = document.createElement('button');
                removeBtn.className = "small-btn btn-red";
                removeBtn.innerText = "x";
                removeBtn.onclick = () => {
                    if (type === 'team') {
                        state.teams = state.teams.filter(t => t.id !== item.id);
                    } else {
                        state.referees = state.referees.filter(r => r.id !== item.id);
                    }
                    admin.renderIdentityInputs();
                    admin.renderLogoSettings();
                    admin.saveToStorage(); game.syncProjection(); // Auto-save on removal
                };

                div.appendChild(label);
                div.appendChild(input);
                div.appendChild(removeBtn);
                container.appendChild(div);
            },

            addTeamSlot: () => {
                const id = "team_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                state.teams.push({ id, name: "" });
                admin.renderIdentityInputs();
                admin.saveToStorage(); game.syncProjection();
            },

            addRefereeSlot: () => {
                const id = "ref_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                state.referees.push({ id, name: "" });
                admin.renderIdentityInputs();
                admin.saveToStorage(); game.syncProjection();
            },

            addPlayerSlot: () => {
                const id = "player_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                state.players.push({ id, surname: "", firstName: "", uciId: "" });
                admin.renderIdentityInputs();
                admin.saveSettings(false);
            },

            // SHA-256 Hash with fallback for non-secure contexts (local file://)
            _hash: async (text) => {
                try {
                    if (window.crypto && crypto.subtle) {
                        const msgUint8 = new TextEncoder().encode(text);
                        const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                    }
                } catch (e) { console.warn("Crypto API failed, using fallback."); }

                // Fallback: Simple deterministic "hash" for deterrent purposes 
                // ONLY used when modern Crypto API is unavailable (e.g. local file)
                let h = 0;
                for (let i = 0; i < text.length; i++) {
                    h = ((h << 5) - h) + text.charCodeAt(i);
                    h |= 0;
                }
                return "fallback_" + Math.abs(h).toString(16);
            },

            openQRWindow: () => {
                const url = window.location.origin + window.location.pathname + '?projection&mode=qr&session=' + state.sessionId;
                qrWindow = window.open(url, 'sb_qr_' + state.sessionId, 'width=600,height=800');
            },

            // BAKED-IN PASSWORD HASHES
            _targetHash: "39a2c54c5bdaad1c10d81f97243bc7c4c90dbb1ed7c6526886dc243259dd0310",
            _fallbackHash: "fallback_5076cf47", // "KolovaOlomouc1962"

            // Reusable admin verification
            verifyAdminPassword: async () => {
                const pass = prompt("Zadejte administraƒçn√≠ heslo:");
                if (!pass) return false;
                const hashed = await admin._hash(pass);
                if (hashed === admin._targetHash || hashed === admin._fallbackHash) return true;
                alert("≈†patn√© heslo. P≈ô√≠stup odep≈ôen.");
                return false;
            },

            exportPlayersWithPassword: async () => {
                if (await admin.verifyAdminPassword()) {
                    admin.exportPlayers();
                }
            },

            updatePlayersFromCloud: async () => {
                let fileId = state.cloudFileId;
                if (!fileId) {
                    alert("Chyb√≠ Google Drive File ID v nastaven√≠ aplikace.");
                    toggleAccordion('acc-app-settings');
                    return;
                }

                // If user pasted a full URL, try to extract the ID
                if (fileId.includes("drive.google.com")) {
                    const match = fileId.match(/\/d\/([a-zA-Z0-9_-]+)/) || fileId.match(/[?&]id=([a-zA-Z0-9_-]+)/);
                    if (match && match[1]) {
                        fileId = match[1];
                        console.log("Extrahov√°no ID z URL:", fileId);
                    }
                }

                const btn = document.querySelector('button[onclick="admin.updatePlayersFromCloud()"]');
                const originalText = btn.innerText;
                btn.innerText = "‚è≥ Stahov√°n√≠...";
                btn.disabled = true;

                try {
                    // Try multiple Google Drive URL formats
                    const methods = [
                        // Method 1: Direct download link
                        `https://drive.google.com/uc?export=download&id=${fileId}`,
                        // Method 2: Alternative format
                        `https://drive.usercontent.google.com/download?id=${fileId}&export=download`,
                        // Method 3: Via CORS proxy
                        `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://drive.google.com/uc?export=download&id=${fileId}`)}`
                    ];

                    let lastError = null;
                    let imported = null;

                    for (let i = 0; i < methods.length; i++) {
                        const url = methods[i];
                        try {
                            console.log(`Pokus ${i + 1}/${methods.length}:`, url);
                            const resp = await fetch(url);
                            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

                            const text = await resp.text();
                            if (text.trim().startsWith('<')) throw new Error("HTML m√≠sto JSON");

                            imported = JSON.parse(text);
                            if (!Array.isArray(imported)) throw new Error("Nen√≠ pole");

                            console.log("‚úì √öspƒõch metodou", i + 1);
                            break;
                        } catch (err) {
                            lastError = err;
                            console.warn(`‚úó Metoda ${i + 1} selhala:`, err.message);
                        }
                    }

                    if (!imported) {
                        throw new Error(`V≈°echny metody selhaly.\n\nPosledn√≠ chyba: ${lastError?.message}\n\nZkontrolujte File ID a sd√≠len√≠.`);
                    }

                    // Reuse the existing conflict logic
                    admin.importPlayersData(imported);

                } catch (err) {
                    alert("Chyba p≈ôi aktualizaci z cloudu: " + err.message);
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            },

            // Helper to handle data without File object
            importPlayersData: (imported) => {
                const conflicts = [];
                const newEntries = [];

                imported.forEach(pImp => {
                    const byUci = pImp.uciId ? state.players.find(p => p.uciId === pImp.uciId) : null;
                    const byName = state.players.find(p =>
                        p.surname?.toLowerCase() === pImp.surname?.toLowerCase() &&
                        p.firstName?.toLowerCase() === pImp.firstName?.toLowerCase()
                    );

                    if (byUci || byName) {
                        conflicts.push({
                            imported: pImp,
                            existing: byUci || byName,
                            type: byUci ? 'uci' : 'name',
                            choice: 'keep'
                        });
                    } else {
                        newEntries.push(pImp);
                    }
                });

                if (conflicts.length > 0) {
                    admin.showConflictReview(conflicts, newEntries);
                } else {
                    newEntries.forEach(p => {
                        if (!p.id) p.id = "player_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                        state.players.push(p);
                    });
                    admin.renderIdentityInputs();
                    admin.saveToStorage(); game.syncProjection();
                    alert(`Importov√°no ${newEntries.length} nov√Ωch hr√°ƒç≈Ø.`);
                }
            },

            exportPlayers: () => {
                if (state.players.length === 0) {
                    alert("Seznam hr√°ƒç≈Ø je pr√°zdn√Ω.");
                    return;
                }
                const dataStr = JSON.stringify(state.players, null, 2);
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.href = url;
                link.download = `CycleBall_UCI-ID.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            },

            importPlayers: (input) => {
                const file = input.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (!Array.isArray(imported)) throw new Error("Neplatn√Ω form√°t dat.");

                        const conflicts = [];
                        const newEntries = [];

                        imported.forEach(pImp => {
                            // Find conflicts by UCI or Name
                            const byUci = pImp.uciId ? state.players.find(p => p.uciId === pImp.uciId) : null;
                            const byName = state.players.find(p =>
                                p.surname?.toLowerCase() === pImp.surname?.toLowerCase() &&
                                p.firstName?.toLowerCase() === pImp.firstName?.toLowerCase()
                            );

                            if (byUci || byName) {
                                conflicts.push({
                                    imported: pImp,
                                    existing: byUci || byName,
                                    type: byUci ? 'uci' : 'name',
                                    choice: 'keep' // Default choice
                                });
                            } else {
                                newEntries.push(pImp);
                            }
                        });

                        if (conflicts.length > 0) {
                            admin.showConflictReview(conflicts, newEntries);
                        } else {
                            // No conflicts, just merge
                            newEntries.forEach(p => {
                                if (!p.id) p.id = "player_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                                state.players.push(p);
                            });
                            admin.renderIdentityInputs();
                            admin.saveToStorage(); game.syncProjection();
                            alert(`Importov√°no ${newEntries.length} nov√Ωch hr√°ƒç≈Ø.`);
                        }
                    } catch (err) {
                        alert("Chyba p≈ôi importu: " + err.message);
                    }
                    input.value = "";
                };
                reader.readAsText(file);
            },

            showConflictReview: (conflicts, newEntries) => {
                const modal = document.getElementById('modal-player-conflicts');
                const container = document.getElementById('conflict-list-container');
                container.innerHTML = "";
                modal.style.display = 'flex';

                conflicts.forEach((conf, idx) => {
                    const row = document.createElement('div');
                    row.className = "conflict-row";

                    const headerTxt = conf.type === 'uci' ? `Shoda v UCI-ID: ${conf.imported.uciId}` : `Shoda ve jm√©nƒõ: ${conf.imported.surname} ${conf.imported.firstName}`;

                    row.innerHTML = `
                        <div class="conflict-header">${headerTxt}</div>
                        <div class="conflict-grid">
                            <div class="conflict-cell">
                                <span class="conflict-label">St√°vaj√≠c√≠ v SB</span>
                                <div class="conflict-value">${conf.existing.surname} ${conf.existing.firstName}</div>
                                <div class="conflict-value" style="font-size:0.8em; color:#888;">UCI: ${conf.existing.uciId || "-"}</div>
                            </div>
                            <div class="conflict-cell" style="border-left:1px solid #333;">
                                <span class="conflict-label">V importovan√©m souboru</span>
                                <div class="conflict-value ${conf.existing.surname !== conf.imported.surname || conf.existing.firstName !== conf.imported.firstName ? 'val-diff' : ''}">
                                    ${conf.imported.surname} ${conf.imported.firstName}
                                </div>
                                <div class="conflict-value ${conf.existing.uciId !== conf.imported.uciId ? 'val-diff' : ''}" style="font-size:0.8em;">
                                    UCI: ${conf.imported.uciId || "-"}
                                </div>
                            </div>
                        </div>
                        <div class="conflict-choice" id="choice-group-${idx}">
                            <button class="choice-btn active" onclick="admin.setConflictChoice(${idx}, 'keep')"
                                title="Data v aplikaci SB z≈Østanou beze zmƒõny. Ignorovat data z cloudu/souboru.">Ponechat p≈Øvodn√≠</button>
                            <button class="choice-btn" onclick="admin.setConflictChoice(${idx}, 'update')"
                                title="Aktualizovat st√°vaj√≠c√≠ho hr√°ƒçe v SB daty z cloudu/souboru.">P≈ôepsat z cloudu</button>
                            <button class="choice-btn" onclick="admin.setConflictChoice(${idx}, 'both')"
                                title="V SB z≈Østane st√°vaj√≠c√≠ z√°znam a z√°rove≈à se vytvo≈ô√≠ nov√Ω z importu (budou tam oba).">Ponechat oba</button>
                        </div>
                    `;
                    container.appendChild(row);
                });

                // Attach resolution data
                admin._pendingImport = { conflicts, newEntries };

                document.getElementById('btn-resolve-all').onclick = () => {
                    const data = admin._pendingImport;
                    data.conflicts.forEach(c => {
                        if (c.choice === 'update') {
                            Object.assign(c.existing, c.imported);
                        } else if (c.choice === 'both') {
                            const p = { ...c.imported };
                            p.id = "player_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                            state.players.push(p);
                        }
                        // 'keep' does nothing
                    });

                    data.newEntries.forEach(p => {
                        if (!p.id) p.id = "player_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                        state.players.push(p);
                    });

                    modal.style.display = 'none';
                    admin.renderIdentityInputs();
                    admin.saveToStorage(); game.syncProjection();
                    alert(`Import dokonƒçen.`);
                };
            },

            setConflictChoice: (idx, choice) => {
                admin._pendingImport.conflicts[idx].choice = choice;
                const group = document.getElementById(`choice-group-${idx}`);
                const buttons = group.querySelectorAll('.choice-btn');
                buttons.forEach(btn => btn.classList.remove('active'));

                if (choice === 'keep') buttons[0].classList.add('active');
                else if (choice === 'update') buttons[1].classList.add('active');
                else if (choice === 'both') buttons[2].classList.add('active');
            },

            cancelConflictReview: () => {
                document.getElementById('modal-player-conflicts').style.display = 'none';
                admin._pendingImport = null;
            },

            propagateRenames: (oldList, newList, type) => {
                // This helper is largely deprecated but kept for manual logic if needed.
                // ID-based system handles renames implicitly.
            },

            resetApp: () => {
                if (confirm("Opravdu chcete vymazat v≈°echna data aplikace (t√Ωmy, rozpis, zvuk)? Tuto akci nelze vz√≠t zpƒõt.")) {
                    localStorage.removeItem('scoreboardState');
                    location.reload();
                }
            },

            getTeamName: (id) => {
                const t = state.teams.find(x => x.id === id);
                return t ? t.name : (id ? id : "T√Ωm");
            },

            getRefName: (id) => {
                if (!id) return "-";
                const r = state.referees.find(x => x.id === id);
                return r ? r.name : id;
            },

            updateCurrentMatch: () => {
                // Manually updating from input fields is deprecated as fields were removed.
                // Keeping function stub if needed for future logic, or removing.
                // For now, let's just sync projection if called.
                ui.updateNames();
                game.syncProjection();
            },

            generateScheduleFromTemplate: () => {
                const templateId = document.getElementById('sched-template-select').value;
                const template = SCHEDULE_TEMPLATES[templateId];
                if (!template) return;

                const count = template.teams;
                if (state.teams.length < count) {
                    alert(`Pro toto sch√©ma je pot≈ôeba definovat alespo≈à ${count} dru≈æstev. Aktu√°lnƒõ jich m√°te ${state.teams.length}.`);
                    return;
                }

                // Always replace
                state.schedule = [];
                state.activeMatchIndex = -1;

                const startIdx = state.schedule.length;
                const pairs = template.matches;
                const defaultDuration = (state.times.play * 2) + state.times.break;

                pairs.forEach((pair, idx) => {
                    // Resolve home team
                    let home = pair[0];
                    if (typeof home === 'number') {
                        home = state.teams[home - 1].id;
                    }

                    // Resolve guest team
                    let guest = pair[1];
                    if (typeof guest === 'number') {
                        guest = state.teams[guest - 1].id;
                    }

                    // Resolve title (optional 3rd element)
                    const title = pair[2] || `Z√°pas ${startIdx + idx + 1}`;

                    state.schedule.push({
                        type: 'match',
                        title: title,
                        home: home,
                        guest: guest,
                        referee: "",
                        homeScore: null,
                        guestScore: null,
                        phaseIndex: 0,
                        duration: defaultDuration
                    });
                });

                admin.saveSettings(false); // Silent save
                ui.renderSchedule();
                game.syncProjection();
                alert(`Rozpis pro ${count} dru≈æstev byl vygenerov√°n.`);
            },

            addMatch: () => {
                const type = document.getElementById('sched-type').value;
                const isEvent = type === 'event';
                const titleSel = document.getElementById('sched-title');
                const customTitle = document.getElementById('sched-custom-title').value.trim();
                const title = (isEvent || customTitle) ? (customTitle || titleSel.value) : titleSel.value;

                const match = {
                    type,
                    title,
                    home: isEvent ? "" : document.getElementById('sched-home').value,
                    guest: isEvent ? "" : document.getElementById('sched-guest').value,
                    referee: isEvent ? "" : document.getElementById('sched-referee').value,
                    duration: isEvent ? parseInt(document.getElementById('sched-duration').value || 600) : null,
                    homeScore: null,
                    guestScore: null
                };
                state.schedule.push(match);
                admin.clearSchedInputs();
                admin.toggleScheduleForm(false); // Hide after add
                ui.renderSchedule();
                admin.saveToStorage(); game.syncProjection();
                game.syncProjection();
            },

            toggleScheduleForm: (forceShow) => {
                const f = document.getElementById('sched-form-container');
                const btn = document.getElementById('btn-toggle-sched-form');

                let show = forceShow !== undefined ? forceShow : (f.style.display === 'none');

                f.style.display = show ? 'block' : 'none';
                if (btn) {
                    btn.innerHTML = show ? '<b style="font-weight: 900;">-</b> Zav≈ô√≠t formul√°≈ô' : '<b style="font-weight: 900;">+</b> P≈ôidat z√°pas';
                }

                if (show) {
                    const form = document.getElementById('sched-form-container');
                    const header = document.querySelector('#acc-schedule h4');
                    if (state.pendingEditIndex === -1 && form && header) {
                        // Move back to top (below header) if adding new
                        header.after(form);
                        admin.clearSchedInputs();
                    }
                }
            },

            toggleAddMode: () => {
                const f = document.getElementById('sched-form-container');
                const isVisible = f.style.display !== 'none';
                const isAdding = state.pendingEditIndex === -1;

                if (isVisible && isAdding) {
                    // Already adding - hide it
                    admin.toggleScheduleForm(false);
                } else {
                    // Closed or editing - switch to add mode
                    state.pendingEditIndex = -1;
                    admin.toggleScheduleForm(true);
                    ui.renderSchedule(); // Refresh highlighting
                }
            },

            editScheduleMatch: (index) => {
                state.pendingEditIndex = index;
                const m = state.schedule[index];
                const type = m.type || 'match';
                document.getElementById('sched-type').value = type;

                // Title handling
                const titleSel = document.getElementById('sched-title');
                const customInput = document.getElementById('sched-custom-title');
                let found = false;
                for (let i = 0; i < titleSel.options.length; i++) {
                    if (titleSel.options[i].value === m.title) {
                        titleSel.selectedIndex = i;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    customInput.value = m.title;
                    customInput.style.display = 'block';
                    titleSel.style.display = 'none';
                } else {
                    customInput.style.display = 'none';
                    titleSel.style.display = 'block';
                }

                document.getElementById('sched-home').value = m.home || "";
                document.getElementById('sched-guest').value = m.guest || "";
                document.getElementById('sched-referee').value = m.referee || "";
                document.getElementById('sched-home-score').value = (m.homeScore !== undefined && m.homeScore !== null) ? m.homeScore : "";
                document.getElementById('sched-guest-score').value = (m.guestScore !== undefined && m.guestScore !== null) ? m.guestScore : "";
                document.getElementById('sched-duration').value = m.duration || 600;

                admin.onSchedTypeChange(); // UI Sync

                // Toggle buttons
                document.getElementById('sched-controls-add').style.display = 'none';
                document.getElementById('sched-controls-edit').style.display = 'flex';

                // Ensure form section is open
                admin.toggleScheduleForm(true);

                // Open accordion if closed
                const acc = document.getElementById('acc-schedule');
                if (!acc.classList.contains('open')) acc.classList.add('open');

                ui.renderSchedule(); // RE-RENDER to move form and highlight match
            },

            saveEditedMatch: () => {
                if (state.pendingEditIndex > -1) {
                    const type = document.getElementById('sched-type').value;
                    const isEvent = type === 'event';
                    const titleSel = document.getElementById('sched-title');
                    const customTitle = document.getElementById('sched-custom-title').value.trim();
                    const title = (isEvent || customTitle) ? (customTitle || titleSel.value) : titleSel.value;

                    let hScore = document.getElementById('sched-home-score').value;
                    let gScore = document.getElementById('sched-guest-score').value;

                    // Validation: Ensure non-negative
                    // Validation: Ensure valid numbers
                    let parsedH = (hScore !== "" && !isNaN(hScore)) ? parseInt(hScore) : null;
                    let parsedG = (gScore !== "" && !isNaN(gScore)) ? parseInt(gScore) : null;

                    if (parsedH !== null && parsedH < 0) parsedH = 0;
                    if (parsedG !== null && parsedG < 0) parsedG = 0;

                    state.schedule[state.pendingEditIndex] = {
                        type,
                        title,
                        home: isEvent ? "" : document.getElementById('sched-home').value,
                        guest: isEvent ? "" : document.getElementById('sched-guest').value,
                        referee: isEvent ? "" : document.getElementById('sched-referee').value,
                        homeScore: isEvent ? null : parsedH,
                        guestScore: isEvent ? null : parsedG,
                        duration: isEvent ? parseInt(document.getElementById('sched-duration').value || 600) : null
                    };
                    admin.cancelEdit(); // Reset UI
                    ui.renderSchedule();
                    admin.saveToStorage(); game.syncProjection();
                    admin.toggleScheduleForm(false); // Hide
                }
            },

            deleteMatch: () => {
                if (state.pendingEditIndex > -1 && confirm("Opravdu smazat tento z√°pas?")) {
                    state.schedule.splice(state.pendingEditIndex, 1);
                    // Adjust active index if needed
                    if (state.activeMatchIndex === state.pendingEditIndex) state.activeMatchIndex = -1;
                    else if (state.activeMatchIndex > state.pendingEditIndex) state.activeMatchIndex--;

                    admin.cancelEdit();
                    ui.renderSchedule();
                    admin.saveToStorage(); game.syncProjection();
                    admin.toggleScheduleForm(false); // Hide
                }
            },

            cancelEdit: () => {
                state.pendingEditIndex = -1;
                ui.renderSchedule(); // Re-render to clear highlights
                admin.clearSchedInputs();
                document.getElementById('sched-controls-add').style.display = 'block';
                document.getElementById('sched-controls-edit').style.display = 'none';
                admin.toggleScheduleForm(false); // Hide
            },

            clearSchedInputs: () => {
                document.getElementById('sched-type').value = "match";
                document.getElementById('sched-title').selectedIndex = 0;
                document.getElementById('sched-title').style.display = 'block';
                document.getElementById('sched-custom-title').value = "";
                document.getElementById('sched-custom-title').style.display = 'none';
                document.getElementById('sched-home').value = "";
                document.getElementById('sched-guest').value = "";
                document.getElementById('sched-referee').value = "";
                document.getElementById('sched-home-score').value = "";
                document.getElementById('sched-guest-score').value = "";
                document.getElementById('sched-duration').value = 600;
                admin.onSchedTypeChange();

                // CRITIAL FIX: Ensure dropdowns are populated if empty (e.g. after refresh)
                if (document.getElementById('sched-home').options.length <= 1) {
                    ui.fillSelects();
                }
            },

            setScheduleMode: (mode) => {
                document.querySelectorAll('.sched-section').forEach(s => s.classList.remove('active'));
                document.querySelectorAll('.sched-tab-btn').forEach(b => b.classList.remove('active'));

                document.getElementById(`sched-section-${mode}`).classList.add('active');
                document.getElementById(`tab-sched-${mode}`).classList.add('active');
            },


            handleScheduleImport: (input) => {
                if (!input.files || !input.files[0]) return;
                const file = input.files[0];

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const sheetName = workbook.SheetNames[0];
                        const sheet = workbook.Sheets[sheetName];
                        const json = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                        if (json.length < 1) {
                            alert("Soubor je pr√°zdn√Ω nebo neƒçiteln√Ω.");
                            return;
                        }

                        const newMatches = [];
                        let startRow = 0;
                        if (json[0] && json[0].length >= 2) {
                            const firstRowStr = json[0].join(" ").toLowerCase();
                            if (firstRowStr.includes("t√Ωm") || firstRowStr.includes("host") || firstRowStr.includes("z√°pas") || firstRowStr.includes("skupina")) {
                                startRow = 1;
                            }
                        }

                        let addedTeams = 0;
                        let addedRefs = 0;

                        for (let i = startRow; i < json.length; i++) {
                            const row = json[i];
                            if (!row || row.length < 2) continue;

                            const title = String(row[0] || "Z√°pas").trim();
                            const home = String(row[1] || "").trim();
                            const guest = String(row[2] || "").trim();
                            const ref = String(row[3] || "").trim();
                            const duration = parseInt(row[4] || 600);

                            if (!home && !guest && !title) continue;

                            newMatches.push({
                                type: 'match',
                                title: title,
                                home: home,
                                guest: guest,
                                referee: ref,
                                homeScore: null,
                                guestScore: null,
                                duration: duration
                            });

                            if (home && admin.ensureIdentityExists(home, 'team')) addedTeams++;
                            if (guest && admin.ensureIdentityExists(guest, 'team')) addedTeams++;
                            if (ref && admin.ensureIdentityExists(ref, 'ref')) addedRefs++;
                        }

                        // Always overwrite
                        state.schedule = newMatches;
                        state.activeMatchIndex = -1;

                        ui.renderSchedule();
                        admin.saveToStorage(); game.syncProjection();
                        admin.renderIdentityInputs(); // Refresh lists
                        game.syncProjection();
                        alert(`Importov√°no ${newMatches.length} z√°pas≈Ø.\n(P≈ôid√°no ${addedTeams} nov√Ωch t√Ωm≈Ø a ${addedRefs} rozhodƒç√≠ch)`);
                        input.value = "";
                    } catch (err) {
                        console.error(err);
                        alert("Chyba p≈ôi ƒçten√≠ souboru. Ujistƒõte se, ≈æe je to platn√Ω Excel nebo CSV.");
                    }
                };
                reader.readAsArrayBuffer(file);
            },

            ensureIdentityExists: (name, type) => {
                if (!name || name === "-" || name.toLowerCase() === "volno") return false;
                const list = type === 'team' ? state.teams : state.referees;
                const exists = list.some(item => item.name.toLowerCase() === name.toLowerCase());
                if (!exists) {
                    const id = (type === 'team' ? "team_" : "ref_") + Date.now() + "_" + Math.floor(Math.random() * 1000);
                    list.push({ id, name });
                    return true;
                }
                return false;
            },

            onSchedTypeChange: () => {
                const type = document.getElementById('sched-type').value;
                const isEvent = type === 'event';
                document.getElementById('sched-match-fields').style.display = isEvent ? 'none' : 'block';
                document.getElementById('sched-event-fields').style.display = isEvent ? 'block' : 'none';

                // Show custom title input for events, or allow toggle for match?
                // Let's force custom title for events.
                const titleSel = document.getElementById('sched-title');
                const customInput = document.getElementById('sched-custom-title');
                if (isEvent) {
                    titleSel.style.display = 'none';
                    customInput.style.display = 'block';
                } else {
                    titleSel.style.display = 'block';
                    customInput.style.display = 'none';
                }
            },

            moveMatch: (from, to) => {
                game.reorderSchedule(from, to);
            },

            renderLogoSettings: () => {
                const container = document.getElementById('team-logo-list');
                const teams = state.teams;

                if (teams.length === 0) {
                    container.innerHTML = '<div style="color:#666; font-size:0.8em;">P≈ôidejte dru≈æstva pro nahr√°n√≠ vlajek, log a jingles...</div>';
                    return;
                }

                container.innerHTML = '<small style="color:#aaa; display:block; margin-bottom:10px;">Dru≈æstva: vlajky, loga, jingly</small>';
                teams.forEach(teamObj => {
                    const team = teamObj.id;
                    const displayName = teamObj.name || "Dru≈æstvo";
                    const row = document.createElement('div');
                    row.style = 'display:flex; align-items:center; gap:10px; margin-bottom:8px; border-bottom:1px solid #444; padding-bottom:5px;';

                    const logoSrc = state.teamLogos[team] || '';
                    const hasAnthem = !!state.teamAnthems[team];

                    row.innerHTML = `
                        <div style="flex:1; font-size:0.9em; overflow:hidden; text-overflow:ellipsis;">${displayName}</div>
                        <img src="${logoSrc}" style="width:30px; height:30px; object-fit:contain; background:#444; border-radius:3px; display:${logoSrc ? 'block' : 'none'}">
                        
                        <input type="file" accept="image/*" style="display:none" id="logo-file-${team}" onchange="admin.handleLogoUpload('${team}', this)">
                        <button class="small-btn" onclick="document.getElementById('logo-file-${team}').click()" title="Nahr√°t Logo">üñºÔ∏è</button>
                        
                        <input type="file" accept="audio/*" style="display:none" id="anthem-file-${team}" onchange="admin.handleAnthemUpload('${team}', this)">
                        <button class="small-btn ${hasAnthem ? 'btn-green' : ''}" onclick="document.getElementById('anthem-file-${team}').click()" title="Nahr√°t Jingle">üéµ</button>
                    `;
                    container.appendChild(row);
                });
            },

            handleAnthemUpload: (teamName, input) => {
                if (input.files && input.files[0]) {
                    const file = input.files[0];
                    if (file.size > 1024 * 1024) {
                        alert("Jingle je p≈ô√≠li≈° velk√Ω (max 1MB).");
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        state.teamAnthems[teamName] = e.target.result;
                        admin.renderLogoSettings();
                    };
                    reader.readAsDataURL(file);
                }
            },

            handleLogoUpload: (teamName, input) => {
                if (input.files && input.files[0]) {
                    const file = input.files[0];
                    if (file.size > 500 * 1024) {
                        alert("Logo je p≈ô√≠li≈° velk√© (max 500KB).");
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        state.teamLogos[teamName] = e.target.result;
                        admin.renderLogoSettings();
                        ui.updateLogos();
                        game.syncProjection();
                    };
                    reader.readAsDataURL(file);
                }
            },

            loadMatch: (index, resetPhase = false, snapshot = null) => {
                // Save current result if it was a real match before loading new one
                if (state.activeMatchIndex !== -1 && !state.currentMatch.isEvent) {
                    const currentMatchInSched = state.schedule[state.activeMatchIndex];
                    if (currentMatchInSched && currentMatchInSched.type === 'match') {
                        currentMatchInSched.homeScore = state.currentMatch.homeScore;
                        currentMatchInSched.guestScore = state.currentMatch.guestScore;
                        admin.saveToStorage(); // ENSURE STORAGE IS UPDATED
                    }
                }

                // Handle PO transition
                if (snapshot) {
                    game.triggerPoTransition(snapshot);
                } else if (state.poTransitionActive) {
                    // Manual load - cancel transition
                    if (poTransitionTimeoutID) clearTimeout(poTransitionTimeoutID);
                    state.poTransitionActive = false;
                    state.poTransitionData = null;
                }

                const m = state.schedule[index];
                if (!m) return;

                state.activeMatchIndex = index;
                state.currentMatch = {
                    ...state.currentMatch,
                    isEvent: (m.type === 'event'),
                    title: m.title || "",
                    homeName: m.home || "",
                    guestName: m.guest || "",
                    referee: m.referee || "",
                    homeScore: (m.homeScore !== null) ? m.homeScore : 0,
                    guestScore: (m.guestScore !== null) ? m.guestScore : 0,
                    duration: m.duration || 600
                };

                ui.updateNames();
                ui.updateScores();
                ui.renderSchedule(); // update active highlight
                ui.renderStandings(); // AUTOMATICALLY UPDATE TABLES

                if (resetPhase) {
                    game.setPhase(0, true);
                } else {
                    // Force sync even if phase is not reset
                    game.syncProjection();
                }
            },

            toggleSelection: (index, isShift, isCtrl, silent = false) => {
                if (index < 0 || index >= state.schedule.length) return;

                // Cancel edit if clicking a different item (single click)
                if (!isShift && !isCtrl && state.pendingEditIndex !== -1) {
                    if (state.pendingEditIndex !== index) {
                        state.pendingEditIndex = -1;
                        admin.clearSchedInputs();
                        admin.toggleScheduleForm(false);
                    } else {
                        // Clicking the same item that's being edited - close it
                        state.pendingEditIndex = -1;
                        admin.clearSchedInputs();
                        admin.toggleScheduleForm(false);
                        ui.renderSchedule();
                        return; // Done
                    }
                }

                if (isShift && state.selectedIndices.length > 0) {
                    const last = state.selectedIndices[state.selectedIndices.length - 1];
                    const start = Math.min(last, index);
                    const end = Math.max(last, index);
                    // Add the range to current selection
                    for (let i = start; i <= end; i++) {
                        if (!state.selectedIndices.includes(i)) state.selectedIndices.push(i);
                    }
                } else if (isCtrl) {
                    const idx = state.selectedIndices.indexOf(index);
                    if (idx > -1) state.selectedIndices.splice(idx, 1);
                    else state.selectedIndices.push(index);
                } else {
                    state.selectedIndices = [index];
                }
                state.selectedIndices.sort((a, b) => a - b);
                if (!silent) ui.renderSchedule();
            },

            moveSelected: (direction) => {
                if (state.selectedIndices.length === 0) return;

                // Direction: -1 (up), 1 (down)
                // Need to move items without stepping on each other
                const indices = [...state.selectedIndices].sort((a, b) => direction > 0 ? b - a : a - b);

                let movedAny = false;
                const newSelection = [];

                indices.forEach(idx => {
                    const targetIdx = idx + direction;
                    if (targetIdx >= 0 && targetIdx < state.schedule.length) {
                        const item = state.schedule.splice(idx, 1)[0];
                        state.schedule.splice(targetIdx, 0, item);
                        newSelection.push(targetIdx);
                        movedAny = true;

                        // Adjust active match index
                        if (state.activeMatchIndex === idx) state.activeMatchIndex = targetIdx;
                        else if (direction > 0 && state.activeMatchIndex > idx && state.activeMatchIndex <= targetIdx) state.activeMatchIndex--;
                        else if (direction < 0 && state.activeMatchIndex < idx && state.activeMatchIndex >= targetIdx) state.activeMatchIndex++;
                    } else {
                        newSelection.push(idx);
                    }
                });

                if (movedAny) {
                    state.selectedIndices = newSelection.sort((a, b) => a - b);
                    ui.renderSchedule();
                    admin.saveToStorage(); game.syncProjection();
                    game.syncProjection();
                }
            },

            deleteSelected: () => {
                if (state.selectedIndices.length === 0) return;
                if (!confirm(`Opravdu smazat vybran√© z√°pasy (${state.selectedIndices.length})?`)) return;

                const indices = [...state.selectedIndices].sort((a, b) => b - a);
                indices.forEach(idx => {
                    state.schedule.splice(idx, 1);
                    if (state.activeMatchIndex === idx) state.activeMatchIndex = -1;
                    else if (state.activeMatchIndex > idx) state.activeMatchIndex--;
                });

                state.selectedIndices = [];
                state.pendingEditIndex = -1;
                ui.renderSchedule();
                admin.saveToStorage(); game.syncProjection();
            },

            resetSelectedScores: () => {
                if (state.selectedIndices.length === 0) return;
                state.selectedIndices.forEach(idx => {
                    if (state.schedule[idx]) {
                        state.schedule[idx].homeScore = null;
                        state.schedule[idx].guestScore = null;
                    }
                });
                ui.renderSchedule();
                admin.saveToStorage(); game.syncProjection();
                game.syncProjection();
            },

            loadSelected: () => {
                if (state.selectedIndices.length === 0) return;
                admin.loadMatch(state.selectedIndices[0], true);
            },

            editSelected: () => {
                if (state.selectedIndices.length === 0) return;
                admin.editScheduleMatch(state.selectedIndices[0]);
            },

            moveMatchesTo: (indices, targetIdx) => {
                if (!indices || indices.length === 0) return;

                // Sort indices to move items in correct order
                indices.sort((a, b) => a - b);

                // Keep track of the active match
                const activeMatch = state.activeMatchIndex > -1 ? state.schedule[state.activeMatchIndex] : null;

                // Extract items to be moved
                const itemsToMove = indices.map(idx => state.schedule[idx]);

                // Create new schedule by removing items and inserting at target
                const remainingItems = state.schedule.filter((_, idx) => !indices.includes(idx));

                // Calculate actual insertion point in the remaining items array
                // We need to count how many items before targetIdx were removed
                let actualInsertIdx = targetIdx;
                let removedBefore = indices.filter(idx => idx < targetIdx).length;
                actualInsertIdx -= removedBefore;

                // Ensure bounds
                actualInsertIdx = Math.max(0, Math.min(actualInsertIdx, remainingItems.length));

                remainingItems.splice(actualInsertIdx, 0, ...itemsToMove);
                state.schedule = remainingItems;

                // Update active match index if it exists
                if (activeMatch) {
                    state.activeMatchIndex = state.schedule.indexOf(activeMatch);
                }

                // Update selected indices to point to the new positions
                state.selectedIndices = [];
                for (let i = 0; i < itemsToMove.length; i++) {
                    state.selectedIndices.push(actualInsertIdx + i);
                }

                ui.renderSchedule();
                admin.saveToStorage(); game.syncProjection();
            },

            calculateStandings: () => {
                const teamsMap = {};
                // Initialize map with all current teams
                state.teams.forEach(t => {
                    teamsMap[t.id] = { id: t.id, name: t.name, gp: 0, w: 0, d: 0, l: 0, gf: 0, ga: 0, gd: 0, pts: 0 };
                });

                // Process schedule
                state.schedule.forEach(m => {
                    const hs = parseInt(m.homeScore);
                    const gs = parseInt(m.guestScore);

                    if (m.type === 'match' && !isNaN(hs) && !isNaN(gs)) {
                        const h = teamsMap[m.home];
                        const g = teamsMap[m.guest];
                        if (!h || !g) return;

                        h.gp++; g.gp++;
                        h.gf += hs; h.ga += gs;
                        g.gf += gs; g.ga += hs;

                        if (hs > gs) {
                            h.w++; g.l++;
                            h.pts += (state.rules ? state.rules.winPoints : 3);
                            g.pts += (state.rules ? state.rules.lossPoints : 0);
                        } else if (hs < gs) {
                            g.w++; h.l++;
                            g.pts += (state.rules ? state.rules.winPoints : 3);
                            h.pts += (state.rules ? state.rules.lossPoints : 0);
                        } else {
                            h.d++; g.d++;
                            h.pts += (state.rules ? state.rules.drawPoints : 1);
                            g.pts += (state.rules ? state.rules.drawPoints : 1);
                        }
                        h.gd = h.gf - h.ga;
                        g.gd = g.gf - g.ga;
                    }
                });

                // Convert to array
                let standingsList = Object.values(teamsMap);

                // SORTING LOGIC
                if (!state.rules || !state.rules.useMiniTables) {
                    // Standard sorting: Points -> GD -> GF
                    standingsList.sort((a, b) => {
                        if (b.pts !== a.pts) return b.pts - a.pts;
                        if (b.gd !== a.gd) return b.gd - a.gd;
                        return b.gf - a.gf;
                    });
                    return standingsList;
                }

                // Advanced sorting: Mini-tables for ties
                const groups = {};
                standingsList.forEach(s => {
                    if (!groups[s.pts]) groups[s.pts] = [];
                    groups[s.pts].push(s);
                });

                const sortedPointsKeys = Object.keys(groups).map(Number).sort((a, b) => b - a);
                let finalStandings = [];

                sortedPointsKeys.forEach(p => {
                    const subgroup = groups[p];
                    if (subgroup.length === 1) {
                        finalStandings.push(subgroup[0]);
                    } else {
                        // Tie! Create mini-table from mutual matches
                        const teamIds = subgroup.map(t => t.id);
                        const mini = admin.calculateMiniTable(teamIds);

                        subgroup.sort((a, b) => {
                            const ma = mini[a.id];
                            const mb = mini[b.id];
                            if (mb.pts !== ma.pts) return mb.pts - ma.pts;
                            if (mb.gd !== ma.gd) return mb.gd - ma.gd;
                            if (mb.gf !== ma.gf) return mb.gf - ma.gf;
                            // Fallback to overall
                            if (b.gd !== a.gd) return b.gd - a.gd;
                            if (b.gf !== a.gf) return b.gf - a.gf;
                            return 0;
                        });
                        finalStandings.push(...subgroup);
                    }
                });

                return finalStandings;
            },

            calculateMiniTable: (teamIds) => {
                const mini = {};
                teamIds.forEach(id => {
                    mini[id] = { pts: 0, gf: 0, ga: 0, gd: 0 };
                });

                state.schedule.forEach(m => {
                    const hs = parseInt(m.homeScore);
                    const gs = parseInt(m.guestScore);

                    if (m.type === 'match' && !isNaN(hs) && !isNaN(gs)) {
                        if (teamIds.includes(m.home) && teamIds.includes(m.guest)) {
                            const h = mini[m.home];
                            const g = mini[m.guest];

                            h.gf += hs; h.ga += gs;
                            g.gf += gs; g.ga += hs;

                            if (hs > gs) {
                                h.pts += (state.rules ? state.rules.winPoints : 3);
                                g.pts += (state.rules ? state.rules.lossPoints : 0);
                            } else if (hs < gs) {
                                g.pts += (state.rules ? state.rules.winPoints : 3);
                                h.pts += (state.rules ? state.rules.lossPoints : 0);
                            } else {
                                h.pts += (state.rules ? state.rules.drawPoints : 1);
                                g.pts += (state.rules ? state.rules.drawPoints : 1);
                            }
                            h.gd = h.gf - h.ga;
                            g.gd = g.gf - g.ga;
                        }
                    }
                });
                return mini;
            },

            setStandingsTab: (tab) => {
                state.activeStandingsTab = tab;
                ui.renderStandings(); // This will now delegate to cross table if needed
                admin.saveToStorage();
            },

            deselectAll: () => {
                if (state.selectedIndices.length > 0) {
                    state.selectedIndices = [];
                    ui.renderSchedule();
                }
            },

            saveToStorage: () => {
                localStorage.setItem('scoreboardState', JSON.stringify(state));
            },

            loadFromStorage: () => {
                const loaded = localStorage.getItem('scoreboardState');
                if (loaded) {
                    const parsed = JSON.parse(loaded);
                    state.tournamentName = parsed.tournamentName || "";
                    if (parsed.times) {
                        state.times = parsed.times;
                        // FIX: If user has stuck '2' values, force new defaults
                        if (state.times.play === 2 || state.times.play === 5) state.times.play = 420;
                        if (state.times.break === 2 || state.times.break === 5) state.times.break = 105;
                        if (state.times.setup === 2 || state.times.setup === 5) state.times.setup = 10;
                    }
                    if (parsed.teams) state.teams = parsed.teams;
                    if (parsed.teamLogos) state.teamLogos = parsed.teamLogos;
                    if (parsed.teamAnthems) state.teamAnthems = parsed.teamAnthems;
                    if (typeof parsed.volSignal !== 'undefined') state.volSignal = parsed.volSignal;
                    if (typeof parsed.volAnthem !== 'undefined') state.volAnthem = parsed.volAnthem;
                    if (parsed.referees) state.referees = parsed.referees;
                    if (parsed.players) state.players = parsed.players;
                    if (parsed.schedule) state.schedule = parsed.schedule;
                    if (parsed.audioData) state.audioData = parsed.audioData;
                    if (parsed.theme) state.theme = parsed.theme;
                    if (typeof parsed.musicAutoEnabled !== 'undefined') state.musicAutoEnabled = parsed.musicAutoEnabled;
                    if (parsed.musicMode) state.musicMode = parsed.musicMode;
                    if (typeof parsed.musicFadeDuration !== 'undefined') state.musicFadeDuration = parsed.musicFadeDuration;
                    if (parsed.musicPlaylistOrder) state.musicPlaylistOrder = parsed.musicPlaylistOrder;
                    if (parsed.musicAutoChangeStrategy) state.musicAutoChangeStrategy = parsed.musicAutoChangeStrategy;
                    if (typeof parsed.activeMatchIndex !== 'undefined') state.activeMatchIndex = parsed.activeMatchIndex;
                    if (parsed.currentMatch) state.currentMatch = parsed.currentMatch;
                    if (parsed.timer) state.timer = parsed.timer;

                    if (typeof parsed.tournamentStartTime !== 'undefined') state.tournamentStartTime = parsed.tournamentStartTime;
                    if (typeof parsed.playTimeAccumulated !== 'undefined') state.playTimeAccumulated = parsed.playTimeAccumulated;

                    // MIGRATION: Strings -> Objects with IDs
                    if (state.teams.length > 0 && typeof state.teams[0] === 'string') {
                        const teamMap = {};
                        const oldTeamsArr = [...state.teams];
                        state.teams = oldTeamsArr.map((name, i) => {
                            const id = "team_legacy_" + i;
                            teamMap[name] = id;
                            return { id, name };
                        });
                        // Migrate logos/anthems
                        const newLogos = {};
                        const newAnthems = {};
                        Object.keys(state.teamLogos).forEach(oldName => {
                            if (teamMap[oldName]) newLogos[teamMap[oldName]] = state.teamLogos[oldName];
                        });
                        Object.keys(state.teamAnthems).forEach(oldName => {
                            if (teamMap[oldName]) newAnthems[teamMap[oldName]] = state.teamAnthems[oldName];
                        });
                        state.teamLogos = newLogos;
                        state.teamAnthems = newAnthems;
                        // Migrate schedule references
                        state.schedule.forEach(m => {
                            if (teamMap[m.home]) m.home = teamMap[m.home];
                            if (teamMap[m.guest]) m.guest = teamMap[m.guest];
                        });
                        // Migrate current match
                        if (teamMap[state.currentMatch.homeName]) state.currentMatch.homeName = teamMap[state.currentMatch.homeName];
                        if (teamMap[state.currentMatch.guestName]) state.currentMatch.guestName = teamMap[state.currentMatch.guestName];
                    }

                    if (state.referees.length > 0 && typeof state.referees[0] === 'string') {
                        const refMap = {};
                        const oldRefsArr = [...state.referees];
                        state.referees = oldRefsArr.map((name, i) => {
                            const id = "ref_legacy_" + i;
                            refMap[name] = id;
                            return { id, name };
                        });
                        // Migrate schedule
                        state.schedule.forEach(m => {
                            if (refMap[m.referee]) m.referee = refMap[m.referee];
                        });
                        // Migrate current
                        if (refMap[state.currentMatch.referee]) state.currentMatch.referee = refMap[state.currentMatch.referee];
                    }
                }

                admin.renderIdentityInputs();

                // Keyboard Selection Listeners
                window.addEventListener('keydown', (e) => {
                    if (e.shiftKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                        // Don't scroll if we are in the list
                        if (state.selectedIndices.length === 0) {
                            admin.toggleSelection(0, false);
                        } else {
                            const last = state.selectedIndices[state.selectedIndices.length - 1];
                            const next = last + (e.key === 'ArrowUp' ? -1 : 1);
                            if (next >= 0 && next < state.schedule.length) {
                                e.preventDefault();
                                admin.toggleSelection(next, true);
                            }
                        }
                    }
                });

                // Deselect on click outside match items
                const schedContent = document.getElementById('acc-schedule');
                if (schedContent) {
                    schedContent.addEventListener('click', (e) => {
                        // If click is directly on the accordion content or the list (not on items or toolbar buttons)
                        const target = e.target;
                        const isMatchItem = target.closest('.match-item');
                        const isToolbar = target.closest('.schedule-toolbar');
                        const isForm = target.closest('#sched-form-container');

                        if (!isMatchItem && !isToolbar && !isForm) {
                            admin.deselectAll();
                        }
                    });
                }

                // Set Inputs
                document.getElementById('input-tournament-name').value = state.tournamentName;
                document.getElementById('time-setup').value = state.times.setup;
                document.getElementById('time-play').value = state.times.play;
                document.getElementById('time-break').value = state.times.break;

                // Volume Controls
                document.getElementById('input-vol-signal').value = state.volSignal || 1.0;
                document.getElementById('vol-signal-disp').innerText = Math.round((state.volSignal || 1.0) * 100);
                document.getElementById('input-vol-anthem').value = state.volAnthem || 1.0;
                document.getElementById('vol-anthem-disp').innerText = Math.round((state.volAnthem || 1.0) * 100);
                document.getElementById('input-theme').value = state.theme || "light";
                document.getElementById('input-po-delay').value = state.poTransitionDelay || 10;
                document.getElementById('input-show-footer').checked = (state.showFooter !== false);

                if (state.rules) {
                    document.getElementById('rule-win').value = state.rules.winPoints;
                    document.getElementById('rule-draw').value = state.rules.drawPoints;
                    document.getElementById('rule-loss').value = state.rules.lossPoints;
                    document.getElementById('rule-mini-tables').checked = !!state.rules.useMiniTables;
                }
                ui.updateFooterVisibility();

                // Music Settings
                const elAuto = document.getElementById('input-music-auto');
                if (elAuto) elAuto.checked = state.musicAutoEnabled;
                const elMode = document.getElementById('input-music-mode');
                if (elMode) elMode.value = state.musicMode || 'continuous';
                const elFade = document.getElementById('input-music-fade');
                if (elFade) elFade.value = state.musicFadeDuration || 1;
                const elFadeDisp = document.getElementById('fade-dur-disp');
                if (elFadeDisp) elFadeDisp.innerText = state.musicFadeDuration || 1;

                const elAutoChange = document.getElementById('input-music-auto-change');
                if (elAutoChange) elAutoChange.value = state.musicAutoChangeStrategy || 'continuous';

                const volSlider = document.getElementById('input-vol-music');
                if (volSlider) volSlider.value = state.volMusic || 0.5;

                const elVolDisp = document.getElementById('vol-music-disp');
                if (elVolDisp) elVolDisp.innerText = Math.round((state.volMusic || 0.5) * 100);

                admin.renderLogoSettings();
                ui.fillSelects();
                ui.renderSchedule();
                ui.updateProjection();
                game.resetTimer();

                // Update projection URL display
                const urlDisp = document.getElementById('projection-url-display');
                if (urlDisp) {
                    urlDisp.value = window.location.origin + window.location.pathname + '?projection&session=' + state.sessionId;
                }

                ui.updateDurationHints(); // INIT DURATION HINTS

                // Init music handle if exists
                music.getHandle().then(h => {
                    if (h) {
                        directoryHandle = h;
                        music.listTracks(); // Try to list if access is already granted
                        document.getElementById('music-list').innerHTML = `<li style="color:#4caf50; font-size:0.8em; text-align:center; padding:10px;">Slo≈æka nalezena. Kliknƒõte na 'Vybrat slo≈æku' pro obnoven√≠ p≈ô√≠stupu.</li>`;
                    }
                });
            }
        };

        const music = {
            fadeInterval: null,
            async openDB() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open("MusicDB", 1);
                    req.onupgradeneeded = () => req.result.createObjectStore("handles");
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            async saveHandle(handle) {
                const db = await music.openDB();
                const tx = db.transaction("handles", "readwrite");
                tx.objectStore("handles").put(handle, "lastDirectory");
            },
            async getHandle() {
                try {
                    const db = await music.openDB();
                    const tx = db.transaction("handles", "readonly");
                    const req = tx.objectStore("handles").get("lastDirectory");
                    return new Promise(resolve => {
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve(null);
                    });
                } catch (e) { return null; }
            },
            async pickDirectory() {
                try {
                    directoryHandle = await window.showDirectoryPicker();
                    await music.saveHandle(directoryHandle);
                    await music.listTracks();
                } catch (e) { console.warn("Picker error:", e); }
            },
            async listTracks() {
                if (!directoryHandle) return;
                state.musicPlaylist = [];
                try {
                    for await (const entry of directoryHandle.values()) {
                        if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.mp3')) {
                            state.musicPlaylist.push({ name: entry.name, handle: entry });
                        }
                    }
                    state.musicPlaylist.sort((a, b) => a.name.localeCompare(b.name));
                    ui.renderMusic();
                    const mc = document.getElementById('music-controls');
                    const mp = document.getElementById('music-mini-panel');
                    if (mc) mc.style.display = 'block';
                    if (mp) mp.style.display = 'flex';
                } catch (e) {
                    alert("Nutno znovu povolit p≈ô√≠stup ke slo≈æce s hudbou.");
                }
            },
            toggle() {
                if (currentMusicAudio.paused) {
                    if (currentMusicIndex === -1 && state.musicPlaylist.length > 0) {
                        music.play(0);
                    } else {
                        currentMusicAudio.play();
                        music.fadeIn();
                    }
                } else {
                    music.fadeOut();
                }
            },
            next() {
                if (state.musicPlaylist.length === 0) return;
                let targetIndex;
                if (state.musicMode === 'random') {
                    targetIndex = Math.floor(Math.random() * state.musicPlaylist.length);
                } else {
                    targetIndex = currentMusicIndex + 1;
                    if (targetIndex >= state.musicPlaylist.length) targetIndex = 0;
                }
                // Crossfade if music is playing and fade duration > 0
                if (!currentMusicAudio.paused && state.musicFadeDuration > 0) {
                    music.crossfadeTo(targetIndex);
                } else {
                    music.play(targetIndex);
                }
            },
            prev() {
                if (state.musicPlaylist.length === 0) return;
                let targetIndex;
                if (state.musicMode === 'random') {
                    targetIndex = Math.floor(Math.random() * state.musicPlaylist.length);
                } else {
                    targetIndex = currentMusicIndex - 1;
                    if (targetIndex < 0) targetIndex = state.musicPlaylist.length - 1;
                }
                // Crossfade if music is playing and fade duration > 0
                if (!currentMusicAudio.paused && state.musicFadeDuration > 0) {
                    music.crossfadeTo(targetIndex);
                } else {
                    music.play(targetIndex);
                }
            },
            setVolume(val) {
                state.volMusic = parseFloat(val);
                if (!music.fadeInterval && !music.crossfadeInterval) {
                    currentMusicAudio.volume = state.volMusic;
                }
                const disp = document.getElementById('vol-music-disp');
                if (disp) disp.innerText = Math.round(state.volMusic * 100);
                admin.saveToStorage(); game.syncProjection();
            },
            setAutoEnabled(val) {
                state.musicAutoEnabled = val;
                admin.saveToStorage(); game.syncProjection();
            },
            setMode(val) {
                state.musicMode = val;
                admin.saveToStorage(); game.syncProjection();
            },
            setFadeDuration(val) {
                state.musicFadeDuration = parseFloat(val);
                document.getElementById('fade-dur-disp').innerText = state.musicFadeDuration;
                admin.saveToStorage(); game.syncProjection();
            },
            setAutoChangeStrategy(val) {
                state.musicAutoChangeStrategy = val;
                admin.saveToStorage(); game.syncProjection();
            },
            fadeIn() {
                clearInterval(music.fadeInterval);
                if (state.musicFadeDuration === 0) {
                    currentMusicAudio.volume = state.volMusic;
                    return;
                }
                currentMusicAudio.volume = 0;
                const step = state.volMusic / (state.musicFadeDuration * 20);
                music.fadeInterval = setInterval(() => {
                    currentMusicAudio.volume = Math.min(state.volMusic, currentMusicAudio.volume + step);
                    if (currentMusicAudio.volume >= state.volMusic) {
                        clearInterval(music.fadeInterval);
                        music.fadeInterval = null;
                    }
                }, 50);
            },
            fadeOut() {
                clearInterval(music.fadeInterval);
                if (state.musicFadeDuration === 0) {
                    currentMusicAudio.pause();
                    return;
                }
                const step = currentMusicAudio.volume / (state.musicFadeDuration * 20);
                music.fadeInterval = setInterval(() => {
                    currentMusicAudio.volume = Math.max(0, currentMusicAudio.volume - step);
                    if (currentMusicAudio.volume <= 0) {
                        clearInterval(music.fadeInterval);
                        music.fadeInterval = null;
                        currentMusicAudio.pause();
                    }
                }, 50);
            },
            startAuto() {
                if (!state.musicAutoEnabled || state.musicPlaylist.length === 0) return;
                // Start a new track from beginning (only when first entering auto mode)
                if (state.musicMode === 'random') {
                    const idx = Math.floor(Math.random() * state.musicPlaylist.length);
                    music.play(idx, true);
                } else {
                    if (currentMusicIndex === -1) music.play(0, true);
                    else music.play(currentMusicIndex, true);
                }
            },
            resumeAuto(phaseIndex, previousPhase) {
                if (!state.musicAutoEnabled || state.musicPlaylist.length === 0) return;

                // Check if we should start a new track based on strategy
                const shouldStartNew = (
                    currentMusicIndex === -1 || // No track loaded
                    (state.musicAutoChangeStrategy === 'per-step' && (phaseIndex === 0 || phaseIndex === 2)) // New track per step
                );

                if (shouldStartNew) {
                    // Start new track only if not already playing or if strategy requires it
                    music.startNewTrack();
                } else if (currentMusicAudio.paused) {
                    // Resume from where it was paused
                    currentMusicAudio.play().then(() => {
                        music.fadeIn();
                    }).catch(e => console.warn("Resume failed, likely interupted:", e));
                }
            },
            startNewTrack() {
                // Start a new track (used by both auto strategies)
                if (state.musicMode === 'random') {
                    const idx = Math.floor(Math.random() * state.musicPlaylist.length);
                    music.play(idx, true);
                } else {
                    let nextIdx = currentMusicIndex + 1;
                    if (nextIdx >= state.musicPlaylist.length) nextIdx = 0;
                    music.play(nextIdx, true);
                }
            },
            pauseAuto() {
                if (!state.musicAutoEnabled) return;
                // Pause (not stop) - will resume from this position
                if (!currentMusicAudio.paused) {
                    music.fadeOut();
                }
            },
            stopAuto() {
                if (!state.musicAutoEnabled) return;
                music.fadeOut();
            },
            reorder(fromIndex, toIndex) {
                const item = state.musicPlaylist.splice(fromIndex, 1)[0];
                state.musicPlaylist.splice(toIndex, 0, item);
                state.musicPlaylistOrder = state.musicPlaylist.map(t => t.name);
                admin.saveToStorage(); game.syncProjection();
                ui.renderMusic();
            },
            crossfadeTo(index) {
                // True crossfade: both tracks play simultaneously
                clearInterval(music.crossfadeInterval);

                // Determine which audio element to use for the new track
                const oldAudio = currentMusicAudio;
                const newAudio = (currentMusicAudio === musicAudioA) ? musicAudioB : musicAudioA;

                // Load and start the new track
                music.loadTrack(newAudio, index).then(() => {
                    newAudio.volume = 0;
                    newAudio.play();

                    // Crossfade: old fades out, new fades in
                    const steps = state.musicFadeDuration * 20;
                    const oldStep = oldAudio.volume / steps;
                    const newStep = state.volMusic / steps;
                    let stepCount = 0;

                    music.crossfadeInterval = setInterval(() => {
                        stepCount++;
                        oldAudio.volume = Math.max(0, oldAudio.volume - oldStep);
                        newAudio.volume = Math.min(state.volMusic, newAudio.volume + newStep);

                        if (stepCount >= steps) {
                            clearInterval(music.crossfadeInterval);
                            music.crossfadeInterval = null;
                            oldAudio.pause();
                            oldAudio.volume = state.volMusic; // Reset for next use
                            currentMusicAudio = newAudio; // Switch active audio
                        }
                    }, 50);
                }).catch(e => {
                    console.error("Crossfade error:", e);
                });
            },
            async loadTrack(audioElement, index) {
                const track = state.musicPlaylist[index];
                const file = await track.handle.getFile();
                const url = URL.createObjectURL(file);
                audioElement.src = url;
                currentMusicIndex = index;
                document.getElementById('current-track-name').textContent = track.name;
                ui.renderMusic();
            },
            async play(index, isAuto = false) {
                if (index < 0 || index >= state.musicPlaylist.length) return;
                try {
                    await music.loadTrack(currentMusicAudio, index);

                    // CRITICAL: Double check if we are still in a musical phase after async load
                    // Musical phases are 0 (Nastupuje) and 2 (P≈ôest√°vka)
                    const pIdx = state.currentMatch.phaseIndex;
                    const isMusicalPhase = (pIdx === 0 || pIdx === 2);

                    if (isAuto && !isMusicalPhase) {
                        console.log("Music play cancelled: current phase is not musical", pIdx);
                        return;
                    }

                    if (isAuto || state.musicFadeDuration > 0) {
                        currentMusicAudio.volume = 0;
                        currentMusicAudio.play().then(() => {
                            music.fadeIn();
                        }).catch(e => console.warn("Auto play interupted:", e));
                    } else {
                        currentMusicAudio.volume = state.volMusic;
                        currentMusicAudio.play().catch(e => console.warn("Manual play failed:", e));
                    }
                } catch (e) {
                    console.error("Play error:", e);
                    if (!isAuto) alert("Chyba p≈ôi p≈ôehr√°v√°n√≠.");
                }
            }
        };


        const exporter = {
            resolveName: (id, type) => {
                if (!id) return "-";
                const list = type === 'team' ? state.teams : state.referees;
                const found = list.find(item => item.id === id);
                return found ? found.name : id; // Fallback to ID if not found (legacy or manual)
            },
            toXLSX: () => {
                const wb = XLSX.utils.book_new();
                const data = state.schedule.map((m, i) => {
                    const row = {
                        "Po≈ôad√≠": i + 1,
                        "N√°zev / Skupina": m.title || "Match",
                        "Dom√°c√≠": m.type === 'match' ? exporter.resolveName(m.home, 'team') : "-",
                        "Host√©": m.type === 'match' ? exporter.resolveName(m.guest, 'team') : "-",
                        "Sk√≥re": m.type === 'match' ? (m.homeScore !== null ? `${m.homeScore}:${m.guestScore}` : "-") : "-",
                        "Rozhodƒç√≠": m.type === 'match' ? exporter.resolveName(m.referee, 'ref') : "-",
                        "D√©lka (s)": m.duration || (m.type === 'match' ? (state.times.play * 2 + state.times.break) : 600)
                    };
                    return row;
                });

                const ws = XLSX.utils.json_to_sheet(data);
                XLSX.utils.book_append_sheet(wb, ws, "Rozpis");

                const filename = (state.tournamentName || "Export") + "_Rozpis.xlsx";
                XLSX.writeFile(wb, filename);
            },
            toPrintable: () => {
                const win = window.open('', '_blank');
                let html = `<html><head><title>Tisk rozpisu - ${state.tournamentName}</title>
                <style>
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 40px; color: #333; line-height: 1.6; }
                    table { width: 100%; border-collapse: collapse; margin-top: 30px; box-shadow: 0 2px 3px rgba(0,0,0,0.1); }
                    th, td { border: 1px solid #ddd; padding: 12px 15px; text-align: left; }
                    th { background-color: #f8f9fa; color: #333; font-weight: bold; text-transform: uppercase; font-size: 0.8em; letter-spacing: 1px; }
                    tr:nth-child(even) { background-color: #fcfcfc; }
                    h1 { color: #1a73e8; margin-bottom: 5px; }
                    .meta { color: #666; font-size: 0.9em; margin-bottom: 30px; }
                    .event-row { background-color: #fff9c4 !important; font-style: italic; color: #555; text-align: center; font-weight: 500; }
                    @media print {
                        body { padding: 0; }
                        table { box-shadow: none; border-color: #000; }
                        th { background-color: #eee !important; -webkit-print-color-adjust: exact; }
                        .event-row { background-color: #ffffdd !important; -webkit-print-color-adjust: exact; }
                    }
                </style></head><body>`;

                html += `<h1>${state.tournamentName || "Turnajov√Ω rozpis"}</h1>`;
                html += `<div class="meta">Exportov√°no: ${new Date().toLocaleString('cs-CZ')}</div>`;
                html += `<table><thead><tr>
                    <th style="width:40px">#</th>
                    <th style="width:120px">Skupina / F√°ze</th>
                    <th>Dom√°c√≠</th>
                    <th>Host√©</th>
                    <th style="width:80px; text-align:center;">V√Ωsledek</th>
                    <th>Rozhodƒç√≠</th>
                </tr></thead><tbody>`;

                state.schedule.forEach((m, i) => {
                    if (m.type === 'match') {
                        html += `<tr>
                            <td>${i + 1}</td>
                            <td>${m.title}</td>
                            <td style="font-weight:bold">${exporter.resolveName(m.home, 'team')}</td>
                            <td style="font-weight:bold">${exporter.resolveName(m.guest, 'team')}</td>
                            <td style="text-align:center; font-family:monospace; font-weight:bold; font-size:1.1em;">
                                ${m.homeScore !== null ? `${m.homeScore}:${m.guestScore}` : "- : -"}
                            </td>
                            <td>${exporter.resolveName(m.referee, 'ref')}</td>
                        </tr>`;
                    } else {
                        html += `<tr class="event-row">
                            <td>${i + 1}</td>
                            <td>${m.title}</td>
                            <td colspan="4">UD√ÅLOST / P≈òEST√ÅVKA (${Math.floor(m.duration / 60)} min)</td>
                        </tr>`;
                    }
                });

                html += `</tbody></table>`;

                const standings = admin.calculateStandings();
                if (standings.length > 0) {
                    html += `<h2 style="margin-top:50px;">Koneƒçn√© po≈ôad√≠ / Tabulka</h2>`;
                    html += `<table><thead><tr>
                        <th style="width:40px">#</th>
                        <th>T√Ωm</th>
                        <th style="text-align:center; width:40px;">Z</th>
                        <th style="text-align:center; width:40px;">V</th>
                        <th style="text-align:center; width:40px;">R</th>
                        <th style="text-align:center; width:40px;">P</th>
                        <th style="text-align:center; width:60px;">Sk√≥re</th>
                        <th style="text-align:center; width:50px;">Body</th>
                    </tr></thead><tbody>`;
                    standings.forEach((s, idx) => {
                        html += `<tr>
                            <td>${idx + 1}.</td>
                            <td style="font-weight:bold;">${s.name}</td>
                            <td style="text-align:center;">${s.gp}</td>
                            <td style="text-align:center;">${s.w}</td>
                            <td style="text-align:center;">${s.d}</td>
                            <td style="text-align:center;">${s.l}</td>
                            <td style="text-align:center;">${s.gf}:${s.ga}</td>
                            <td style="text-align:center; font-weight:bold;">${s.pts}</td>
                        </tr>`;
                    });
                    html += `</tbody></table>`;
                }

                if (state.teams.length > 0) {
                    html += `<h2 style="margin-top:50px; page-break-before:always;">K≈ô√≠≈æov√° tabulka v√Ωsledk≈Ø</h2>`;
                    html += `<table style="font-size:0.8em; text-align:center;"><thead style="background:#eee;"><tr>
                        <th style="width:30px">#</th>
                        <th style="text-align:left;">T√Ωm</th>`;
                    state.teams.forEach((_, i) => html += `<th style="width:30px;">${i + 1}</th>`);
                    html += `<th style="width:40px;">Body</th><th style="width:70px;">Sk√≥re</th></tr></thead><tbody>`;

                    const standings = admin.calculateStandings();
                    const statsMap = {};
                    standings.forEach(s => statsMap[s.id] = s);

                    state.teams.forEach((tRow, i) => {
                        html += `<tr><td>${i + 1}.</td><td style="text-align:left; font-weight:bold;">${tRow.name}</td>`;
                        state.teams.forEach((tCol, j) => {
                            if (i === j) {
                                html += `<td style="background:#ddd;"></td>`;
                            } else {
                                const match = state.schedule.find(m =>
                                    m.type === 'match' &&
                                    ((m.home === tRow.id && m.guest === tCol.id) || (m.home === tCol.id && m.guest === tRow.id)) &&
                                    m.homeScore !== null && m.guestScore !== null
                                );
                                if (match) {
                                    const score = (match.home === tRow.id) ? `${match.homeScore}:${match.guestScore}` : `${match.guestScore}:${match.homeScore}`;
                                    html += `<td>${score}</td>`;
                                } else {
                                    html += `<td>-</td>`;
                                }
                            }
                        });
                        const s = statsMap[tRow.id] || { pts: 0, gf: 0, ga: 0 };
                        html += `<td style="font-weight:bold;">${s.pts}</td><td>${s.gf}:${s.ga}</td></tr>`;
                    });
                    html += `</tbody></table>`;
                }

                html += `
                <div style="margin-top:40px; text-align:right; font-size:0.8em; color:#999;">
                    Generov√°no aplikac√≠ Antigravity Scoreboard
                </div>
                </body></html>`;
                win.document.write(html);
                win.document.close();
            }
        };

        // Event listeners for both audio elements
        musicAudioA.addEventListener('ended', () => {
            if (currentMusicAudio === musicAudioA) music.next();
        });
        musicAudioB.addEventListener('ended', () => {
            if (currentMusicAudio === musicAudioB) music.next();
        });

        // Update indicator when either audio plays/pauses
        musicAudioA.addEventListener('play', () => {
            if (currentMusicAudio === musicAudioA) ui.updateMusicIndicatorState();
        });
        musicAudioA.addEventListener('pause', () => {
            if (currentMusicAudio === musicAudioA) ui.updateMusicIndicatorState();
        });
        musicAudioB.addEventListener('play', () => {
            if (currentMusicAudio === musicAudioB) ui.updateMusicIndicatorState();
        });
        musicAudioB.addEventListener('pause', () => {
            if (currentMusicAudio === musicAudioB) ui.updateMusicIndicatorState();
        });

        // --- UI DRAWING ---
        const ui = {
            updateFooterVisibility: () => {
                const footer = document.getElementById('admin-footer');
                if (footer) {
                    footer.style.display = state.showFooter ? 'grid' : 'none';
                    document.body.style.paddingBottom = state.showFooter ? '55px' : '20px';
                }
            },
            updateAdminFooter: () => {
                const telemetry = game.getTelemetry();
                const prog = document.getElementById('admin-footer-progress');
                const end = document.getElementById('admin-footer-end');
                const time = document.getElementById('admin-footer-time');
                const sess = document.getElementById('admin-footer-session');
                if (prog) prog.innerText = telemetry.progress;
                if (end) end.innerText = telemetry.end;
                if (time) time.innerText = telemetry.time;
                if (sess) sess.innerText = `Relace: ${state.sessionId}`;
            },
            render: () => {
                try {
                    ui.renderPhase();
                    ui.updateScores();
                    ui.updateNames();
                    ui.updateTimer();
                    ui.updateTimerBtn();
                    ui.renderSchedule();
                    ui.renderMusic();
                    ui.renderStandings();
                    ui.updateDurationHints(); // Force update hints on every render
                } catch (e) {
                    console.error("UI: Fatal error in render()", e);
                }
            },

            renderStandings: () => {
                const container = document.getElementById('standings-container');
                if (!container) return;

                // Update tab buttons style
                const btnS = document.getElementById('tab-btn-standings');
                const btnC = document.getElementById('tab-btn-cross');
                if (btnS && btnC) {
                    const activeStyle = "background: var(--accent-blue); color: #fff; transform: translateY(-1px); border: 1px solid #555;";
                    const inactiveStyle = "background: #333; color: #aaa; border: 1px solid #444;";
                    btnS.style = (state.activeStandingsTab !== 'cross') ? activeStyle : inactiveStyle;
                    btnC.style = (state.activeStandingsTab === 'cross') ? activeStyle : inactiveStyle;
                }

                if (state.activeStandingsTab === 'cross') {
                    ui.renderCrossTable(container);
                    return;
                }

                const standings = admin.calculateStandings();
                if (standings.length === 0) {
                    container.innerHTML = `<p style="text-align:center; color:#666; font-size:0.9em; padding:10px;">≈Ω√°dn√° data pro tabulku.</p>`;
                    return;
                }

                let html = `<table style="width:100%; border-collapse:collapse; font-size:0.85em; margin-top:5px;">
                    <thead><tr style="background:#222; color:#aaa; text-align:left;">
                        <th style="padding:5px;">#</th>
                        <th style="padding:5px;">T√Ωm</th>
                        <th style="padding:5px; text-align:center;">Z</th>
                        <th style="padding:5px; text-align:center;">S</th>
                        <th style="padding:5px; text-align:center;">B</th>
                    </tr></thead><tbody>`;

                standings.forEach((s, i) => {
                    html += `<tr style="border-bottom:1px solid #444;">
                        <td style="padding:5px;">${i + 1}.</td>
                        <td style="padding:5px; font-weight:bold; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:120px;">${s.name}</td>
                        <td style="padding:5px; text-align:center;">${s.gp}</td>
                        <td style="padding:5px; text-align:center; color:#888;">${s.gf}:${s.ga}</td>
                        <td style="padding:5px; text-align:center; font-weight:bold; color:var(--accent-green);">${s.pts}</td>
                    </tr>`;
                });

                html += `</tbody></table>`;
                container.innerHTML = html;
            },

            renderCrossTable: (container) => {
                const teams = state.teams;
                if (teams.length === 0) {
                    container.innerHTML = `<p style="text-align:center; color:#666; font-size:0.9em; padding:10px;">≈Ω√°dn√° dru≈æstva pro zobrazen√≠.</p>`;
                    return;
                }

                const standings = admin.calculateStandings();
                // Map of ranks for easy lookup
                const ranks = {};
                standings.forEach((s, i) => ranks[s.id] = i + 1);

                // Map of points/goals for easy lookup
                const stats = {};
                standings.forEach(s => stats[s.id] = s);

                let html = `<div style="overflow-x:auto;"><table style="width:100%; border-collapse:collapse; font-size:0.75em; text-align:center; table-layout:fixed;">
                    <thead><tr style="background:#222; color:#aaa;">
                        <th style="padding:4px; width:25px;">#</th>
                        <th style="padding:4px; text-align:left; width:100px;">T√Ωm</th>`;

                teams.forEach((t, i) => {
                    html += `<th style="padding:4px; border-left:1px solid #444;">${i + 1}</th>`;
                });

                html += `<th style="padding:4px; border-left:2px solid #555; width:30px;">B</th>
                         <th style="padding:4px; border-left:1px solid #444; width:50px;">Sk√≥re</th>
                         <th style="padding:4px; border-left:1px solid #444; width:30px; background:#332;">M</th>
                    </tr></thead><tbody>`;

                teams.forEach((tRow, i) => {
                    html += `<tr style="border-bottom:1px solid #444;">
                        <td style="padding:4px; color:#666;">${i + 1}</td>
                        <td style="padding:4px; text-align:left; font-weight:bold; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${tRow.name}</td>`;

                    teams.forEach((tCol, j) => {
                        let cellContent = "";
                        let cellStyle = "border-left:1px solid #444; padding:4px;";

                        if (i === j) {
                            cellStyle += "background:#111;";
                        } else {
                            // Find match between tRow and tCol
                            const match = state.schedule.find(m =>
                                m.type === 'match' &&
                                ((m.home === tRow.id && m.guest === tCol.id) || (m.home === tCol.id && m.guest === tRow.id)) &&
                                m.homeScore !== null && m.guestScore !== null
                            );

                            if (match) {
                                if (match.home === tRow.id) {
                                    cellContent = `${match.homeScore}:${match.guestScore}`;
                                } else {
                                    cellContent = `${match.guestScore}:${match.homeScore}`;
                                }
                            } else {
                                cellContent = "-";
                            }
                        }
                        html += `<td style="${cellStyle}">${cellContent}</td>`;
                    });

                    const s = stats[tRow.id] || { pts: 0, gf: 0, ga: 0 };
                    const rank = ranks[tRow.id] || "-";

                    html += `<td style="padding:4px; border-left:2px solid #555; font-weight:bold; color:var(--accent-green);">${s.pts}</td>
                             <td style="padding:4px; border-left:1px solid #444; color:#888;">${s.gf}:${s.ga}</td>
                             <td style="padding:4px; border-left:1px solid #444; background:#332; font-weight:bold;">${rank}.</td>
                    </tr>`;
                });

                html += `</tbody></table></div>`;
                container.innerHTML = html;
            },

            renderMusic: () => {
                const list = document.getElementById('music-list');
                const container = document.getElementById('music-controls');
                if (state.musicPlaylist.length === 0) {
                    list.innerHTML = `<li style="color:#666; font-size:0.8em; text-align:center; padding:10px;">Slo≈æka nebyla vybr√°na nebo neobsahuje MP3</li>`;
                    container.style.display = 'none';
                    return;
                }
                container.style.display = 'block';
                list.innerHTML = "";
                state.musicPlaylist.forEach((track, idx) => {
                    const li = document.createElement('li');
                    li.className = "match-item" + (idx === currentMusicIndex ? " active-match" : "");
                    li.style.display = "flex";
                    li.style.alignItems = "center";
                    li.style.padding = "5px 10px";
                    li.draggable = true;
                    li.dataset.index = idx;

                    li.innerHTML = `
                        <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; cursor:move;">${track.name}</span>
                        <span style="font-size:1.2em; cursor:pointer;" onclick="event.stopPropagation(); music.play(${idx})">${idx === currentMusicIndex && !currentMusicAudio.paused ? '‚ô´' : '‚ñ∂'}</span>
                    `;

                    // Drag & Drop
                    li.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', idx);
                        li.style.opacity = '0.5';
                    });
                    li.addEventListener('dragend', () => li.style.opacity = '1');
                    li.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        li.classList.add('drag-over');
                    });
                    li.addEventListener('dragleave', () => li.classList.remove('drag-over'));
                    li.addEventListener('drop', (e) => {
                        e.preventDefault();
                        li.classList.remove('drag-over');
                        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                        const toIdx = idx;
                        if (fromIdx !== toIdx) {
                            music.reorder(fromIdx, toIdx);
                        }
                    });

                    li.onclick = () => music.play(idx);
                    list.appendChild(li);
                });
            },

            renderPhase: () => {
                try {
                    const isEvent = state.currentMatch.isEvent;
                    const phaseControls = document.getElementById('phase-controls');
                    const eventLabel = document.getElementById('event-label');
                    const phase = state.currentMatch.phaseIndex;

                    if (isEvent) {
                        if (phaseControls) phaseControls.style.display = 'none';
                        if (eventLabel) {
                            eventLabel.style.display = 'block';
                            eventLabel.textContent = state.currentMatch.title;
                        }
                        // Hide score controls for events
                        const hp = document.getElementById('home-team-panel');
                        const gp = document.getElementById('guest-team-panel');
                        if (hp) hp.style.visibility = 'hidden';
                        if (gp) gp.style.visibility = 'hidden';
                    } else {
                        if (phaseControls) phaseControls.style.display = 'flex';
                        if (eventLabel) eventLabel.style.display = 'none';

                        const buttons = document.querySelectorAll('.phase-btn');
                        buttons.forEach(btn => {
                            const bPhase = parseInt(btn.dataset.phase);
                            const isActive = (bPhase === phase);
                            btn.classList.toggle('active', isActive);
                        });

                        // Show score controls for matches
                        const hp = document.getElementById('home-team-panel');
                        const gp = document.getElementById('guest-team-panel');
                        if (hp) hp.style.visibility = 'visible';
                        if (gp) gp.style.visibility = 'visible';
                    }
                    ui.updateMatchInfo();
                } catch (e) {
                    console.error("UI: Error in renderPhase", e);
                }
            },

            updateMatchInfo: () => {
                const infoDiv = document.getElementById('match-info-display');
                if (state.activeMatchIndex > -1 && state.schedule[state.activeMatchIndex]) {
                    const m = state.schedule[state.activeMatchIndex];
                    infoDiv.textContent = `${state.activeMatchIndex + 1}. ${m.title || ""}`;
                } else {
                    infoDiv.textContent = state.tournamentName || "Z√°pas";
                }
            },



            updateDurationHints: () => {
                try {
                    const ids = ['time-play', 'time-break', 'time-setup'];
                    ids.forEach(id => {
                        const input = document.getElementById(id);
                        const hint = document.getElementById(`hint-${id}`);
                        if (input && hint) {
                            const val = parseInt(input.value) || 0;
                            hint.innerText = admin.formatTime(val);
                        }
                    });
                } catch (e) {
                    console.error("UI: Error updating duration hints:", e);
                }
            },

            updateScores: () => {
                document.getElementById('home-score-disp').textContent = state.currentMatch.homeScore;
                document.getElementById('guest-score-disp').textContent = state.currentMatch.guestScore;
            },

            updateNames: () => {
                document.getElementById('home-name-disp').textContent = admin.getTeamName(state.currentMatch.homeName);
                document.getElementById('guest-name-disp').textContent = admin.getTeamName(state.currentMatch.guestName);
                ui.updateLogos();
            },

            updateLogos: () => {
                const hImg = document.getElementById('home-logo-disp');
                const gImg = document.getElementById('guest-logo-disp');

                const hLogo = state.teamLogos[state.currentMatch.homeName];
                const gLogo = state.teamLogos[state.currentMatch.guestName];

                if (hLogo) {
                    hImg.src = hLogo;
                    hImg.style.opacity = '1';
                } else {
                    hImg.src = '';
                    hImg.style.opacity = '0';
                }

                if (gLogo) {
                    gImg.src = gLogo;
                    gImg.style.opacity = '1';
                } else {
                    gImg.src = '';
                    gImg.style.opacity = '0';
                }
            },

            updateTimer: () => {
                const m = Math.floor(state.timer.timeLeft / 60).toString().padStart(2, '0');
                const s = Math.floor(state.timer.timeLeft % 60).toString().padStart(2, '0');
                document.getElementById('main-timer').textContent = `${m}:${s}`;
            },

            updateTimerBtn: () => {
                const btn = document.getElementById('btn-timer-toggle');
                const tDisp = document.getElementById('main-timer');
                const up = document.getElementById('btn-time-up');
                const down = document.getElementById('btn-time-down');

                if (state.timer.running) {
                    btn.textContent = "‚è∏"; // Pause
                    btn.classList.remove('btn-green');
                    btn.classList.add('btn-yellow');
                    tDisp.contentEditable = "false";
                    if (up) up.disabled = true;
                    if (down) down.disabled = true;
                } else {
                    btn.textContent = "‚ñ∂"; // Play
                    btn.classList.remove('btn-yellow');
                    btn.classList.add('btn-green');
                    tDisp.contentEditable = "true";
                    if (up) up.disabled = false;
                    if (down) down.disabled = false;
                }
            },

            fillSelects: () => {
                // Teams
                const teamSelects = ['sched-home', 'sched-guest'];
                teamSelects.forEach(id => {
                    const sel = document.getElementById(id);
                    if (!sel) return;
                    const currentVal = sel.value;
                    sel.innerHTML = '<option value="">-- Vyber Dru≈æstvo --</option>';
                    state.teams.forEach(t => {
                        sel.innerHTML += `<option value="${t.id}">${t.name}</option>`;
                    });
                    // Only restore value if it still exists in the list or is empty
                    if (state.teams.includes(currentVal) || currentVal === "") sel.value = currentVal;
                });

                // Referees
                const refSelects = ['sched-referee'];
                refSelects.forEach(id => {
                    const sel = document.getElementById(id);
                    if (!sel) return;
                    const currentVal = sel.value;
                    sel.innerHTML = '<option value="">-- Vyber Rozhodƒç√≠ho --</option>';
                    state.referees.forEach(r => {
                        sel.innerHTML += `<option value="${r.id}">${r.name}</option>`;
                    });
                    if (state.referees.includes(currentVal) || currentVal === "") sel.value = currentVal;
                });
            },

            renderSchedule: () => {
                const list = document.getElementById('match-queue');
                const form = document.getElementById('sched-form-container');
                const header = document.getElementById('sched-list-header'); // Po≈ôad√≠:

                // Move form back to safe spot (below header) before clearing
                if (form && header) {
                    header.after(form);
                }

                list.innerHTML = "";
                state.schedule.forEach((m, idx) => {
                    const li = document.createElement('li');
                    li.className = "match-item";
                    li.draggable = true;
                    li.dataset.index = idx;
                    li.title = "Dvojklik pro editaci, Ta≈æen√≠m zmƒõ≈à po≈ôad√≠";

                    // Double Click to Edit
                    li.addEventListener('dblclick', (e) => {
                        admin.editScheduleMatch(idx);
                    });

                    // Drag Events
                    li.addEventListener('dragstart', (e) => {
                        // If we are dragging an item that's part of a selection, move the whole selection
                        // If not, select just this item and move it
                        if (!state.selectedIndices.includes(idx)) {
                            // IMPORTANT: Use silent mode to avoid re-rendering and destroying the dragged element
                            admin.toggleSelection(idx, false, false, true);
                            li.classList.add('selected-match');
                        }

                        e.dataTransfer.effectAllowed = 'move';
                        // Store the indices as a JSON string
                        const data = JSON.stringify(state.selectedIndices);
                        e.dataTransfer.setData('text/plain', data);

                        // Set a drag image if multiple items are selected? (Browser default is usually fine)
                        li.style.opacity = '0.5';
                    });

                    li.addEventListener('dragend', (e) => {
                        li.style.opacity = '1';
                        // Remove drop indicator styles from all items
                        document.querySelectorAll('.match-item').forEach(item => {
                            item.classList.remove('drop-indicator-top', 'drop-indicator-bottom');
                        });
                    });

                    li.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';

                        // Remove indicators from all items first
                        document.querySelectorAll('.match-item').forEach(item => {
                            item.classList.remove('drop-indicator-top', 'drop-indicator-bottom');
                        });

                        // Calculate if mouse is in top or bottom half of item
                        const rect = li.getBoundingClientRect();
                        const relY = e.clientY - rect.top;

                        if (relY > rect.height / 2) {
                            li.classList.add('drop-indicator-bottom');
                        } else {
                            li.classList.add('drop-indicator-top');
                        }
                    });

                    li.addEventListener('dragleave', (e) => {
                        li.classList.remove('drop-indicator-top', 'drop-indicator-bottom');
                    });

                    li.addEventListener('drop', (e) => {
                        e.preventDefault();
                        li.classList.remove('drop-indicator-top', 'drop-indicator-bottom');

                        try {
                            const indices = JSON.parse(e.dataTransfer.getData('text/plain'));
                            let toIndex = idx;

                            // Calculate if we should insert AFTER the target item
                            // This allows reaching the end of the list when dropping on the bottom half of the last item
                            const rect = li.getBoundingClientRect();
                            const relY = e.clientY - rect.top;
                            if (relY > rect.height / 2) {
                                toIndex++;
                            }

                            // If it's just one index and it's same as target, do nothing
                            if (Array.isArray(indices)) {
                                admin.moveMatchesTo(indices, toIndex);
                            } else if (typeof indices === 'number') {
                                // Fallback for old single-item behavior if any
                                admin.moveMatch(indices, toIndex);
                            }
                        } catch (err) {
                            console.error("Drop error", err);
                        }
                    });

                    if (idx === state.activeMatchIndex) {
                        li.classList.add('active-match');
                    }
                    if (idx === state.pendingEditIndex) {
                        li.classList.add('editing-match');
                    }
                    if (state.selectedIndices.includes(idx)) {
                        li.classList.add('selected-match');
                    }

                    const isEvent = m.type === 'event';
                    let hasScore = (m.homeScore !== undefined && m.homeScore !== null && m.guestScore !== undefined && m.guestScore !== null);
                    let scoreDisplay = hasScore ? `${m.homeScore}:${m.guestScore}` : "-:-";

                    if (isEvent) {
                        const durMin = Math.floor((m.duration || 600) / 60);
                        li.innerHTML = `
                            <div style="flex:1; display:grid; grid-template-columns: 120px 1fr 15px 1fr 60px 1fr; align-items:center; font-size:0.85em; gap:5px; padding-right:10px; overflow:hidden;">
                                <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><b>${idx + 1}.</b> ${m.title || "Ud√°lost"}</div>
                                <div style="grid-column: 2 / 5; text-align:center; color:#aaa; white-space:nowrap;">‚è± ${durMin}m</div>
                                <div></div>
                                <div></div>
                            </div>
                        `;
                    } else {
                        li.innerHTML = `
                            <div style="flex:1; display:grid; grid-template-columns: 120px 1fr 15px 1fr 60px 1fr; align-items:center; font-size:0.85em; gap:5px; padding-right:10px; overflow:hidden;">
                                <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><b>${idx + 1}.</b> ${m.title}</div>
                                <div style="text-align:right; font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${admin.getTeamName(m.home)}</div>
                                <div style="text-align:center; color:#888;">:</div>
                                <div style="text-align:left; font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${admin.getTeamName(m.guest)}</div>
                                <div style="text-align:center; ${hasScore ? 'font-weight:900; color:var(--accent-green);' : 'font-weight:300; color:#fff;'}">${scoreDisplay}</div>
                                <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:#aaa; font-style:italic;">${admin.getRefName(m.referee)}</div>
                            </div>
                        `;
                    }

                    li.onclick = (e) => {
                        admin.toggleSelection(idx, e.shiftKey, e.ctrlKey);
                    };

                    list.appendChild(li);
                });

                // If editing, move form to the correct spot (below item)
                if (state.pendingEditIndex > -1 && form) {
                    const targetLi = list.querySelector(`.match-item[data-index="${state.pendingEditIndex}"]`);
                    if (targetLi) {
                        targetLi.after(form);
                    }
                }
            },

            updateMusicIndicatorState: () => {
                const btnMini = document.getElementById('btn-music-toggle-mini');
                if (btnMini) {
                    if (!currentMusicAudio.paused) {
                        btnMini.classList.add('active');
                        btnMini.innerText = '‚ô´';
                    } else {
                        btnMini.classList.remove('active');
                        btnMini.innerText = '‚ô´';
                    }
                }
                // Also update the note symbols in the music playlist list
                ui.renderMusic();
            },

            updateProjection: () => {
                try {
                    if (!state.isProjectionMode) return;

                    const pLayout = document.getElementById('projection-layout');
                    const qrLayout = document.getElementById('qr-layout');

                    if (isQR) {
                        if (pLayout) pLayout.style.display = 'none';
                        if (qrLayout) {
                            qrLayout.style.display = 'flex';
                            document.getElementById('qr-tournament-name').innerText = state.tournamentName || "SB Scoreboard";
                            document.getElementById('qr-session-id').innerText = state.sessionId;

                            // Generate QR Code if empty
                            const container = document.getElementById('qr-container');
                            if (container && container.innerHTML === "") {
                                const poUrl = window.location.origin + window.location.pathname + '?projection&session=' + state.sessionId;
                                new QRCode(container, {
                                    text: poUrl,
                                    width: Math.min(window.innerWidth, window.innerHeight) * 0.6,
                                    height: Math.min(window.innerWidth, window.innerHeight) * 0.6,
                                    colorDark: "#000000",
                                    colorLight: "#ffffff",
                                    correctLevel: QRCode.CorrectLevel.H
                                });
                            }
                        }
                        return;
                    }

                    if (pLayout) pLayout.style.display = 'grid';
                    if (qrLayout) qrLayout.style.display = 'none';

                    console.log("UI: updateProjection start");

                    const usedState = (state.poTransitionActive && state.poTransitionData) ? state.poTransitionData : state;
                    const isBlinking = state.poTransitionActive;

                    const PHASES_LIST = ["Nastupuje", "1. Poloƒças", "P≈ôest√°vka", "2. Poloƒças"];
                    const matchData = usedState.currentMatch || { title: "Z√°pas", homeName: "Dom√°c√≠", guestName: "Host√©", homeScore: 0, guestScore: 0, phaseIndex: 0 };
                    const teamLogos = usedState.teamLogos || {};
                    const teams = usedState.teams || [];
                    const referees = usedState.referees || [];

                    const getTName = (id) => {
                        const t = teams.find(x => x.id === id);
                        return t ? t.name : (id || "T√Ωm");
                    };
                    const getRName = (id) => {
                        const r = referees.find(x => x.id === id);
                        return r ? r.name : (id || "-");
                    };

                    // Update Theme
                    document.body.classList.toggle('theme-dark', usedState.theme === 'dark');
                    document.body.classList.toggle('theme-light', usedState.theme !== 'dark');

                    // Update Top Row
                    const titleEl = document.getElementById('p-match-title');
                    if (titleEl) titleEl.innerText = matchData.title || "";

                    const isEventMode = !!matchData.isEvent;
                    const phaseNameEl = document.getElementById('p-phase-name');
                    if (phaseNameEl) {
                        phaseNameEl.innerText = isEventMode ? "" : (PHASES_LIST[matchData.phaseIndex] || "");
                        phaseNameEl.classList.toggle('p-row-blink', isBlinking);
                    }

                    const timerEl = document.getElementById('p-timer');
                    if (timerEl) {
                        const m = Math.floor(usedState.timer.timeLeft / 60).toString().padStart(2, '0');
                        const s = Math.floor(usedState.timer.timeLeft % 60).toString().padStart(2, '0');
                        timerEl.innerText = m + ":" + s;
                    }

                    // Main View Mode (Match vs Event)
                    const matchCont = document.getElementById('p-match-content');
                    if (matchCont) matchCont.style.display = isEventMode ? 'none' : 'grid';
                    const eventCont = document.getElementById('p-event-content');
                    if (eventCont) {
                        eventCont.style.display = isEventMode ? 'flex' : 'none';
                        if (isEventMode) {
                            let title = usedState.currentMatch.title || "Ud√°lost";
                            if (title.length > 20) title = title.substring(0, 17) + "...";
                            eventCont.innerText = title;
                            eventCont.classList.toggle('p-row-blink', isBlinking);
                        }
                    }

                    if (!isEventMode) {
                        const hn = document.getElementById('p-home-name');
                        if (hn) hn.innerText = getTName(matchData.homeName);
                        const gn = document.getElementById('p-guest-name');
                        if (gn) gn.innerText = getTName(matchData.guestName);
                        const hs = document.getElementById('p-home-score');
                        if (hs) hs.innerText = matchData.homeScore;
                        const gs = document.getElementById('p-guest-score');
                        if (gs) gs.innerText = matchData.guestScore;

                        const scoreBox = document.getElementById('p-score-box');
                        if (scoreBox) scoreBox.classList.toggle('p-row-blink', isBlinking);

                        const hi = document.getElementById('p-home-logo');
                        if (hi) {
                            const hl = teamLogos[matchData.homeName];
                            if (hl) { hi.src = hl; hi.style.opacity = '1'; } else { hi.src = ''; hi.style.opacity = '0'; }
                        }
                        const gi = document.getElementById('p-guest-logo');
                        if (gi) {
                            const gl = teamLogos[matchData.guestName];
                            if (gl) { gi.src = gl; gi.style.opacity = '1'; } else { gi.src = ''; gi.style.opacity = '0'; }
                        }
                    }

                    // Upcoming Matches
                    const upcomingBody = document.getElementById('p-upcoming-body');
                    if (upcomingBody) {
                        upcomingBody.innerHTML = "";
                        const nextItems = (usedState.schedule || []).slice(usedState.activeMatchIndex + 1, usedState.activeMatchIndex + 5);
                        nextItems.forEach((match, idx) => {
                            const tr = document.createElement('tr');
                            tr.className = 'p-sched-row';
                            const isItemEvent = match.type === 'event';

                            if (isItemEvent) {
                                const durMin = Math.floor((match.duration || 600) / 60);
                                tr.innerHTML = `
                                    <td class="p-sched-col-match">${usedState.activeMatchIndex + 1 + idx + 1}. ${match.title || "Ud√°lost"}</td>
                                    <td class="p-sched-col-teams" style="text-align:center; color:var(--accent-blue);">
                                        <div style="font-weight:900; letter-spacing:1px; text-transform:uppercase;">‚è± ${durMin} min</div>
                                    </td>
                                    <td class="p-sched-col-refs"></td>
                                `;
                            } else {
                                const hLogo = teamLogos[match.home];
                                const gLogo = teamLogos[match.guest];

                                tr.innerHTML = `
                                    <td class="p-sched-col-match">${usedState.activeMatchIndex + 1 + idx + 1}. ${match.title || "Z√°pas"}</td>
                                    <td class="p-sched-col-teams">
                                        <div class="p-teams-flex">
                                            <div class="p-teams-side-home">
                                                <span>${getTName(match.home)}</span>
                                                <img src="${hLogo || ''}" class="p-mini-logo" style="opacity:${hLogo ? '1' : '0'}">
                                            </div>
                                            <div class="p-teams-sep">:</div>
                                            <div class="p-teams-side-guest">
                                                <img src="${gLogo || ''}" class="p-mini-logo" style="opacity:${gLogo ? '1' : '0'}">
                                                <span>${getTName(match.guest)}</span>
                                            </div>
                                        </div>
                                    </td>
                                    <td class="p-sched-col-refs">${getRName(match.referee)}</td>
                                `;
                            }
                            upcomingBody.appendChild(tr);
                        });
                    }

                    // Footer Visibility & Telemetry
                    const footer = document.getElementById('p-row-footer');
                    const layout = document.getElementById('projection-layout');
                    if (footer && layout) {
                        const fv = (usedState.showFooter !== false);
                        footer.style.display = fv ? 'grid' : 'none';
                        layout.style.gridTemplateRows = fv ? '18vh 48vh 30vh 4vh' : '18vh 48vh 34vh 0vh';

                        if (usedState.telemetry) {
                            const progEl = document.getElementById('p-footer-progress');
                            if (progEl) progEl.innerText = usedState.telemetry.progress;
                            const endEl = document.getElementById('p-footer-end');
                            if (endEl) endEl.innerText = usedState.telemetry.end;
                            // Time is updated locally by setInterval in game.init for smoother experience
                        }
                    }
                    // Final consistency check
                    const existingLayout = document.getElementById('projection-layout');
                    if (existingLayout) {
                        console.log("UI: layout height", existingLayout.offsetHeight, "rows", existingLayout.style.gridTemplateRows);
                    }
                } catch (err) {
                    console.error("UI Update Error:", err);
                }
            }
        };

        // --- UTILS ---
        function toggleAccordion(id) {
            const content = document.getElementById(id);
            if (content.classList.contains('open')) {
                content.classList.remove('open');
            } else {
                content.classList.add('open');
                // Force render if schedule is opened to ensure it is up to date/visible
                if (id === 'acc-schedule') {
                    ui.renderSchedule();
                }
            }
        }

        function openProjectionWindow() {
            const url = window.location.origin + window.location.pathname + '?projection&session=' + state.sessionId;
            projectionWindow = window.open(url, "ScoreboardProjection_" + state.sessionId, "width=800,height=600");
            if (!projectionWindow) {
                alert("Vyskakovac√≠ okno bylo zablokov√°no. Pros√≠m povolte jej pro tuto str√°nku.");
            } else {
                game.syncProjection();
            }
        }

        // Legacy implementation removed.

        // Initial Sync for Admin/Main view
        game.syncProjection();


        // Music Audio Events for Indicator stability
        // (Already set up above for both audio elements)

        // --- INIT ---
        window.addEventListener('load', game.init);

    </script>

    <!-- Conflict Resolution Modal -->
    <div id="modal-player-conflicts" class="modal-overlay"
        style="display:none; z-index: 10000; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); display:none; align-items:center; justify-content:center;">
        <div
            style="background:var(--bg-dark); border:1px solid #444; width:90%; max-width:800px; max-height:85vh; border-radius:8px; display:flex; flex-direction:column; box-shadow:0 10px 30px rgba(0,0,0,0.5);">
            <div
                style="padding:20px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center;">
                <h3 style="margin:0; color:var(--accent-blue);">‚ö†Ô∏è Revize konflikt≈Ø v datab√°zi</h3>
                <span style="font-size:0.8em; color:#888;">Porovnejte st√°vaj√≠c√≠ data s importem</span>
            </div>

            <div id="conflict-list-container" style="flex:1; overflow-y:auto; padding:20px;">
                <!-- Conflicts will be rendered here -->
            </div>

            <div
                style="padding:15px; border-top:1px solid #333; display:flex; justify-content:flex-end; gap:10px; background:#1a1a1a; border-bottom-left-radius:8px; border-bottom-right-radius:8px;">
                <button class="small-btn btn-yellow" onclick="admin.cancelConflictReview()">Zru≈°it import</button>
                <button class="small-btn btn-green" id="btn-resolve-all" style="padding:8px 20px;">Dokonƒçit import
                    ‚úÖ</button>
            </div>
        </div>
    </div>

    <!-- PUBLIC QR CODE LAYOUT (PO2) -->
    <div id="qr-layout"
        style="display:none; flex-direction:column; align-items:center; justify-content:center; height:100vh; background:#1a1a1a; color:white; padding:20px; text-align:center;">
        <h1 id="qr-tournament-name" style="font-size:3.5vw; margin-bottom:2vh; color:var(--accent-blue);">SB Scoreboard
        </h1>
        <div id="qr-container"
            style="background:white; padding:2vw; border-radius:1vw; box-shadow:0 1vw 3vw rgba(0,0,0,0.5);"></div>
        <div style="margin-top:4vh; font-size:2vw;">
            <p>Naskenujte pro sledov√°n√≠ v√Ωsledk≈Ø na mobilu</p>
            <p style="font-size:1.5vw; color:#888; margin-top:1vh;">Relace: <span id="qr-session-id"
                    style="color:var(--accent-blue); font-weight:bold;">---</span></p>
        </div>
    </div>

    <style>
        .conflict-row {
            background: #252525;
            border: 1px solid #444;
            border-radius: 6px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .conflict-header {
            background: #333;
            padding: 8px 12px;
            font-size: 0.85em;
            font-weight: bold;
            color: #ccc;
            border-bottom: 1px solid #444;
        }

        .conflict-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: #444;
        }

        .conflict-cell {
            background: #252525;
            padding: 12px;
        }

        .conflict-label {
            display: block;
            font-size: 0.7em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .conflict-value {
            font-size: 0.95em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conflict-choice {
            display: flex;
            gap: 5px;
            padding: 10px;
            background: #1a1a1a;
            justify-content: flex-end;
        }

        .choice-btn {
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: 0.2s;
        }

        .choice-btn:hover {
            background: #444;
        }

        .choice-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
            font-weight: bold;
        }

        .val-diff {
            color: #ffab40;
            font-weight: bold;
        }
    </style>
</body>

</html>