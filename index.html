<!DOCTYPE html>
<html lang="cs">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OmniScore (OmS)</title>
    <!-- SheetJS for Excel/CSV import -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <!-- QRCode library for PO2 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-bg: #2d2d2d;
            --text-color: #ffffff;
            --accent-green: #4caf50;
            --accent-red: #f44336;
            --accent-yellow: #ffc107;
            --accent-blue: #2196f3;
            --border-radius: 8px;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
            /* Prevent body scroll if content fits */
        }

        #app-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            height: 100%;
        }

        /* Responsive Layout */
        @media (max-width: 1024px) {
            #app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                overflow-y: auto;
            }

            body {
                overflow-y: auto;
                height: auto;
            }
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        h2,
        h3 {
            margin-top: 0;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }

        /* --- Controls Section (Left Panel) --- */
        #game-controls {
            gap: 20px;
        }

        /* Phase Navigation */
        .phase-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #383838;
            padding: 10px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
        }

        .phase-steps {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .phase-btn {
            background: #555;
            border: none;
            color: #aaa;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .phase-btn.active {
            background: var(--accent-blue);
            color: white;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
        }

        .nav-arrow {
            background: #444;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
        }

        .nav-arrow:hover {
            background: #666;
        }

        /* Score & Time Area */
        .scoreboard-interface {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
            gap: 20px;
            flex-grow: 1;
            align-items: center;
        }

        .team-panel {
            text-align: center;
            background: #333;
            padding: 20px;
            border-radius: var(--border-radius);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 0;
            /* Allow shrinking for ellipsis */
            position: relative;
            z-index: 1;
            /* Below center panel */
        }

        .team-logo {
            width: 80px;
            height: 80px;
            object-fit: contain;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            display: block;
            /* Always visible to maintain layout */
            opacity: 0;
            /* Invisible by default, will be set to 1 when logo is loaded */
        }

        .team-name {
            font-size: 1.5em;
            font-weight: bold;
            color: #ddd;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .score-display {
            font-size: 4em;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
        }

        .score-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn-speaker {
            font-size: 0.8em;
            padding: 5px;
        }

        .btn-speaker svg {
            width: 24px;
            height: 24px;
        }

        .round-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .center-panel {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
            z-index: 2;
            /* Above team panels */
        }

        .timer-display {
            font-size: 5em;
            font-family: 'Courier New', monospace;
            background: #000;
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #444;
            color: var(--accent-yellow);
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #main-timer {
            outline: none;
            cursor: default;
        }

        #main-timer[contenteditable="true"]:hover {
            background: #111;
            cursor: text;
        }

        .timer-arrows {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .arrow-btn {
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 0.4em;
            padding: 0;
            line-height: 1;
            transition: color 0.2s;
        }

        .arrow-btn:hover {
            color: var(--accent-yellow);
        }

        .arrow-btn:disabled {
            color: #333;
            cursor: not-allowed;
        }

        .timer-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .music-mini-panel {
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
            background: #222;
            padding: 6px 12px;
            border-radius: 20px;
            margin-top: 10px;
            border: 1px solid #444;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            width: fit-content;
        }

        .music-mini-panel .round-btn {
            background: none !important;
            border: none !important;
            color: #888 !important;
            box-shadow: none !important;
            width: 32px;
            height: 32px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .music-mini-panel .round-btn:hover {
            color: #bbb !important;
        }

        #btn-music-toggle-mini {
            font-size: 1.5em;
        }


        #btn-music-toggle-mini.active {
            color: #00a2ff !important;
        }

        .small-btn {
            padding: 5px 10px;
            font-size: 0.9em;
            background: #555;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* --- Admin Section (Right Panel) --- */
        #admin-panel {
            overflow-y: auto;
        }

        .accordion {
            margin-bottom: 10px;
        }

        .accordion-header {
            background-color: #444;
            padding: 10px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }

        .accordion-content {
            padding: 10px;
            background: #383838;
            margin-top: 2px;
            border-radius: 0 0 4px 4px;
            display: none;
        }

        .accordion-content.open {
            display: block;
        }

        .form-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #ccc;
        }

        input,
        select {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .btn-full {
            width: 100%;
            padding: 10px;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .btn-projection {
            background: #9c27b0;
            margin-bottom: 20px;
        }

        /* Color Utilities (must be after layout classes) */
        .btn-green {
            background-color: var(--accent-green) !important;
        }

        .btn-red {
            background-color: var(--accent-red) !important;
        }

        .btn-yellow {
            background-color: var(--accent-yellow) !important;
            color: #000 !important;
        }

        .btn-orange {
            background-color: #ff9800 !important;
            color: white !important;
        }

        /* List Styling */
        .match-list {
            list-style: none;
            padding: 0;
        }

        .match-item {
            background: #444;
            margin-bottom: 5px;
            padding: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            position: relative;
            /* Required for ::before positioning */
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .match-item.drop-indicator-top::before,
        .match-item.drop-indicator-bottom::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 3px;
            background-color: #4caf50;
            z-index: 10;
        }

        .match-item.drop-indicator-top::before {
            top: -2px;
        }

        .match-item.drop-indicator-bottom::before {
            bottom: -2px;
        }

        .active-match {
            border-left: 5px solid var(--accent-green);
            background-color: #3e5e40;
        }

        .editing-match {
            background-color: #8c2a2a !important;
            /* Redish background for edit */
            border: 2px solid #f44336;
        }

        .selected-match {
            background-color: #2b4b7c !important;
            /* Blue for selection */
            border-left: 5px solid #2196f3;
        }

        .schedule-toolbar {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
            background: #2a2a2a;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .schedule-toolbar .small-btn {
            background: #444;
            min-width: 32px;
            font-weight: bold;
        }

        .schedule-toolbar .small-btn:hover {
            background: #555;
        }

        .schedule-toolbar .btn-red:hover {
            background: #d32f2f !important;
        }

        .schedule-toolbar .btn-green:hover {
            background: #388e3c !important;
        }

        .identity-row {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-bottom: 5px;
        }

        .identity-label {
            width: 120px;
            font-size: 0.8em;
            color: #888;
            flex-shrink: 0;
            white-space: nowrap;
        }

        /* --- Admin Footer --- */
        #admin-footer {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            align-items: center;
            background: #111;
            padding: 0 20px;
            color: #888;
            font-size: 0.85em;
            font-weight: bold;
            border-top: 1px solid #333;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 35px;
            box-sizing: border-box;
            z-index: 1000;
        }

        #admin-footer-end {
            text-align: center;
        }

        #admin-footer-time {
            text-align: right;
        }

        body {
            padding-bottom: 55px;
            /* 35px footer + 20px gap */
        }

        /* Space for fixed footer */

        /* PROJECTION MODE OVERRIDES */
        body.mode-projection {
            margin: 0;
            padding: 0 !important;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            background: #000;
            color: #fff;
            display: block;
            /* Overriding possible grid from other modes */
        }

        body.mode-projection #app-container,
        body.mode-projection #admin-footer {
            display: none !important;
        }

        #projection-layout {
            display: none;
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            grid-template-rows: 18vh 48vh 30vh 4vh;
        }

        body.mode-projection #projection-layout {
            display: grid;
        }

        /* Reuse projection styles from old window generation */
        .p-row {
            display: grid;
            align-items: center;
            padding: 0 4vw;
        }

        #p-row-top {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
        }

        #p-match-title {
            font-size: 3vw;
            text-align: left;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #p-phase-name {
            font-size: 4vw;
            font-weight: 800;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.1vw;
        }

        #p-timer {
            font-size: 6vw;
            font-family: 'Courier New', monospace;
            text-align: right;
            font-weight: bold;
        }

        #p-row-mid {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
        }

        .p-team {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2vh;
            min-width: 0;
        }

        .p-team-name {
            font-size: 4.5vw;
            font-weight: 900;
            text-align: center;
            line-height: 1.1;
            text-transform: uppercase;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .p-team-logo {
            width: 17vw;
            height: 17vw;
            object-fit: contain;
            border-radius: 2vw;
            display: block;
            opacity: 0;
            /* Always visible to maintain layout */
        }

        #p-score-box {
            font-size: 16vw;
            font-weight: 900;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #p-score-sep {
            margin: 0 1vw;
        }

        #p-event-content {
            display: none;
            grid-column: 1 / span 3;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 9vw;
            font-weight: 900;
            text-transform: uppercase;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 0 5vw;
            box-sizing: border-box;
        }

        #p-row-bot {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            padding: 0;
            overflow: hidden;
        }

        .p-sched-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        #p-upcoming-header {
            display: grid;
            grid-template-columns: 22% 56% 22%;
            align-items: flex-start;
            padding: 0.5vh 4vw 0 4vw;
            font-size: 1.8vw;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05vw;
            height: 5vh;
            margin-bottom: 1vh;
            box-sizing: border-box;
        }

        #p-match-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-column: 1 / span 3;
            width: 100%;
            height: 100%;
            align-items: center;
        }

        .p-sched-row {
            height: 5.5vh;
            font-size: 1.8vw;
        }

        .p-sched-col-match {
            width: 22%;
            text-align: left;
            font-weight: 500;
        }

        .p-sched-col-teams {
            width: 56%;
            font-weight: 700;
            padding: 0;
        }

        .p-sched-col-refs {
            width: 22%;
            text-align: right;
            font-size: 1.5vw;
        }

        .p-teams-flex {
            display: flex;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .p-teams-side-home {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            text-align: right;
            overflow: hidden;
        }

        .p-teams-side-guest {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            text-align: left;
            overflow: hidden;
        }

        .p-teams-sep {
            width: 4vw;
            text-align: center;
            flex-shrink: 0;
            font-size: 2vw;
            font-weight: 900;
        }

        .p-mini-logo {
            width: 2.5vw;
            height: 2.5vw;
            object-fit: contain;
            vertical-align: middle;
            margin: 0 0.8vw;
            border-radius: 0.5vw;
            display: inline-block;
            opacity: 0;
            /* Always visible to maintain layout */
        }

        #p-row-footer {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            align-items: center;
            padding: 0 4vw;
            font-size: 1.0vw;
            font-weight: bold;
            color: #888;
        }

        .p-footer-center {
            text-align: center;
            font-weight: bold;
        }

        .p-footer-right {
            text-align: right;
        }

        /* THEMES for Projection */
        body.mode-projection.theme-light {
            background: #ffffff;
            color: #333333;
        }

        body.mode-projection.theme-light #p-row-top {
            background: #fcfcfc;
        }

        body.mode-projection.theme-light #p-match-title {
            color: #777777;
        }

        body.mode-projection.theme-light #p-phase-name {
            color: #1a73e8;
        }

        body.mode-projection.theme-light #p-timer {
            color: #d32f2f;
        }

        body.mode-projection.theme-light #p-score-box,
        body.mode-projection.theme-light #p-event-content {
            color: #2e7d32;
        }

        body.mode-projection.theme-light #p-row-bot {
            background: #f8f9fa;
        }

        body.mode-projection.theme-light .p-sched-row {
            border-bottom: 1px solid #e9ecef;
            color: #3c4043;
        }

        body.mode-projection.theme-dark {
            background: #000000;
            color: #ffffff;
        }

        body.mode-projection.theme-dark #p-row-top {
            background: #0a0a0a;
        }

        body.mode-projection.theme-dark #p-match-title {
            color: #aaaaaa;
        }

        body.mode-projection.theme-dark #p-timer {
            color: #ffc107;
        }

        body.mode-projection.theme-dark #p-score-box,
        body.mode-projection.theme-dark #p-event-content {
            color: #4caf50;
        }

        body.mode-projection.theme-dark .p-sched-row {
            border-bottom: 1px solid #222222;
            color: #dddddd;
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }

            100% {
                opacity: 1;
            }
        }

        .p-row-blink {
            animation: blink 1s infinite;
        }

        /* Schedule Sections - Simplified */
        .sched-section {
            display: none;
            border: 1px solid var(--accent-blue);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            background: rgba(33, 150, 243, 0.03);
        }

        #sched-section-import {
            border-color: #555;
            background: rgba(255, 255, 255, 0.01);
        }

        .sched-section.active {
            display: block;
        }

        .sched-section h4 {
            margin: 0 0 12px 0;
            padding: 0;
            font-size: 0.85em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #sched-section-gen h4 {
            color: var(--accent-blue);
        }

        #sched-section-import h4 {
            color: #aaa;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: #222;
            padding: 2px;
            border-radius: 6px;
            margin-bottom: 12px;
            border: 1px solid #444;
        }

        .mode-toggle-btn {
            flex: 1;
            padding: 6px;
            border: none;
            background: none;
            color: #777;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .mode-toggle-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        .mode-toggle-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .icon-sq {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            background: var(--accent-blue);
            border-radius: 4px;
            color: white;
            flex-shrink: 0;
        }

        .mode-toggle-btn.active .icon-sq {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Suggestion & Chips */
        .suggestion-container {
            position: relative;
            width: 100%;
        }

        .suggestion-box {
            position: absolute;
            top: 100%;
            left: 0;
            width: 240px;
            background: #222;
            border: 1px solid #444;
            max-height: 150px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .suggestion-item {
            padding: 8px;
            cursor: pointer;
            font-size: 0.8em;
            border-bottom: 1px solid #333;
        }

        .suggestion-item:hover {
            background: #333;
        }

        .suggestion-item.add-new {
            color: var(--accent-blue);
            font-weight: bold;
        }

        .player-chip {
            background: #444;
            color: #fff;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            margin: 2px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .remove-chip {
            cursor: pointer;
            color: #888;
            font-weight: bold;
        }

        .remove-chip:hover {
            color: #ff4d4d;
        }

        /* ===================================================================================
           REGION: VE≈òEJN√Å ZOBRAZEN√ç (PUBLIC VIEWS: OPZ, STANDINGS, CROSS)
           =================================================================================== */
        body.mode-view-schedule,
        body.mode-view-standings,
        body.mode-view-cross,
        body.mode-qr {
            margin: 0;
            padding: 0 !important;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Default (Dark) Colors for Public Views */
        body.mode-view-schedule.theme-dark,
        body.mode-view-standings.theme-dark,
        body.mode-view-cross.theme-dark {
            background: #0b0e14;
            color: #fff;
        }

        /* Light Mode Colors for Public Views */
        body.mode-view-schedule.theme-light,
        body.mode-view-standings.theme-light,
        body.mode-view-cross.theme-light {
            background: #f8f9fa;
            color: #212529;
        }

        /* Hide other layouts when in public view mode */
        body.mode-view-schedule #app-container,
        body.mode-view-schedule #admin-footer,
        body.mode-view-schedule #projection-layout,
        body.mode-view-standings #app-container,
        body.mode-view-standings #admin-footer,
        body.mode-view-standings #projection-layout,
        body.mode-view-cross #app-container,
        body.mode-view-cross #admin-footer,
        body.mode-view-cross #projection-layout {
            display: none !important;
        }

        .pv-container {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
            padding: 2vh 4vw;
            box-sizing: border-box;
        }

        body.mode-view-schedule #view-schedule-layout {
            display: flex;
        }

        body.mode-view-standings #view-standings-layout {
            display: flex;
        }

        body.mode-view-cross #view-cross-layout {
            display: flex;
        }

        .pv-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--accent-blue);
            padding-bottom: 1vh;
            margin-bottom: 2vh;
        }

        .pv-title {
            font-size: 3vw;
            font-weight: 900;
            text-transform: uppercase;
            color: var(--accent-blue);
        }

        .pv-clock {
            font-size: 2.5vw;
            font-weight: 700;
            color: #888;
        }

        .pv-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 1.6vw;
        }

        .pv-table th {
            text-align: left;
            padding: 1.5vh 1vw;
            text-transform: uppercase;
            font-size: 0.8em;
        }

        /* Hide table headers in QR mode */
        body.mode-qr .pv-table thead {
            display: none !important;
        }

        /* QR Layout unification */
        body.mode-qr .pv-container:not(#qr-layout) {
            display: none !important;
        }

        body.mode-qr #qr-layout {
            display: flex !important;
            background: transparent !important;
            /* Will use body background */
            padding: 2vh 4vw;
        }

        .qr-inner {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        /* QR Grid Styles */
        .qr-grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3vh 2vw;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        .qr-grid-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2.5vh;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .theme-light .qr-grid-item {
            background: rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .qr-grid-label {
            font-size: 1.1vw;
            font-weight: bold;
            margin-bottom: 2vh;
            color: var(--accent-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .qr-grid-code {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 170px;
            height: 170px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .qr-grid-code:hover {
            transform: scale(1.03);
        }

        /* Horizontal QR Grid for Projection Bottom Row */
        .qr-grid-horizontal {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1vw;
            width: 100%;
            padding: 1vh 2vw;
            box-sizing: border-box;
            align-items: center;
        }

        .qr-grid-horizontal .qr-grid-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 1vh;
            border-radius: 8px;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .qr-grid-horizontal .qr-grid-label {
            font-size: 0.8vw;
            font-weight: bold;
            margin-bottom: 0.5vh;
            color: var(--accent-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .qr-grid-horizontal .qr-grid-code {
            background: white;
            padding: 5px;
            border-radius: 6px;
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qr-grid-horizontal .qr-grid-code canvas,
        .qr-grid-horizontal .qr-grid-code img {
            max-width: 100%;
            max-height: 100%;
        }

        /* Transitions for Projection Bottom Row */
        #p-upcoming-container,
        #p-qr-projection-container {
            transition: opacity var(--qr-transition-duration, 1.5s) ease;
            width: 100%;
        }

        #p-qr-projection-container {
            position: absolute;
            top: 5vh;
            /* Align with upcoming header */
            left: 0;
            height: calc(100% - 5vh);
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        /* Table header/cell theme overrides */
        .theme-dark .pv-table th {
            background: rgba(255, 255, 255, 0.05);
            color: #aaa;
        }

        .theme-light .pv-table th {
            background: rgba(0, 0, 0, 0.05);
            color: #666;
        }

        .pv-table td {
            padding: 1.2vh 1vw;
        }

        .theme-dark .pv-table td {
            border-bottom: 1px solid #222;
        }

        .theme-light .pv-table td {
            border-bottom: 1px solid #dee2e6;
        }

        .col-rank,
        .col-pts,
        .col-score {
            text-align: center !important;
        }

        .pv-table td.played-score {
            color: #4caf50;
            font-weight: 900 !important;
        }

        .pv-table tr.active td.pv-score-cell {
            font-weight: 900;
        }

        .pv-table tr.active {
            border-left: 5px solid var(--accent-green);
        }

        .theme-dark .pv-table tr.active {
            background: rgba(76, 175, 80, 0.2);
        }

        .theme-light .pv-table tr.active {
            background: rgba(76, 175, 80, 0.15);
        }

        .pv-table tr.active td {
            color: #fff;
            font-weight: 700;
        }

        .pv-team-cell {
            display: flex;
            align-items: center;
            gap: 1vw;
        }

        .pv-logo {
            width: 3vw;
            height: 3vw;
            object-fit: contain;
        }

        /* Standing specific */
        .col-rank {
            width: 4vw;
            text-align: center;
            color: var(--accent-blue);
            font-weight: 900;
        }

        .col-pts {
            width: 6vw;
            text-align: center;
            font-weight: 900;
        }

        .col-score {
            width: 8vw;
            text-align: center;
            color: #888;
        }

        /* Cross table specific */
        .cross-table {
            table-layout: fixed;
        }

        .cross-table td,
        .cross-table th {
            text-align: center;
            height: 5vw;
        }

        .theme-dark .cross-table td,
        .theme-dark .cross-table th {
            border: 1px solid #333;
        }

        .theme-light .cross-table td,
        .theme-light .cross-table th {
            border: 1px solid #dee2e6;
        }

        .theme-dark .cross-table thead tr,
        .theme-dark .cross-table tbody td:nth-child(1),
        .theme-dark .cross-table tbody td:nth-child(2),
        .theme-dark .cross-self {
            background: #1f1f1f !important;
        }

        .theme-light .cross-table thead tr,
        .theme-light .cross-table tbody td:nth-child(1),
        .theme-light .cross-table tbody td:nth-child(2),
        .theme-light .cross-self {
            background: #f2f2f2 !important;
        }

        .cross-result {
            font-weight: 900;
        }

        /* Custom Scrollbar for Public Views */
        .pv-container div::-webkit-scrollbar {
            width: 8px;
        }

        .pv-container div::-webkit-scrollbar-track {
            background: transparent;
        }

        .theme-dark .pv-container div::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        .theme-light .pv-container div::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }

        .pv-container div::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>

<body>

    <div id="app-container">
        <!-- LEFT PANEL: Game Controls -->
        <div id="game-controls" class="panel">
            <button class="btn-full btn-projection" onclick="openProjectionWindow()">üìΩÔ∏è Otev≈ô√≠t Projekci Sk√≥re</button>

            <div class="phase-nav">
                <button class="nav-arrow" onclick="game.step(-1)">‚óÑ</button>
                <div class="phase-steps" id="phase-controls">
                    <button class="phase-btn" data-phase="0">Nastupuje</button>
                    <button class="phase-btn" data-phase="1">1. Poloƒças</button>
                    <button class="phase-btn" data-phase="2">P≈ôest√°vka</button>
                    <button class="phase-btn" data-phase="3">2. Poloƒças</button>
                </div>
                <div id="event-label"
                    style="display:none; flex:1; text-align:center; font-weight:900; text-transform:uppercase; font-size:1.2em; color:var(--accent-blue); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                    Ud√°lost</div>
                <button class="nav-arrow" onclick="game.step(1)">‚ñ∫</button>
            </div>

            <div class="scoreboard-interface">
                <!-- Home Team -->
                <div class="team-panel" id="home-team-panel">
                    <div class="team-name" id="home-name-disp">Dom√°c√≠</div>
                    <img id="home-logo-disp" class="team-logo" src="" alt="Logo">
                    <div class="score-display" id="home-score-disp">0</div>
                    <div class="score-controls">
                        <button class="round-btn btn-green" onclick="game.adjustScore('home', 1)">+</button>
                        <button class="round-btn btn-green btn-speaker" onclick="game.adjustScore('home', 1, true)"
                            title="G√≥l s jingle">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z" />
                            </svg>
                        </button>
                        <button class="round-btn btn-red" onclick="game.adjustScore('home', -1)">-</button>
                    </div>
                </div>

                <!-- Timer & Center -->
                <div class="center-panel">
                    <div id="match-info-display" style="color:#aaa; margin-bottom:5px; font-weight:bold;">-</div>
                    <div class="timer-display">
                        <span id="main-timer" onblur="game.manualTimeEntry()"
                            onkeydown="if(event.key==='Enter'){this.blur(); event.preventDefault();} else { return admin.restrictToNumbers(event); }">00:00</span>
                        <div class="timer-arrows">
                            <button class="arrow-btn" id="btn-time-up" onclick="game.adjustTime(1)">‚ñ≤</button>
                            <button class="arrow-btn" id="btn-time-down" onclick="game.adjustTime(-1)">‚ñº</button>
                        </div>
                    </div>
                    <div class="timer-controls">
                        <button id="btn-timer-toggle" class="round-btn btn-yellow"
                            onclick="game.toggleTimer()">‚èØ</button>
                        <button class="round-btn btn-red" onclick="game.resetTimer()">‚Ü∫</button>
                    </div>

                    <div class="music-mini-panel" id="music-mini-panel" style="display:none;">
                        <div style="display:flex; align-items:center; gap:8px;">
                            <button class="round-btn" onclick="music.prev()">‚èÆ</button>
                            <button class="round-btn" id="btn-music-toggle-mini" onclick="music.toggle()">‚ô´</button>
                            <button class="round-btn" onclick="music.next()">‚è≠</button>
                        </div>
                        <div style="width: 100%; display: flex; align-items: center; padding: 0 4px;">
                            <input type="range" id="input-vol-music" min="0" max="1" step="0.05" value="0.5"
                                oninput="music.setVolume(this.value)"
                                style="margin:0; height:4px; accent-color:#888; cursor:pointer;">
                        </div>
                    </div>
                </div>

                <!-- Guest Team -->
                <div class="team-panel" id="guest-team-panel">
                    <div class="team-name" id="guest-name-disp">Host√©</div>
                    <img id="guest-logo-disp" class="team-logo" src="" alt="Logo">
                    <div class="score-display" id="guest-score-disp">0</div>
                    <div class="score-controls">
                        <button class="round-btn btn-green" onclick="game.adjustScore('guest', 1)">+</button>
                        <button class="round-btn btn-green btn-speaker" onclick="game.adjustScore('guest', 1, true)"
                            title="G√≥l s jingle">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z" />
                            </svg>
                        </button>
                        <button class="round-btn btn-red" onclick="game.adjustScore('guest', -1)">-</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT PANEL: Administration -->
        <div id="admin-panel" class="panel">
            <!-- Authentication Section -->
            <div id="auth-section" style="margin-bottom: 20px; padding: 15px; background: rgba(33, 150, 243, 0.1); border: 1px solid var(--accent-blue); border-radius: var(--border-radius);">
                <div id="auth-logged-out">
                    <button class="btn-full btn-projection" onclick="auth.login()" style="background: var(--accent-blue); color: white;">
                        üîë P≈ôihl√°sit se p≈ôes Google
                    </button>
                    <small style="display: block; margin-top: 8px; color: #888; text-align: center;">Pro ulo≈æen√≠ do cloudu a licenci.</small>
                </div>
                <div id="auth-logged-in" style="display: none; align-items: center; justify-content: space-between; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px; overflow: hidden;">
                        <img id="user-photo" src="" style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--accent-blue);">
                        <div style="overflow: hidden;">
                            <div id="user-name" style="font-weight: bold; font-size: 0.9em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">U≈æivatel</div>
                            <div id="license-status" style="font-size: 0.75em; color: var(--accent-yellow);">Ovƒõ≈ôov√°n√≠ licence...</div>
                        </div>
                    </div>
                    <button class="small-btn btn-red" onclick="auth.logout()" style="padding: 5px 10px; font-size: 0.8em;">Odhl√°sit</button>
                </div>
            </div>

            <h3>Turnajov√° Spr√°va</h3>
            <!-- 1. Tournament Settings -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-settings')">
                    Nastaven√≠ Turnaje <span>‚ñº</span>
                </div>
                <div id="acc-settings" class="accordion-content">
                    <!-- BEGIN: QUICK START / IMPORT SECTION -->
                    <div id="quick-setup-box"
                        style="background: rgba(76, 175, 80, 0.1); border: 2px solid var(--accent-green); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4
                            style="margin: 0 0 10px 0; border: none; padding: 0; color: var(--accent-green); display: flex; align-items: center; gap: 8px;">
                            üöÄ Rychl√Ω start / Import / Obnova
                        </h4>
                        <div id="sched-section-import">
                            <label
                                style="display:block; font-size:0.85em; color:#bbb; font-weight:bold; margin-bottom:12px;">
                                Nahr√°t rozpis nebo Z√°lohu turnaje (.xlsx, .xls, .csv)
                            </label>

                            <input type="file" id="input-sched-import" accept=".xlsx, .xls, .csv" style="display:none"
                                onchange="admin.handleScheduleImport(this)">
                            <button class="btn-full" onclick="document.getElementById('input-sched-import').click()"
                                style="background: var(--accent-green); color: #000; font-weight: bold; margin-top:0;">üìÇ
                                Vybrat soubor (Rozpis nebo Z√°loha)</button>

                            <div
                                style="margin-top:15px; font-size:0.8em; color:#ddd; background:rgba(0,0,0,0.2); padding:10px; border-radius:6px; border:1px solid rgba(255,255,255,0.05);">
                                <b
                                    style="color:var(--accent-green); display:block; margin-bottom:8px; font-size:0.9em;">üí°
                                    Inteligentn√≠ Import:</b>

                                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; line-height:1.4;">
                                    <div>
                                        <b style="color:#bbb; font-size:0.85em;">1. Z√°loha turnaje:</b>
                                        <div style="color:#aaa; font-style:italic;">
                                            Pokud nahrajete soubor vytvo≈ôen√Ω funkc√≠ "Export", aplikace rozpozn√° z√°lohu a
                                            nab√≠dne kompletn√≠ obnoven√≠.
                                        </div>
                                    </div>
                                    <div>
                                        <b style="color:#bbb; font-size:0.85em;">2. Bƒõ≈æn√Ω rozpis:</b>
                                        <ul style="margin:4px 0; padding-left:15px; color:#aaa;">
                                            <li>Auto-detekce sloupc≈Ø</li>
                                            <li>Zachov√°n√≠ log a jingl≈Ø</li>
                                            <li>Podpora XLSX i CSV</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- END: QUICK START / IMPORT SECTION -->

                    <button class="btn-full btn-yellow" onclick="admin.resetTournament()"
                        style="margin-bottom: 20px;">Resetovat Turnaj</button>

                    <div class="form-group">
                        <label>N√°zev Turnaje</label>
                        <input type="text" id="input-tournament-name" placeholder="Nap≈ô. Zimn√≠ Poh√°r" maxlength="96"
                            oninput="admin.sanitizeInput(this); admin.saveSettings(false)">
                    </div>

                    <div class="form-group">
                        <label>Kategorie</label>
                        <select id="input-tournament-category" onchange="admin.saveSettings(false)">
                            <option value="">-- Bez kategorie --</option>
                            <optgroup label="Vzory z√°kladn√≠">
                                <option value="U9">U9 (P≈ôed≈æ√°ci do 8 let)</option>
                                <option value="U11">U11 (Mlad≈°√≠ ≈æ√°ci 9‚Äì10 let)</option>
                                <option value="U13">U13 (Mlad≈°√≠ ≈æ√°ci/≈æ√°kynƒõ 11‚Äì12 let)</option>
                                <option value="U15">U15 (Star≈°√≠ ≈æ√°ci/≈æ√°kynƒõ 13‚Äì14 let)</option>
                                <option value="U17">U17 (Kadeti/Kadetky 15‚Äì16 let)</option>
                                <option value="U19">U19 (Junio≈ôi/Juniorky 17‚Äì18 let)</option>
                                <option value="U23">U23 (Mu≈æi/≈Ωeny 19‚Äì22 let)</option>
                                <option value="Elite">Elite (Mu≈æi/≈Ωeny 23+ let)</option>
                                <option value="Masters">Masters (Mu≈æi/≈Ωeny 30+ let)</option>
                            </optgroup>
                            <optgroup label="Vzory kolov√° 2022">
                                <option value="≈Ω√°ci">≈Ω√°ci</option>
                                <option value="Junio≈ôi">Junio≈ôi</option>
                                <option value="U23_kolova">U23</option>
                                <option value="Elite_kolova">Elite</option>
                                <option value="Veter√°ni">Veter√°ni</option>
                                <option value="≈Ωeny">≈Ωeny</option>
                            </optgroup>
                        </select>
                    </div>

                    <h4 style="margin: 15px 0 10px 0; border: none; padding: 0;">D√©lka krok≈Ø (s)</h4>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">Poloƒças</label>
                            <input type="number" id="time-play" value="420" min="0" max="3599" style="width: 100%;"
                                oninput="admin.validateTimeInput(this)"
                                onkeydown="return admin.restrictToNumbers(event)">
                            <small id="hint-time-play"
                                style="color: #4caf50; font-size: 0.75em; display: block; margin-top: 2px;">-</small>
                        </div>
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">P≈ôest√°vka</label>
                            <input type="number" id="time-break" value="105" min="0" max="3599" style="width: 100%;"
                                oninput="admin.validateTimeInput(this)"
                                onkeydown="return admin.restrictToNumbers(event)">
                            <small id="hint-time-break"
                                style="color: #4caf50; font-size: 0.75em; display: block; margin-top: 2px;">-</small>
                        </div>
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">Nastupuje</label>
                            <input type="number" id="time-setup" value="10" min="0" max="3599" style="width: 100%;"
                                oninput="admin.validateTimeInput(this)"
                                onkeydown="return admin.restrictToNumbers(event)">
                            <small id="hint-time-setup"
                                style="color: #4caf50; font-size: 0.75em; display: block; margin-top: 2px;">-</small>
                        </div>
                    </div>

                    <div class="form-group" style="display: flex; gap: 10px;">
                        <div style="flex: 1.5;">
                            <label>Datum kon√°n√≠</label>
                            <input type="date" id="input-tournament-date" oninput="admin.saveSettings(false)">
                        </div>
                        <div style="flex: 2;">
                            <label>M√≠sto kon√°n√≠</label>
                            <input type="text" id="input-tournament-location" placeholder="Mƒõsto, hala..."
                                maxlength="32" oninput="admin.sanitizeInput(this); admin.saveSettings(false)">
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Po≈ô√°daj√≠c√≠ odd√≠l / spolek</label>
                        <select id="input-tournament-organizer" onchange="admin.saveSettings(false)">
                            <option value="">-- vybrat ze seznamu --</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Hrac√≠ plocha</label>
                        <input type="text" id="input-pitch-size" placeholder="nap≈ô. 11 x 14 (m)" maxlength="32"
                            oninput="admin.sanitizeInput(this); admin.saveSettings(false)">
                    </div>

                    <h4 style="margin: 20px 0 10px 0; border: none; padding: 0;">Ofici√°ln√≠ ƒçinitel√©</h4>
                    <div style="display: flex; flex-direction: column; gap: 5px;">
                        <div class="identity-row">
                            <span class="identity-label">Hlavn√≠ rozhodƒç√≠</span>
                            <div style="display: flex; gap: 5px; flex: 1;">
                                <input type="text" id="official-chief-referee-surname" placeholder="P≈ô√≠jmen√≠"
                                    oninput="admin.sanitizeInput(this); admin.saveSettings(false)" maxlength="32"
                                    style="flex:1.2">
                                <input type="text" id="official-chief-referee-firstname" placeholder="Jm√©no"
                                    oninput="admin.sanitizeInput(this); admin.saveSettings(false)" maxlength="32"
                                    style="flex:1">
                            </div>
                        </div>
                        <div class="identity-row">
                            <span class="identity-label">Zapisovatel</span>
                            <div style="display: flex; gap: 5px; flex: 1;">
                                <input type="text" id="official-recorder-surname" placeholder="P≈ô√≠jmen√≠"
                                    oninput="admin.sanitizeInput(this); admin.saveSettings(false)" maxlength="32"
                                    style="flex:1.2">
                                <input type="text" id="official-recorder-firstname" placeholder="Jm√©no"
                                    oninput="admin.sanitizeInput(this); admin.saveSettings(false)" maxlength="32"
                                    style="flex:1">
                            </div>
                        </div>
                        <div class="identity-row">
                            <span class="identity-label">ƒåasomƒõ≈ôiƒç</span>
                            <div style="display: flex; gap: 5px; flex: 1;">
                                <input type="text" id="official-timekeeper-surname" placeholder="P≈ô√≠jmen√≠"
                                    oninput="admin.sanitizeInput(this); admin.saveSettings(false)" maxlength="32"
                                    style="flex:1.2">
                                <input type="text" id="official-timekeeper-firstname" placeholder="Jm√©no"
                                    oninput="admin.sanitizeInput(this); admin.saveSettings(false)" maxlength="32"
                                    style="flex:1">
                            </div>
                        </div>
                    </div>

                    <h4 style="margin: 20px 0 10px 0; border: none; padding: 0;">Sbor rozhodƒç√≠ch (pro z√°pasy)</h4>
                    <div class="form-group">
                        <div id="referees-input-list"
                            style="display:flex; flex-direction:column; gap:5px; margin-bottom:10px;">
                            <!-- Dynamically populated numbered inputs -->
                        </div>
                        <button class="small-btn btn-green" onclick="admin.addRefereeSlot()"
                            title="P≈ôid√° nov√Ω ≈ô√°dek pro zad√°n√≠ jm√©na rozhodƒç√≠ho.">+ P≈ôidat rozhodƒç√≠ho do sboru</button>
                    </div>

                    <h4 style="margin: 20px 0 10px 0; border: none; padding: 0;">R≈Øzn√©</h4>
                    <div class="form-group">
                        <div id="misc-input-list"
                            style="display:flex; flex-direction:column; gap:5px; margin-bottom:10px;">
                            <!-- Dynamically populated -->
                        </div>
                        <button class="small-btn btn-green" onclick="admin.addMiscSlot()"
                            title="P≈ôid√° nov√Ω ≈ô√°dek pro dopl≈àuj√≠c√≠ informace o turnaji.">+ P≈ôidat ≈ô√°dek</button>
                    </div>

                    <div
                        style="display: flex; align-items: center; justify-content: space-between; margin: 20px 0 10px 0;">
                        <h4 style="margin: 0; border: none; padding: 0;">Bodov√°n√≠ a Pravidla</h4>
                        <label
                            style="font-size: 0.75em; color: var(--accent-orange); display: flex; align-items: center; gap: 5px; cursor: pointer; background: #333; padding: 2px 8px; border-radius: 4px; border: 1px solid #444;">
                            <input type="checkbox" id="rule-lock-toggle" onchange="admin.toggleRulesLock()"
                                style="width: auto; margin: 0;"> üîì Upravit
                        </label>
                    </div>

                    <div id="rules-container" style="opacity: 0.6; pointer-events: none; transition: all 0.3s ease;">
                        <div style="display: flex; gap: 10px; margin-bottom: 5px;">
                            <div class="form-group" style="flex: 1; margin-bottom: 0;">
                                <label style="font-size: 0.85em;">V√Ωhra</label>
                                <input type="number" id="rule-win" value="3" min="0" style="width: 100%;"
                                    oninput="admin.saveSettings(false)" disabled
                                    onkeydown="return admin.restrictToNumbers(event)">
                            </div>
                            <div class="form-group" style="flex: 1; margin-bottom: 0;">
                                <label style="font-size: 0.85em;">Rem√≠za</label>
                                <input type="number" id="rule-draw" value="1" min="0" style="width: 100%;"
                                    oninput="admin.saveSettings(false)" disabled
                                    onkeydown="return admin.restrictToNumbers(event)">
                            </div>
                            <div class="form-group" style="flex: 1; margin-bottom: 0;">
                                <label style="font-size: 0.85em;">Prohra</label>
                                <input type="number" id="rule-loss" value="0" min="0" style="width: 100%;"
                                    oninput="admin.saveSettings(false)" disabled
                                    onkeydown="return admin.restrictToNumbers(event)">
                            </div>
                        </div>

                        <div class="form-group" style="margin-top: 15px; text-align: left;">
                            <label
                                style="display: flex; align-items: center; gap: 8px; cursor: pointer; justify-content: flex-start;">
                                <input type="checkbox" id="rule-mini-tables" onchange="admin.saveSettings(false)"
                                    style="margin: 0; width: auto;" disabled>
                                Vz√°jemn√© z√°pasy (Minitabulky)
                            </label>
                            <small style="color: #888; display: block; margin-top: 4px;">P≈ôi rovnosti bod≈Ø rozhoduj√≠
                                vz√°jemn√© z√°pasy p≈ôed celkov√Ωm sk√≥re.</small>
                        </div>
                    </div>

                </div>
            </div>



            <!-- 3. Players -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-players')">
                    Hr√°ƒçi <span>‚ñº</span>
                </div>
                <div id="acc-players" class="accordion-content">
                    <div class="form-group">
                        <label>Seznam hr√°ƒç≈Ø turnaje</label>
                        <div id="players-input-list"
                            style="display:flex; flex-direction:column; gap:5px; margin-bottom:10px;">
                            <!-- Dynamically populated -->
                        </div>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; gap:5px;">
                                <button class="small-btn btn-green" onclick="admin.addPlayerSlot()"
                                    title="P≈ôid√° nov√Ω pr√°zdn√Ω ≈ô√°dek pro zad√°n√≠ jm√©na a UCI-ID hr√°ƒçe.">+ P≈ôidat
                                    hr√°ƒçe</button>
                                <a href="https://portal.czechcyclingfederation.com/Racer" target="_blank"
                                    class="small-btn"
                                    title="Otev≈ôe ofici√°ln√≠ port√°l ƒåSC pro vyhled√°n√≠ UCI-ID podle jm√©na."
                                    style="background:#0056b3; display:flex; align-items:center; text-decoration:none; color:white; font-size:0.75em; padding:0 10px;">
                                    üåê Hledat UCI-ID
                                </a>
                            </div>
                            <div style="display:flex; gap:5px;">
                                <button class="small-btn" onclick="admin.updatePlayersFromCloud()"
                                    title="St√°hne nejnovƒõj≈°√≠ glob√°ln√≠ datab√°zi hr√°ƒç≈Ø z Google Disku a synchronizuje ji s va≈°√≠ hlavn√≠ lok√°ln√≠ verz√≠."
                                    style="background:#00a2ff; flex:1; font-weight:bold;">üîÑ Aktualizovat datab√°zi
                                    hr√°ƒç≈Ø</button>

                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 2. Team Logos & Anthems -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-logos')">
                    Dru≈æstva <span>‚ñº</span>
                </div>
                <div id="acc-logos" class="accordion-content">
                    <div class="form-group">
                        <label>Seznam Dru≈æstev</label>
                        <div id="teams-input-list"
                            style="display:flex; flex-direction:column; gap:5px; margin-bottom:10px;">
                            <!-- Dynamically populated numbered inputs -->
                        </div>
                        <button class="small-btn btn-green" onclick="admin.addTeamSlot()"
                            title="P≈ôid√° nov√Ω ≈ô√°dek pro zad√°n√≠ n√°zvu dru≈æstva.">+ P≈ôidat dru≈æstvo</button>
                    </div>
                    <div id="team-logo-list"
                        style="margin-bottom:15px; border:1px solid #444; padding:10px; border-radius:4px; max-height:250px; overflow-y:auto;">
                        <!-- logo items here -->
                    </div>

                    <h4 style="margin: 20px 0 10px 0; border:none; border-top:1px solid #444; padding-top:15px;">V√Ωchoz√≠
                        nastaven√≠ log</h4>
                    <div class="form-group"
                        style="background: rgba(76, 175, 80, 0.1); padding: 10px; border-radius: 8px; border: 1px solid var(--accent-green); margin-bottom: 20px;">
                        <label style="color: var(--accent-green); font-weight: bold;">V√Ωchoz√≠ logo (pro dru≈æstva bez
                            loga)</label>
                        <input type="file" id="input-default-logo" accept="image/*"
                            onchange="admin.handleDefaultLogo(this)">
                        <small style="display: block; margin-top: 5px; color: #aaa; font-size: 0.75em;">Tento soubor
                            bude p≈ôi≈ôazen v≈°em dru≈æstv≈Øm, kter√° aktu√°lnƒõ nemaj√≠ vybran√© logo.</small>
                    </div>
                </div>
            </div>

            <!-- 4. Schedule -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-schedule')">
                    Z√°pasy <span>‚ñº</span>
                </div>
                <div id="acc-schedule" class="accordion-content">

                    <!-- Schedule Generator Section -->
                    <div id="sched-section-gen"
                        style="margin-bottom: 20px; border-bottom: 1px solid #444; padding-bottom: 15px;">
                        <h4 style="margin-top: 5px;">üìã Gener√°tor rozpis≈Ø</h4>
                        <div id="sched-template-container">
                            <label
                                style="display:block; font-size:0.85em; color:var(--accent-blue); font-weight:bold; margin-bottom:12px;">Vytvo≈ôit
                                rozpis (podle poƒçtu dru≈æstev)</label>
                            <div style="display:flex; gap:8px;">
                                <select id="sched-template-select" style="flex:1">
                                    <optgroup label="Vzory z√°kladn√≠">
                                        <option value="basic_1">1. Pro 3 dru≈æstva</option>
                                        <option value="basic_2">2. Pro 4 dru≈æstva</option>
                                        <option value="basic_3">3. Pro 5 dru≈æstev</option>
                                        <option value="basic_4">4. Pro 6 dru≈æstev</option>
                                        <option value="basic_5">5. Pro 7 dru≈æstev</option>
                                        <option value="basic_6">6. Pro 8 dru≈æstev</option>
                                    </optgroup>
                                    <optgroup label="Vzory kolov√° 2022">
                                        <!-- Bude doplnƒõno pozdƒõji -->
                                    </optgroup>
                                </select>
                                <button class="small-btn btn-blue" onclick="admin.generateScheduleFromTemplate()"
                                    title="Sma≈æe aktu√°ln√≠ rozpis a vytvo≈ô√≠ nov√Ω podle vybran√©ho vzoru a aktu√°ln√≠ch dru≈æstev."
                                    style="background:var(--accent-blue);">Generovat</button>
                            </div>
                        </div>
                    </div>

                    <!-- Manual Add Section -->
                    <div id="sched-form-container"
                        style="display:none; border:1px solid #444; padding:10px; border-radius:4px; margin-bottom:15px; background:#2a2a2a;">
                        <div class="form-group">
                            <label>Typ polo≈æky</label>
                            <select id="sched-type" onchange="admin.onSchedTypeChange()">
                                <option value="match">Z√°pas</option>
                                <option value="event">Ud√°lost</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>N√°zev / Skupina</label>
                            <div style="display:flex; gap:5px;">
                                <select id="sched-title" style="flex:1">
                                    <option value="Z√°kladn√≠ skupina">Z√°kladn√≠ skupina</option>
                                    <option value="Skupina A">Skupina A</option>
                                    <option value="Skupina B">Skupina B</option>
                                    <option value="Skupina C">Skupina C</option>
                                    <option value="Skupina D">Skupina D</option>
                                    <option value="ƒåtvrtfin√°le">ƒåtvrtfin√°le</option>
                                    <option value="Semifin√°le">Semifin√°le</option>
                                    <option value="Fin√°le">Fin√°le</option>
                                    <option value="O um√≠stƒõn√≠">O um√≠stƒõn√≠</option>
                                </select>
                                <input type="text" id="sched-custom-title" placeholder="Vlastn√≠ n√°zev..." maxlength="32"
                                    style="flex:1; display:none;" oninput="admin.sanitizeInput(this)">
                            </div>
                        </div>
                        <div id="sched-match-fields">
                            <div class="form-group">
                                <label>Dom√°c√≠ dru≈æstvo</label>
                                <select id="sched-home"></select>
                            </div>
                            <div class="form-group">
                                <label>Hostuj√≠c√≠ dru≈æstvo</label>
                                <select id="sched-guest"></select>
                            </div>
                            <div class="form-group">
                                <label>Rozhodƒç√≠</label>
                                <select id="sched-referee"></select>
                            </div>
                            <div class="form-group" style="display:flex; gap:10px;">
                                <div style="flex:1">
                                    <label>Sk√≥re Dom.</label>
                                    <input type="number" id="sched-home-score" placeholder="-" style="width:100%"
                                        min="0" onkeydown="return admin.restrictToNumbers(event)">
                                </div>
                                <div style="flex:1">
                                    <label>Sk√≥re Host.</label>
                                    <input type="number" id="sched-guest-score" placeholder="-" style="width:100%"
                                        min="0" onkeydown="return admin.restrictToNumbers(event)">
                                </div>
                            </div>
                        </div>
                        <div id="sched-event-fields" style="display:none;">
                            <div class="form-group">
                                <label>D√©lka trv√°n√≠ (sekundy)</label>
                                <input type="number" id="sched-duration" value="600" min="1" style="width:100%"
                                    onkeydown="return admin.restrictToNumbers(event)">
                            </div>
                        </div>
                        <div id="sched-controls-add" style="display:flex; gap:5px;">
                            <button class="btn-full" onclick="admin.addMatch()"
                                title="Ulo≈æit tento z√°pas nebo ud√°lost do rozpisu."
                                style="background: var(--accent-blue);">Ulo≈æit</button>
                            <button class="btn-full btn-yellow" onclick="admin.toggleAddMode()"
                                title="Zav≈ô√≠t formul√°≈ô bez ulo≈æen√≠ zmƒõn.">Zru≈°it</button>
                        </div>
                        <div id="sched-controls-edit" style="display:none; gap:5px; margin-top:10px;">
                            <button class="btn-full btn-green" onclick="admin.saveEditedMatch()">Ulo≈æit
                                Zmƒõny</button>
                            <button class="btn-full btn-red" onclick="admin.deleteMatch()">Smazat</button>
                            <button class="btn-full btn-yellow" onclick="admin.cancelEdit()">Zru≈°it</button>
                        </div>
                    </div>

                    <h4 id="sched-list-header" style="margin-top:5px; border:none;">Po≈ôad√≠:</h4>
                    <div class="schedule-toolbar">
                        <button class="small-btn btn-green" onclick="admin.toggleAddMode()"
                            title="P≈ôidat nov√Ω z√°pas nebo ud√°lost"><b>+</b></button>
                        <button class="small-btn" onclick="admin.moveSelected(-1)" title="Posunout nahoru">‚ñ≤</button>
                        <button class="small-btn" onclick="admin.moveSelected(1)" title="Posunout dol≈Ø">‚ñº</button>
                        <button class="small-btn btn-red" onclick="admin.deleteSelected()"
                            title="Odstranit vybran√©">x</button>
                        <button class="small-btn btn-yellow" onclick="admin.resetSelectedScores()"
                            title="Resetovat sk√≥re">Reset</button>
                        <button class="small-btn btn-yellow" onclick="admin.editSelected()" title="Upravit vybran√Ω"
                            style="margin-left: auto; background: #fbc02d; color: #000;">Upravit</button>
                        <button class="small-btn btn-blue" onclick="admin.loadSelected()" title="Naƒç√≠st vybran√Ω"
                            style="background: var(--accent-blue);">Naƒç√≠st</button>
                    </div>
                    <ul class="match-list" id="match-queue"></ul>
                </div>
            </div>

            <!-- 5. Unified Tables -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-standings')">
                    Tabulky <span>‚ñº</span>
                </div>
                <div id="acc-standings" class="accordion-content">
                    <div class="tab-switcher"
                        style="display: flex; gap: 5px; margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 8px;">
                        <button id="tab-btn-standings" class="small-btn" style="flex: 1;"
                            onclick="admin.setStandingsTab('standings')"
                            title="Zobrazit standardn√≠ tabulku s po≈ôad√≠m, body a sk√≥re.">Po≈ôad√≠</button>
                        <button id="tab-btn-cross" class="small-btn" style="flex: 1;"
                            onclick="admin.setStandingsTab('cross')"
                            title="Zobrazit k≈ô√≠≈æovou tabulku vz√°jemn√Ωch z√°pas≈Ø.">K≈ô√≠≈æov√°</button>
                    </div>
                    <div id="standings-container">
                        <!-- Standard standings or Cross table will be rendered here -->
                    </div>
                </div>
            </div>

            <!-- 4. Export -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-export')">
                    Exporty <span>‚ñº</span>
                </div>
                <div id="acc-export" class="accordion-content">
                    <h4 style="margin: 0 0 10px 0; border: none; padding: 0; color: #4caf50;">Vzor z√°kladn√≠</h4>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom: 10px;">
                        <button class="btn-full" onclick="exporter.toXLSX()"
                            title="Exportovat rozpis, tabulky a seznam hr√°ƒç≈Ø do Excel souboru (.xlsx)."
                            style="background:#4caf50; margin-top:0;">üìä Excel</button>
                        <button class="btn-full" onclick="exporter.toPrintable()"
                            title="Vygenerovat tiskovou verzi rozpisu a tabulek (otev≈ôe se v nov√©m oknƒõ)."
                            style="background:#2196f3; margin-top:0;">üñ®Ô∏è Pro tisk</button>
                    </div>



                    <h4 style="margin: 0 0 10px 0; border: none; padding: 0; color: #888;">Vzor kolov√° 2022</h4>
                    <div
                        style="font-size: 0.8em; color: #666; font-style: italic; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 4px; border: 1px dashed #444; margin-bottom: 20px;">
                        Tato sekce bude zprovoznƒõna po implementaci hern√≠ch sch√©mat a import≈Ø pro rok 2022.
                    </div>

                    <h4 style="margin: 0 0 10px 0; border: none; padding: 0; color: #888;">Port√°l ƒåSC</h4>
                    <div
                        style="font-size: 0.8em; color: #666; font-style: italic; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 4px; border: 1px dashed #444;">
                        Tato sekce bude zprovoznƒõna v budoucnu pro p≈ô√≠mou integraci s port√°lem ƒåSC.
                    </div>
                </div>
            </div>

            <!-- 6. Audio -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-music')">
                    Audio <span>‚ñº</span>
                </div>
                <div id="acc-music" class="accordion-content">
                    <!-- Subsection: Background Music -->
                    <h4 style="margin: 0 0 10px 0; border: none; padding: 0; color: #4caf50;">Hudba na pozad√≠</h4>
                    <div class="form-group">
                        <button class="btn-full" onclick="music.pickDirectory()"
                            title="Vyberte lok√°ln√≠ slo≈æku s MP3 soubory pro p≈ôehr√°v√°n√≠ na pozad√≠."
                            style="background:#444; margin-top:0;">
                            üìÅ Vybrat slo≈æku s hudbou
                        </button>
                    </div>

                    <div id="music-controls"
                        style="display:none; margin-bottom:15px; background:#2a2a2a; padding:10px; border-radius:4px;">
                        <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                            <div style="color:#aaa; font-size:0.8em;">Pr√°vƒõ hraje:</div>
                            <div id="current-track-name"
                                style="flex:1; font-size:0.8em; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color:#4caf50;">
                                -</div>
                        </div>

                        <div class="form-group">
                            <label>Skladby p≈ôehr√°vat</label>
                            <select id="input-music-mode" onchange="music.setMode(this.value)">
                                <option value="continuous">Za sebou (podle seznamu)</option>
                                <option value="random">N√°hodnƒõ</option>
                            </select>
                        </div>
                        <div class="form-group"
                            style="border-top: 1px solid #444; padding-top: 10px; margin-top: 10px;">
                            <label
                                style="display:flex; align-items:center; gap:10px; cursor:pointer; font-weight: bold; color: #4caf50;">
                                <input type="checkbox" id="input-music-auto"
                                    onchange="music.setAutoEnabled(this.checked)" style="width:auto;">
                                Automatick√Ω re≈æim podle krok≈Ø
                            </label>
                        </div>
                        <div class="form-group">
                            <label>Zmƒõna skladby</label>
                            <select id="input-music-auto-change" onchange="music.setAutoChangeStrategy(this.value)">
                                <option value="continuous">Nechat hr√°t celou skladbu</option>
                                <option value="per-step">Mƒõnit skladbu se zmƒõnou kroku</option>
                                <option value="per-match">Mƒõnit skladbu se zmƒõnou z√°pasu</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>D√©lka prolnut√≠: <span id="fade-dur-disp">1</span>s</label>
                            <input type="range" id="input-music-fade" min="0" max="5" step="0.5" value="1"
                                oninput="music.setFadeDuration(this.value)">
                        </div>
                    </div>

                    <ul class="match-list" id="music-list"
                        style="max-height:150px; overflow-y:auto; margin-bottom: 20px;">
                        <li style="color:#666; font-size:0.8em; text-align:center; padding:10px;">Slo≈æka nebyla
                            vybr√°na
                        </li>
                    </ul>

                    <!-- Subsection: Jingle Pool -->
                    <h4 style="margin: 20px 0 10px 0; border: none; padding: 0; color: #2196f3;">Jingly pro oslavy</h4>
                    <div class="form-group">
                        <label>Re≈æim oslav (tlaƒç√≠tko G√≥l)</label>
                        <select id="input-jingle-mode" onchange="jingles.setMode(this.value)">
                            <option value="priority">T√Ωmov√Ω jingle (priorita) + n√°hodn√Ω</option>
                            <option value="random">V≈ædy n√°hodn√Ω z poolu</option>
                        </select>
                    </div>
                    <div class="form-group"
                        style="background: rgba(33, 150, 243, 0.1); padding: 10px; border-radius: 8px; border: 1px solid var(--accent-blue);">
                        <label style="color: var(--accent-blue); font-weight: bold;">Z√°sobn√≠k jingl≈Ø (Pool)</label>
                        <input type="file" id="input-jingle-upload" multiple accept="audio/*"
                            onchange="jingles.handleUpload(this)">
                        <div
                            style="display:flex; justify-content: space-between; align-items: center; margin-top: 5px;">
                            <small id="jingle-pool-count" style="color: #aaa; font-size: 0.75em;">Poƒçet jingl≈Ø:
                                0</small>
                            <button class="small-btn btn-red" onclick="jingles.clear()"
                                style="padding: 2px 8px; font-size: 0.7em;">Vymazat v≈°e</button>
                        </div>
                    </div>
                    <div id="jingle-pool-list"
                        style="margin-top:10px; font-size:0.75em; color:#888; max-height:100px; overflow-y:auto;">
                        <!-- List of file names -->
                    </div>
                </div>
            </div>

            <!-- 5. Public Views -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-public-views')">
                    Ve≈ôejn√° zobrazen√≠ <span>‚ñº</span>
                </div>
                <div id="acc-public-views" class="accordion-content">
                    <div class="form-group"
                        style="background: rgba(255,193,7,0.05); padding: 15px; border-radius: 10px; border: 1px solid var(--accent-yellow); margin-bottom: 20px;">
                        <label
                            style="color: var(--accent-yellow); font-weight: bold; display: block; margin-bottom: 10px; font-size: 0.9em; text-transform: uppercase;">Hlavn√≠
                            rozcestn√≠k (Hub)</label>
                        <div style="display:flex; gap:10px;">
                            <button class="btn-full btn-yellow" onclick="admin.openAllQRWindow()"
                                style="margin:0; flex:1; height: 50px; font-weight: bold;">
                                üì± QR M≈ò√ç≈ΩKA (2x2)
                            </button>
                            <button class="small-btn btn-yellow" onclick="admin.openQRWindow('all')"
                                title="QR k√≥d pro p≈ô√≠stup k m≈ô√≠≈æce"
                                style="width: 50px; height: 50px; margin:0; display:flex; align-items:center; justify-content:center; font-size: 1.5em;">
                                üì±
                            </button>
                        </div>
                    </div>

                    <h4
                        style="margin: 0 0 10px 0; border:none; padding-bottom:5px; color:#888; font-size: 0.8em; text-transform: uppercase;">
                        Jednotliv√° zobrazen√≠</h4>

                    <div style="display:flex; flex-direction:column; gap:8px; margin-bottom: 20px;">
                        <!-- PO -->
                        <div style="display:flex; gap:8px;">
                            <button class="btn-full" onclick="openProjectionWindow()"
                                style="background:#9c27b0; margin:0; flex:1; text-align: left; padding-left: 15px;">üìΩÔ∏è
                                Projekce Sk√≥re</button>
                            <button class="small-btn btn-yellow" onclick="admin.openQRWindow()"
                                title="QR k√≥d pro Projekci" style="width: 45px; margin:0;">üì±</button>
                        </div>
                        <!-- Schedule -->
                        <div style="display:flex; gap:8px;">
                            <button class="btn-full" onclick="admin.openPublicView('schedule')"
                                style="background:#2196f3; margin:0; flex:1; text-align: left; padding-left: 15px;">üìã
                                Po≈ôad√≠ Z√°pas≈Ø</button>
                            <button class="small-btn btn-yellow" onclick="admin.openQRWindow('schedule')"
                                title="QR k√≥d pro Po≈ôad√≠" style="width: 45px; margin:0;">üì±</button>
                        </div>
                        <!-- Standings -->
                        <div style="display:flex; gap:8px;">
                            <button class="btn-full" onclick="admin.openPublicView('standings')"
                                style="background:#4caf50; margin:0; flex:1; text-align: left; padding-left: 15px;">üìä
                                Tabulka Po≈ôad√≠</button>
                            <button class="small-btn btn-yellow" onclick="admin.openQRWindow('standings')"
                                title="QR k√≥d pro Tabulku" style="width: 45px; margin:0;">üì±</button>
                        </div>
                        <!-- Cross -->
                        <div style="display:flex; gap:8px;">
                            <button class="btn-full" onclick="admin.openPublicView('cross')"
                                style="background:#4caf50; margin:0; flex:1; text-align: left; padding-left: 15px;">üî¢
                                Tabulka K≈ô√≠≈æov√°</button>
                            <button class="small-btn btn-yellow" onclick="admin.openQRWindow('cross')"
                                title="QR k√≥d pro K≈ô√≠≈æovou" style="width: 45px; margin:0;">üì±</button>
                        </div>
                    </div>

                    <h4 style="margin: 20px 0 10px 0; border:none; padding-bottom:5px; border-bottom:1px solid #333;">
                        Nastaven√≠ zobrazen√≠</h4>
                    <div style="display:grid; grid-template-columns:1fr; gap:10px;">
                        <div class="form-group">
                            <label>T√©ma (Vzhled)</label>
                            <select id="input-theme" onchange="admin.saveSettings(false); game.syncProjection()">
                                <option value="light">Svƒõtl√Ω re≈æim</option>
                                <option value="dark">Tmav√Ω re≈æim</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Zpo≈ædƒõn√≠ 1. kroku (s) v Projekci Sk√≥re</label>
                            <input type="number" id="input-po-delay" value="10" min="1" max="20"
                                oninput="admin.validateInputRange(this, 20)"
                                onkeydown="return admin.restrictToNumbers(event)">
                        </div>
                        <div class="form-group" style="border-top: 1px solid #333; padding-top: 10px; margin-top: 5px;">
                            <label
                                style="display:flex; align-items:center; gap:10px; cursor:pointer; color: var(--accent-yellow); font-weight: bold;">
                                <input type="checkbox" id="input-qr-cycling"
                                    onchange="admin.saveSettings(false); game.syncProjection()" style="width:auto;">
                                St≈ô√≠dat QR k√≥dy v projekci
                            </label>
                        </div>
                        <div class="form-group">
                            <label>Interval st≈ô√≠d√°n√≠ (s)</label>
                            <input type="number" id="input-qr-interval" value="8" min="5" max="60"
                                oninput="admin.validateInputRange(this, 60)"
                                onkeydown="return admin.restrictToNumbers(event)">
                        </div>
                        <div class="form-group">
                            <label>D√©lka prol√≠n√°n√≠ (s)</label>
                            <input type="number" id="input-qr-transition" value="2" min="1" max="8" step="1"
                                oninput="admin.validateInputRange(this, 8)"
                                onkeydown="return admin.restrictToNumbers(event)">
                        </div>
                    </div>
                </div>
            </div>


            <!-- 6. Application Settings -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-app-settings')">
                    Nastaven√≠ Aplikace <span>‚ñº</span>
                </div>

                <div id="acc-app-settings" class="accordion-content">
                    <h4 style="margin-bottom:10px; border:none;">Cloudov√° Synchronizace</h4>
                    <div class="form-group">
                        <label style="display:flex; justify-content:space-between; align-items:center;">
                            Google Drive File ID (Hr√°ƒçi)
                            <button class="small-btn" onclick="admin.unlockCloudID()" id="btn-unlock-cloud-id"
                                title="Odemknout pro √∫pravy (vy≈æaduje heslo)"
                                style="font-size: 0.7em; padding: 2px 8px; background: #444;">üîí Upravit</button>
                        </label>
                        <input type="text" id="input-cloud-file-id" placeholder="ID souboru z Google Disku"
                            autocomplete="off" oninput="admin.saveSettings(false)" disabled
                            style="opacity: 0.7; cursor: not-allowed; -webkit-text-security: disc;">
                        <small style="color:#888; font-size:0.75em; display:block; margin-top:4px;">
                            ID z√≠sk√°te z odkazu pro sd√≠len√≠ (nap≈ô. 19QC...e1f3). Nastaveno spr√°vcem.
                        </small>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
                        <button class="btn-full" onclick="admin.exportPlayersWithPassword()"
                            title="Vytvo≈ô√≠ z√°lohu va≈°√≠ aktu√°ln√≠ datab√°ze hr√°ƒç≈Ø do souboru. Vy≈æaduje heslo."
                            style="background:#555;">üì• Export hlavn√≠ datab√°ze hr√°ƒç≈Ø</button>
                    </div>

                    <div class="form-group" style="margin-top: 10px; font-size: 0.8em; color: #888; text-align: right;">
                        ID Relace: <span id="session-id-display"
                            style="font-family: monospace; font-weight: bold; color: var(--accent-blue);">---</span>
                    </div>




                    <h4 style="margin: 20px 0 10px 0; border:none;">Zvuky a Hlasitost</h4>
                    <div class="form-group">
                        <label>Vlastn√≠ sir√©na</label>
                        <input type="file" id="input-audio-file" accept="audio/*" onchange="admin.saveSettings(false)">
                    </div>

                    <div class="form-group">
                        <label>Hlasitost sir√©ny: <span id="vol-signal-disp">50</span>%</label>
                        <input type="range" id="input-vol-signal" min="0" max="1" step="0.05" value="0.5"
                            oninput="document.getElementById('vol-signal-disp').innerText = Math.round(this.value * 100); admin.saveSettings(false)">
                    </div>

                    <div class="form-group">
                        <label>Hlasitost jingl≈Ø: <span id="vol-anthem-disp">50</span>%</label>
                        <input type="range" id="input-vol-anthem" min="0" max="1" step="0.05" value="0.5"
                            oninput="document.getElementById('vol-anthem-disp').innerText = Math.round(this.value * 100); admin.saveSettings(false)">
                    </div>

                    <div class="form-group" style="padding-top: 10px; margin-top: 10px; border-top: 1px solid #444;">
                        <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
                            <input type="checkbox" id="input-show-footer" onchange="admin.saveSettings(false)"
                                style="width:auto;" checked>
                            Patiƒçka s informacemi
                        </label>
                    </div>

                    <button class="btn-full" style="margin-top:20px; background: var(--accent-blue);"
                        onclick="admin.saveSettings()">Ulo≈æit v≈°echna nastaven√≠</button>
                    <button class="btn-full btn-red" style="margin-top:10px;" onclick="admin.resetApp()">Resetovat
                        celou
                        aplikaci</button>
                </div>
            </div>
        </div> <!-- END of #admin-panel -->
    </div> <!-- END of #app-container -->


    <div id="admin-footer">
        <div style="text-align:left; font-size:0.85em; white-space:nowrap;">
            <span id="admin-footer-session" style="font-weight:bold; color:var(--accent-blue);">---</span>
            <span id="admin-footer-progress" style="font-weight:bold; color:#888;">&nbsp;&nbsp;&nbsp;&nbsp;-</span>
        </div>
        <div id="admin-footer-end">OmniScore (OmS)</div>
        <div id="admin-footer-time">-</div>
    </div>

    <!-- CLEAN PROJECTION LAYOUT -->
    <div id="projection-layout">
        <div id="p-row-top" class="p-row">
            <div id="p-match-title">...</div>
            <div id="p-phase-name">...</div>
            <div id="p-timer">00:00</div>
        </div>

        <div id="p-row-mid" class="p-row">
            <div id="p-match-content">
                <div class="p-team">
                    <div class="p-team-name" id="p-home-name">DOM√ÅC√ç</div>
                    <img id="p-home-logo" class="p-team-logo" src="">
                </div>
                <div id="p-score-box">
                    <span id="p-home-score">0</span>
                    <span id="p-score-sep">:</span>
                    <span id="p-guest-score">0</span>
                </div>
                <div class="p-team">
                    <div class="p-team-name" id="p-guest-name">HOST√â</div>
                    <img id="p-guest-logo" class="p-team-logo" src="">
                </div>
            </div>
            <div id="p-event-content"></div>
        </div>

        <div id="p-row-bot" class="p-row" style="position: relative;">
            <div id="p-upcoming-container">
                <div id="p-upcoming-header">
                    <div></div>
                    <div style="text-align:center;">N√ÅSLEDUJE</div>
                    <div style="text-align:right;">ROZHODƒå√ç</div>
                </div>
                <div style="padding: 0 4vw; width: 100%; box-sizing: border-box;">
                    <table class="p-sched-table">
                        <tbody id="p-upcoming-body"></tbody>
                    </table>
                </div>
            </div>

            <div id="p-qr-projection-container" style="display: none; opacity: 0;">
                <div class="qr-grid-horizontal">
                    <div class="qr-grid-item">
                        <div class="qr-grid-label">Projekce Sk√≥re</div>
                        <div id="p-qr-grid-projection" class="qr-grid-code"></div>
                    </div>
                    <div class="qr-grid-item">
                        <div class="qr-grid-label">Po≈ôad√≠ Z√°pas≈Ø</div>
                        <div id="p-qr-grid-schedule" class="qr-grid-code"></div>
                    </div>
                    <div class="qr-grid-item">
                        <div class="qr-grid-label">Tabulka Po≈ôad√≠</div>
                        <div id="p-qr-grid-standings" class="qr-grid-code"></div>
                    </div>
                    <div class="qr-grid-item">
                        <div class="qr-grid-label">Tabulka K≈ô√≠≈æov√°</div>
                        <div id="p-qr-grid-cross" class="qr-grid-code"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="p-row-footer" class="p-row">
            <div id="p-footer-progress">Z√°pas: - / -</div>
            <div id="p-footer-end" class="p-footer-center">Konec: --:--</div>
            <div id="p-footer-time" class="p-footer-right">00:00:00</div>
        </div>
    </div>
    </div>

    <!-- ===================================================================================
         REGION: VE≈òEJN√Å ZOBRAZEN√ç HTML (PUBLIC VIEWS HTML)
         =================================================================================== -->
    <div id="view-schedule-layout" class="pv-container">
        <div class="pv-header">
            <div class="pv-title" id="pv-sched-tournament-name">Po≈ôad√≠ Z√°pas≈Ø</div>
        </div>
        <div style="flex:1; overflow-y:auto;">
            <table class="pv-table">
                <thead>
                    <tr>
                        <th style="width:5%;">#</th>
                        <th style="width:25%;">Z√°pas</th>
                        <th style="width:35%;"></th>
                        <th style="width:15%; text-align:center;">V√Ωsledek</th>
                        <th style="width:20%;">Rozhodƒç√≠</th>
                    </tr>
                </thead>
                <tbody id="pv-sched-body"></tbody>
            </table>
        </div>
    </div>

    <div id="view-standings-layout" class="pv-container">
        <div class="pv-header">
            <div class="pv-title" id="pv-stand-title">Tabulka po≈ôad√≠</div>
        </div>
        <div style="flex:1; overflow-y:auto;">
            <table class="pv-table">
                <thead>
                    <tr>
                        <th class="col-rank">#</th>
                        <th>Dru≈æstvo</th>
                        <th class="col-pts">Z</th>
                        <th class="col-pts">B</th>
                        <th class="col-score">S</th>
                        <th class="col-pts">R</th>
                    </tr>
                </thead>
                <tbody id="pv-stand-body"></tbody>
            </table>
        </div>
    </div>

    <div id="view-cross-layout" class="pv-container">
        <div class="pv-header">
            <div class="pv-title" id="pv-cross-title">K≈ô√≠≈æov√° tabulka</div>
        </div>
        <div id="pv-cross-container" style="flex:1; overflow:auto;"></div>
    </div>

    <script>
        // ===================================================================================
        // POZN√ÅMKY K ARCHITEKTU≈òE (ARCHITECTURE NOTES)
        // ===================================================================================
        /*
          Aplikace OmniScore (OmS) pro ≈ô√≠zen√≠ sportovn√≠ch turnaj≈Ø.
          
          Z√°kladn√≠ komponenty:
          - state: Jednotn√Ω zdroj pravdy pro data (tournament, teams, players, schedule, timers).
          - game: Logick√© j√°dro (bƒõh ƒçasu, sk√≥re, p≈ôep√≠n√°n√≠ f√°z√≠).
          - admin: Spr√°va dat, v√Ωpoƒçty tabulek, importy/exporty, persistence (localStorage).
          - ui: Vykreslovac√≠ vrstva pro ovl√°dac√≠ okno i projekci.
          - music/jingles: Moduly pro pr√°ci s audio soubory (FileSystem API, IndexedDB).
          - syncChannel: Synchronizace dat mezi hlavn√≠m oknem a projekƒçn√≠m oknem (BroadcastChannel).
        */

        // ===================================================================================
        // CONFIG & KONSTANTY
        // ===================================================================================
        // --- DATA STRUCTURES ---
        const PHASES = [
            { id: 0, name: "Nastupuje", timeKey: 'setup' },
            { id: 1, name: "1. Poloƒças", timeKey: 'play' },
            { id: 2, name: "P≈ôest√°vka", timeKey: 'break' },
            { id: 3, name: "2. Poloƒças", timeKey: 'play' }
        ];

        const SCHEDULE_TEMPLATES = {
            "basic_1": {
                name: "Pro 3 dru≈æstva",
                teams: 3,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"]]
            },
            "basic_2": {
                name: "Pro 4 dru≈æstva",
                teams: 4,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"]]
            },
            "basic_3": {
                name: "Pro 5 dru≈æstev",
                teams: 5,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"]]
            },
            "basic_4": {
                name: "Pro 6 dru≈æstev",
                teams: 6,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [5, 6, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 6, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [1, 6, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [3, 6, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"], [4, 6, "Z√°kladn√≠ skupina"]]
            },
            "basic_5": {
                name: "Pro 7 dru≈æstev",
                teams: 7,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [5, 6, "Z√°kladn√≠ skupina"], [1, 7, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [6, 7, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"], [4, 7, "Z√°kladn√≠ skupina"], [1, 6, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [2, 7, "Z√°kladn√≠ skupina"], [4, 6, "Zoladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [3, 7, "Z√°kladn√≠ skupina"], [2, 6, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [5, 7, "Z√°kladn√≠ skupina"], [3, 6, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"]]
            },
            "basic_6": {
                name: "Pro 8 dru≈æstev",
                teams: 8,
                matches: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [5, 6, "Z√°kladn√≠ skupina"], [7, 8, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"], [3, 6, "Z√°kladn√≠ skupina"], [1, 7, "Z√°kladn√≠ skupina"], [5, 8, "Z√°kladn√≠ skupina"], [4, 6, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [5, 7, "Z√°kladn√≠ skupina"], [1, 8, "Z√°kladn√≠ skupina"], [2, 6, "Z√°kladn√≠ skupina"], [4, 7, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [1, 6, "Z√°kladn√≠ skupina"], [2, 8, "Z√°kladn√≠ skupina"], [3, 7, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [6, 8, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 7, "Z√°kladn√≠ skupina"], [4, 8, "Z√°kladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [6, 7, "Z√°kladn√≠ skupina"], [3, 8, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"]]
            }
        };

        const CLUBS = [
            "TJ Lokomotiva Liberec",
            "Ml√©k√°rna Ole≈°nice Cykloklub Svit√°vka",
            "S√°lov√° cyklistika Svit√°vka",
            "SK Chodov",
            "SK Prima Nezamyslice",
            "TJ Favorit Brno",
            "TJ MILO Olomouc",
            "TJ Pankr√°c Praha",
            "TJ Sokol ≈†itbo≈ôice",
            "TJ Sokol Zl√≠n-Pr≈°tn√©",
            "TJ Spartak Chrastava",
            "TJ Spartak P≈ôerov",
            "TJ Start Plze≈à"
        ];

        // ===================================================================================
        // GLOB√ÅLN√ç STAV (STATE)
        // ===================================================================================
        let state = {
            isProjectionMode: false, // Will be set in KOMUNIKACE
            sessionId: "", // Will be set in KOMUNIKACE
            isLoading: false,
            tournamentName: "",
            tournamentCategory: "", // Add category field
            times: { setup: 10, play: 420, break: 105 }, // in seconds
            teams: [],
            teamLogos: {}, // Mapping team name to Base64
            teamAnthems: {}, // Mapping team name to Base64 (MP3)
            volSignal: 0.5,
            volAnthem: 0.5,
            referees: [],
            players: [],
            masterPlayers: [], // Global pool of all known players (Main database)
            qrCyclingEnabled: false,
            qrCyclingInterval: 8,
            qrTransitionDuration: 2,
            qrCyclingActive: false, // Internal state for alternating
            currentMatch: {
                title: "",
                homeName: "Dom√°c√≠",
                guestName: "Host√©",
                homeScore: 0,
                guestScore: 0,
                referee: "",
                phaseIndex: 0, // 0-3
                isEvent: false,
                duration: 600
            },
            audioData: null, // Base64 string of the audio file
            timer: {
                running: false,
                timeLeft: 0,
                lastTick: 0,
                targetEndTime: 0
            },
            pendingEditIndex: -1, // Tracks which match is being edited
            schedule: [],
            activeMatchIndex: -1, // Track which match from schedule is active
            theme: "dark", // Default to dark for better initial projection appearance
            cloudFileId: "1wIMbybqiDgI4VnT7zc_q8F6O4ZdMdyGI", // Google Drive File ID for players database
            poTransitionActive: false,
            poTransitionData: null,
            poTransitionDelay: 10,
            volMusic: 0.5,
            jinglePool: [], // List of filenames/IDs
            jingleMode: 'priority', // 'priority' or 'random'
            musicPlaylist: [], // { name: string, handle: FileSystemFileHandle }
            musicAutoEnabled: false,
            musicMode: 'random', // 'continuous' or 'random'
            musicFadeDuration: 1,
            musicAutoChangeStrategy: 'continuous', // 'continuous', 'per-step', 'per-match'
            musicPreviousPhase: -1, // Track previous phase for direction detection
            selectedIndices: [], // Track selected matches
            tournamentStartTime: null, // Timestamp when first timer starts
            playTimeAccumulated: 0, // Seconds of actual play time (halves) completed
            showFooter: true,
            rules: {
                winPoints: 3,
                drawPoints: 1,
                lossPoints: 0,
                useMiniTables: false
            },
            activeStandingsTab: 'standings', // 'standings' or 'cross'
            // Tournament Metadata
            tournamentDate: new Date().toISOString().split('T')[0],
            tournamentLocation: "",
            tournamentOrganizer: "",
            pitchSize: "11 x 14 (m)",
            officialChiefReferee: "",
            officialTimekeeper: "",
            officialRecorder: "",
            misc: [
                { id: "misc_default_1", text: "Startovn√© dru≈æstev bylo uhrazeno. N√°hrady rozhodƒç√≠m byly vyplaceny podle STS ƒåSC." }
            ] // { id: string, text: string }
        };

        let musicAudioA = new Audio();
        let musicAudioB = new Audio();
        let currentMusicAudio = musicAudioA; // Which one is currently playing
        let currentAnthemAudio = null;
        let currentMusicIndex = -1;
        let directoryHandle = null;
        let poTransitionTimeoutID = null;

        // ===================================================================================
        // AUTHENTICATION LOGIC
        // ===================================================================================
        const auth = {
            currentUser: null,
            isVIP: false,
            isPaid: false,

            init: () => {
                firebase.auth().onAuthStateChanged((user) => {
                    auth.currentUser = user;
                    auth.updateUI();
                    if (user) {
                        auth.checkLicense(user);
                    }
                });
            },

            login: () => {
                const provider = new firebase.auth.GoogleAuthProvider();
                firebase.auth().signInWithPopup(provider).catch(err => {
                    console.error("Login failed:", err);
                    alert("Nepoda≈ôilo se p≈ôihl√°sit: " + err.message);
                });
            },

            logout: () => {
                firebase.auth().signOut().then(() => {
                    auth.isVIP = false;
                    auth.isPaid = false;
                    auth.updateUI();
                });
            },

            updateUI: () => {
                const loggedOut = document.getElementById('auth-logged-out');
                const loggedIn = document.getElementById('auth-logged-in');
                const nameEl = document.getElementById('user-name');
                const photoEl = document.getElementById('user-photo');

                if (auth.currentUser) {
                    loggedOut.style.display = 'none';
                    loggedIn.style.display = 'flex';
                    nameEl.innerText = auth.currentUser.displayName || auth.currentUser.email;
                    photoEl.src = auth.currentUser.photoURL || '';
                    photoEl.style.display = auth.currentUser.photoURL ? 'block' : 'none';
                } else {
                    loggedOut.style.display = 'block';
                    loggedIn.style.display = 'none';
                }
            },

            checkLicense: (user) => {
                const statusEl = document.getElementById('license-status');
                // 1. Check if user is in VIP list (simulated for now, would be in DB)
                firebase.database().ref('vip_users').child(user.uid).once('value', snapshot => {
                    if (snapshot.exists()) {
                        auth.isVIP = true;
                        statusEl.innerText = "‚≠ê VIP P≈ô√≠stup";
                        statusEl.style.color = "var(--accent-green)";
                    } else {
                        // 2. Check Stripe status
                        firebase.database().ref('users').child(user.uid).once('value', snap => {
                            const data = snap.val();
                            if (data && data.isPaid && data.expiresAt > Date.now()) {
                                auth.isPaid = true;
                                const date = new Date(data.expiresAt).toLocaleDateString();
                                statusEl.innerText = "‚úÖ Aktivn√≠ do " + date;
                                statusEl.style.color = "var(--accent-green)";
                            } else {
                                auth.isPaid = false;
                                statusEl.innerText = "‚ùå Demo verze (bez licence)";
                                statusEl.style.color = "var(--accent-red)";
                            }
                        });
                    }
                });
            }
        };

        // ===================================================================================
        // KOMUNIKACE (SYNC)
        // ===================================================================================
        let projectionWindow = null;
        let qrWindow = null;

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyAFh3hSr8uAiyS5Wv-YgaxgITxTA-6zSWE",
            authDomain: "omniscore-live.firebaseapp.com",
            databaseURL: "https://omniscore-live-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "omniscore-live",
            storageBucket: "omniscore-live.firebasestorage.app",
            messagingSenderId: "1089053095317",
            appId: "1:1089053095317:web:d90f097e7df2a53e34f29c"
        };

        // ===================================================================================
        // REGION: RELACE A SYNCHRONIZACE (SESSION & SYNC)
        // ===================================================================================
        const urlParams = new URLSearchParams(window.location.search);
        const isPO = urlParams.has('projection');
        const isQR = urlParams.get('mode') && urlParams.get('mode').startsWith('qr');
        const viewMode = urlParams.get('view'); // 'schedule', 'standings', 'cross'
        let sessionId = urlParams.get('session');

        if (!sessionId) {
            sessionId = sessionStorage.getItem('oms_session_id');
            if (!sessionId) {
                sessionId = Math.random().toString(36).substring(2, 7).toUpperCase();
            }
        }

        if (!isPO && !viewMode) {
            sessionStorage.setItem('oms_session_id', sessionId);
        }

        const syncChannel = new BroadcastChannel('oms_sync_' + sessionId);

        // Update state with session info
        state.isProjectionMode = isPO;
        state.viewMode = viewMode;
        state.sessionId = sessionId;


        // ===================================================================================
        // HERN√ç J√ÅDRO (GAME)
        // ===================================================================================
        // --- CORE LOGIC CLASS ---
        // --- FIREBASE INITIALIZATION ---
        if (typeof firebase !== 'undefined' && typeof firebaseConfig !== 'undefined') {
            try {
                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                    console.log("%c[Firebase] Initialized", "color: #4caf50; font-weight: bold;", { sessionId });

                    // Initialize Auth logic
                    auth.init();

                    // Schedule cleanup on disconnect (Only for Admin window)
                    if (!isPO) {
                        const sessionRef = firebase.database().ref('sessions/' + sessionId);
                        sessionRef.onDisconnect().remove().then(() => {
                            console.log("%c[Firebase] onDisconnect cleanup scheduled for session:", "color: #2196f3;", sessionId);
                        }).catch(e => console.error("[Firebase] onDisconnect failed to schedule:", e));
                    }
                }
            } catch (e) { console.error("[Firebase] Initialization failed:", e); }
        }

        const game = {
            init: () => {
                if (state.isProjectionMode || state.viewMode) {
                    if (state.isProjectionMode) document.body.classList.add('mode-projection');
                    if (state.viewMode) document.body.classList.add('mode-view-' + state.viewMode);
                    if (isQR) document.body.classList.add('mode-qr');

                    console.log("Public View/Projection: INIT starting", { mode: state.viewMode || 'projection' });

                    ui.updateProjection();

                    // HANDLER for both BroadcastChannel and Direct window messages
                    const handleSync = (receivedState) => {
                        if (!receivedState || typeof receivedState !== 'object') return;
                        if (receivedState === 'REQUEST_SYNC') return;


                        // Keep local window modes and local animation state
                        const modePO = state.isProjectionMode;
                        const modeView = state.viewMode;
                        const qrActive = state.qrCyclingActive;

                        Object.assign(state, receivedState);

                        state.isProjectionMode = modePO;
                        state.viewMode = modeView;
                        state.qrCyclingActive = qrActive;

                        state.isSynced = true;
                        ui.updateProjection();
                    };

                    syncChannel.onmessage = (event) => handleSync(event.data);
                    window.addEventListener('message', (event) => handleSync(event.data));

                    if (typeof firebase !== 'undefined') {
                        try {
                            const dbRef = firebase.database().ref('sessions/' + state.sessionId);
                            dbRef.on('value', (snapshot) => {
                                const data = snapshot.val();
                                if (data) handleSync(data);
                            });
                        } catch (e) { console.error("Firebase sync error:", e); }
                    }

                    const syncRetry = setInterval(() => {
                        if (state.isSynced) {
                            console.log("init: Sync successful, stopping retry");
                            clearInterval(syncRetry);
                            return;
                        }
                        console.log("init: Sync still empty, retrying REQUEST_SYNC...");
                        syncChannel.postMessage('REQUEST_SYNC');
                    }, 2000);
                    syncChannel.postMessage('REQUEST_SYNC');

                    setInterval(() => {
                        const now = new Date();
                        const timeStr = now.toLocaleTimeString('cs-CZ');
                        const clocks = ['p-footer-time'];
                        clocks.forEach(id => {
                            const el = document.getElementById(id);
                            if (el) {
                                if (id === 'p-footer-time') {
                                    const dateStr = now.getFullYear() + '-' + (now.getMonth() + 1).toString().padStart(2, '0') + '-' + now.getDate().toString().padStart(2, '0');
                                    el.innerText = `${dateStr}\u00A0\u00A0\u00A0\u00A0${timeStr}`;
                                } else {
                                    el.innerText = timeStr;
                                }
                            }
                        });
                    }, 1000);

                    ui.updateProjection();
                    return;
                }

                try {
                    // Reset session ID display colors (branding removed)
                    const footerSess = document.getElementById('admin-footer-session');
                    if (footerSess) footerSess.style.color = 'var(--accent-blue)';
                    const settingSess = document.getElementById('session-id-display');
                    if (settingSess) settingSess.style.color = 'var(--accent-blue)';

                    // Display Session ID in settings
                    const sidDisp = document.getElementById('session-id-display');
                    if (sidDisp) sidDisp.innerText = state.sessionId;

                    // Update the URL display for OBS/copying
                    const purlDisp = document.getElementById('projection-url-display');
                    if (purlDisp) {
                        purlDisp.value = window.location.origin + window.location.pathname + '?projection&session=' + state.sessionId;
                    }

                    admin.loadFromStorage();

                    // Re-activate current match if any was active before F5
                    if (state.activeMatchIndex > -1) {
                        admin.loadMatch(state.activeMatchIndex, false);
                    }

                    ui.renderSchedule();
                    ui.render();

                    // Force broadcast state immediately after load so opened windows get data
                    game.syncProjection();

                    // Listen for sync requests from projection windows
                    syncChannel.onmessage = (event) => {
                        if (event.data === 'REQUEST_SYNC') {
                            game.syncProjection();
                        }
                    };

                    // Start periodic Firebase sync
                    setInterval(() => game.tick(), 100);
                    setInterval(() => ui.updateAdminFooter(), 1000);
                } catch (e) {
                    console.error("Initialization error:", e);
                }
            },

            tick: () => {
                if (!state.timer.running) return;

                const now = Date.now();
                const remainingMs = state.timer.targetEndTime - now;
                const newTimeLeft = Math.max(0, Math.floor(remainingMs / 1000));

                // Track play time accumulation
                if (state.currentMatch.phaseIndex === 1 || state.currentMatch.phaseIndex === 3) {
                    const elapsedSinceLastTick = (now - state.timer.lastTick) / 1000;
                    state.playTimeAccumulated += elapsedSinceLastTick;
                }
                state.timer.lastTick = now;

                if (newTimeLeft !== state.timer.timeLeft) {
                    state.timer.timeLeft = newTimeLeft;

                    if (state.timer.timeLeft <= 0) {
                        state.timer.timeLeft = 0;
                        game.toggleTimer(); // Stop at 0

                        // Play signal only for 1. Poloƒças (1) and 2. Poloƒças (3)
                        if (state.currentMatch.phaseIndex === 1 || state.currentMatch.phaseIndex === 3) {
                            game.playSignal();
                        }
                    }

                    ui.updateTimer();
                    game.syncProjection();
                    ui.updateAdminFooter();
                }
            },

            toggleTimer: () => {
                state.timer.running = !state.timer.running;
                if (state.timer.running) {
                    state.timer.lastTick = Date.now();
                    state.timer.targetEndTime = Date.now() + (state.timer.timeLeft * 1000) - 1;
                    // Set tournament start time if not already set
                    if (state.tournamentStartTime === null) {
                        state.tournamentStartTime = Date.now();
                    }
                    // Immediate first tick to reflect visual change (e.g. 7:00 -> 6:59)
                    game.tick();
                } else {
                    // When pausing, state.timer.timeLeft is already up to date from tick()
                    // but we capture the exact remaining time (float) to preserve precision for resume
                    const remainingMs = state.timer.targetEndTime - Date.now();
                    state.timer.timeLeft = Math.max(0, remainingMs / 1000);
                }
                ui.updateTimerBtn();
                game.syncProjection();
            },

            getPhaseCount: () => {
                return state.currentMatch.isEvent ? 1 : PHASES.length;
            },

            resetTimer: () => {
                state.timer.running = false;
                if (state.currentMatch.isEvent) {
                    state.timer.timeLeft = state.currentMatch.duration || 600;
                } else {
                    const currentPhase = PHASES[state.currentMatch.phaseIndex];
                    state.timer.timeLeft = state.times[currentPhase.timeKey];
                }
                state.timer.targetEndTime = Date.now() + (state.timer.timeLeft * 1000);

                ui.updateTimer();
                ui.updateTimerBtn();
                game.syncProjection();
            },

            adjustTime: (seconds) => {
                state.timer.timeLeft += seconds;
                if (state.timer.timeLeft < 0) state.timer.timeLeft = 0;
                if (state.timer.running) {
                    state.timer.targetEndTime += (seconds * 1000);
                }
                ui.updateTimer();
                game.syncProjection();
            },

            manualTimeEntry: () => {
                const el = document.getElementById('main-timer');
                const val = el.textContent.trim();
                const parts = val.split(':');
                if (parts.length === 2) {
                    const m = parseInt(parts[0]);
                    const s = parseInt(parts[1]);
                    if (!isNaN(m) && !isNaN(s)) {
                        state.timer.timeLeft = (m * 60) + s;
                        if (state.timer.running) {
                            state.timer.targetEndTime = Date.now() + (state.timer.timeLeft * 1000);
                        }
                    }
                }
                ui.updateTimer();
                game.syncProjection();
            },

            adjustScore: (team, delta, playSound = false) => {
                const isHome = team === 'home';
                if (isHome) {
                    state.currentMatch.homeScore += delta;
                    if (state.currentMatch.homeScore < 0) state.currentMatch.homeScore = 0;
                } else {
                    state.currentMatch.guestScore += delta;
                    if (state.currentMatch.guestScore < 0) state.currentMatch.guestScore = 0;
                }

                if (playSound && delta > 0) {
                    const teamName = isHome ? state.currentMatch.homeName : state.currentMatch.guestName;
                    const teamId = isHome ? state.currentMatch.home : state.currentMatch.guest;
                    game.playGoalCelebration(teamId, teamName);
                }

                ui.updateScores();
                game.syncProjection();
            },

            playGoalCelebration: async (teamId, teamName) => {
                let audioData = null;
                let isAnthem = false;

                // 1. Check Mode
                if (state.jingleMode === 'priority') {
                    audioData = state.teamAnthems[teamId] || state.teamAnthems[teamName]; // Try ID then Name for legacy
                    if (audioData) isAnthem = true;
                }

                // 2. Fallback to Pool if no anthem or Mode is 'random'
                if (!audioData) {
                    const poolFile = await jingles.getRandomJingle();
                    if (poolFile) {
                        audioData = URL.createObjectURL(poolFile);
                    }
                }

                // 3. Play if something found
                if (audioData) {
                    if (currentAnthemAudio) {
                        currentAnthemAudio.pause();
                        currentAnthemAudio = null;
                    }

                    // Pre≈ôu≈°it hudbu na pozad√≠
                    if (!currentMusicAudio.paused) {
                        currentMusicAudio.pause();
                        clearInterval(music.fadeInterval);
                        music.fadeInterval = null;
                    }

                    currentAnthemAudio = new Audio(audioData);
                    currentAnthemAudio.volume = state.volAnthem || 1.0;
                    currentAnthemAudio.play().catch(e => console.warn("Celebration play failed:", e));

                    // Revoke URL if it was a Blob URL from pool
                    if (!isAnthem) {
                        currentAnthemAudio.onended = () => URL.revokeObjectURL(audioData);
                    }
                }
            },

            triggerPoTransition: (snapshot) => {
                if (poTransitionTimeoutID) clearTimeout(poTransitionTimeoutID);

                state.poTransitionData = snapshot;
                state.poTransitionActive = true;

                poTransitionTimeoutID = setTimeout(() => {
                    state.poTransitionActive = false;
                    state.poTransitionData = null;
                    game.syncProjection();
                }, (state.poTransitionDelay || 10) * 1000);
            },

            step: (direction) => {
                let newPhaseIndex = state.currentMatch.phaseIndex + direction;
                const phaseCount = game.getPhaseCount();

                // Moving Forward past last phase -> Next Match
                if (newPhaseIndex >= phaseCount) {
                    if (game.loadMatchByRelativeIndex(1)) {
                        // Match loaded, transition handled inside loadMatchByRelativeIndex
                        return;
                    } else {
                        // No next match, stay at end
                        // BUT still save the result of the current last match!
                        if (!state.currentMatch.isEvent && state.activeMatchIndex !== -1 && state.schedule[state.activeMatchIndex]) {
                            state.schedule[state.activeMatchIndex].homeScore = state.currentMatch.homeScore;
                            state.schedule[state.activeMatchIndex].guestScore = state.currentMatch.guestScore;
                            ui.renderSchedule();
                            ui.renderStandings(); // UPDATE STANDINGS
                            admin.saveToStorage(); game.syncProjection();
                            alert("Konec turnaje (nebo posledn√≠ z√°pas). V√Ωsledek ulo≈æen.");
                        }
                        newPhaseIndex = phaseCount - 1;
                    }
                }

                // Moving Backward before first phase -> Prev Match
                if (newPhaseIndex < 0) {
                    if (game.loadMatchByRelativeIndex(-1)) {
                        // Match loaded, phase set inside that function (to last)
                        return;
                    } else {
                        newPhaseIndex = 0;
                    }
                }

                if (newPhaseIndex !== state.currentMatch.phaseIndex) {
                    game.setPhase(newPhaseIndex, true);
                }
            },

            setPhase: (index, resetTime) => {
                // P≈ôeru≈°it prodlevu/blik√°n√≠, pokud zaƒç√≠n√° poloƒças (index 1 nebo 3)
                if ((index === 1 || index === 3) && state.poTransitionActive) {
                    if (poTransitionTimeoutID) clearTimeout(poTransitionTimeoutID);
                    state.poTransitionActive = false;
                    state.poTransitionData = null;
                }

                state.currentMatch.phaseIndex = index;
                if (resetTime) {
                    game.resetTimer();
                }

                // Auto music control
                const previousPhase = state.musicPreviousPhase;
                state.musicPreviousPhase = index; // Update for next time

                if (index === 0 || index === 2) {
                    music.resumeAuto(index, previousPhase); // Pass current and previous phase
                } else {
                    music.pauseAuto(); // Pause (not stop)
                }

                ui.renderPhase();
                game.syncProjection();
            },

            // Returns true if match change was successful
            loadMatchByRelativeIndex: (offset) => {
                // Auto-Save Score of currently active match before switching
                if (state.activeMatchIndex !== -1 && !state.currentMatch.isEvent) {
                    const currentMatchInSched = state.schedule[state.activeMatchIndex];
                    if (currentMatchInSched && currentMatchInSched.type === 'match') {
                        currentMatchInSched.homeScore = state.currentMatch.homeScore;
                        currentMatchInSched.guestScore = state.currentMatch.guestScore;
                    }
                }

                let targetIndex = state.activeMatchIndex;
                if (targetIndex === -1) {
                    if (offset > 0) targetIndex = 0;
                } else {
                    targetIndex += offset;
                }

                if (targetIndex >= 0 && targetIndex < state.schedule.length) {
                    // Capture snapshot for PO delay only when moving to NEXT match
                    let snapshot = null;
                    if (offset > 0) {
                        snapshot = JSON.parse(JSON.stringify(state));
                    }

                    admin.loadMatch(targetIndex, false, snapshot);

                    // Check if we should change track when loading new match
                    if (state.musicAutoChangeStrategy === 'per-match' && state.musicAutoEnabled) {
                        music.startNewTrack();
                    }

                    if (offset < 0) {
                        game.setPhase(game.getPhaseCount() - 1, true);
                    } else {
                        game.setPhase(0, true);
                    }
                    return true;
                }
                return false;
            },

            getTelemetry: () => {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('cs-CZ');
                const dateStr = now.getFullYear() + '-' + (now.getMonth() + 1).toString().padStart(2, '0') + '-' + now.getDate().toString().padStart(2, '0');
                const fullTimeStr = `${dateStr}\u00A0\u00A0\u00A0\u00A0${timeStr}`;

                const currentIdx = state.activeMatchIndex;
                const totalItems = (state.schedule || []).length;
                const progressStr = `Pr√°vƒõ se hraje: ${currentIdx + 1} z ${totalItems}`;

                // Average "Planned" overhead per match (Setup + Break)
                const s = state.times.setup || 0;
                const b = state.times.break || 0;
                const p = state.times.play || 0;
                const plannedOverhead = s + b;

                let avgLag = 0;
                let learnedOverhead = 0;

                // Adjust based on real performance if tournament started
                if (state.tournamentStartTime && state.activeMatchIndex > 0) {
                    const realElapsed = (Date.now() - state.tournamentStartTime) / 1000;
                    const playElapsed = state.playTimeAccumulated || 0;
                    const totalOverhead = Math.max(0, realElapsed - playElapsed);
                    learnedOverhead = totalOverhead / state.activeMatchIndex;

                    // Lag is the delay compared to theoretical plan
                    avgLag = Math.max(0, learnedOverhead - plannedOverhead);

                    // Clamp to reasonable range (max 10 mins extra per match)
                    avgLag = Math.min(600, avgLag);
                }

                let remainingSeconds = state.timer.running
                    ? (state.timer.targetEndTime - Date.now()) / 1000
                    : state.timer.timeLeft;

                // Current item progress
                if (currentIdx !== -1 && state.schedule[currentIdx]) {
                    const m = state.schedule[currentIdx];
                    if (m.type === 'match') {
                        const curPhase = state.currentMatch.phaseIndex;
                        // Ph 0 (Setup): + P1, B, P2
                        if (curPhase === 0) remainingSeconds += (p * 2) + b + (avgLag * 0.8);
                        // Ph 1 (P1): + B, P2
                        else if (curPhase === 1) remainingSeconds += p + b + (avgLag * 0.5);
                        // Ph 2 (Break): + P2
                        else if (curPhase === 2) remainingSeconds += p + (avgLag * 0.2);
                        // Ph 3 (P2): already covered by timer
                    }
                }

                // Upcoming items
                (state.schedule || []).slice(currentIdx + 1).forEach(m => {
                    if (m.type === 'event') {
                        remainingSeconds += (m.duration || 600);
                        remainingSeconds += (avgLag * 0.5); // Add partial lag for events too
                    } else {
                        remainingSeconds += (p * 2) + plannedOverhead + avgLag;
                    }
                });

                const endTime = new Date(now.getTime() + remainingSeconds * 1000);
                const endStr = `P≈ôedpokl√°dan√Ω konec: ${endTime.toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' })}`;

                return {
                    progress: progressStr,
                    end: endStr,
                    time: fullTimeStr
                };
            },

            syncProjection: () => {
                // IMPORTANT: Prevent projection/public windows from broadcasting their (empty) state
                if (state.isProjectionMode || state.viewMode) {
                    console.log("syncProjection: Skipping broadcast (not in admin mode)");
                    return;
                }
                const payload = { ...state, telemetry: game.getTelemetry() };
                const plainPayload = JSON.parse(JSON.stringify(payload));

                // Send to BroadcastChannel for all listeners (OBS, other tabs)
                syncChannel.postMessage(plainPayload);

                // Legacy window.postMessage for the specific window opened via button
                if (projectionWindow && !projectionWindow.closed) {
                    projectionWindow.postMessage(plainPayload, '*');
                }

                // Send to Firebase (Cross-Device)
                if (typeof firebase !== 'undefined' && !state.isProjectionMode) {
                    try {
                        firebase.database().ref('sessions/' + state.sessionId).set(plainPayload);
                    } catch (e) {
                        console.error("Firebase write failed:", e);
                    }
                }

                ui.updateAdminFooter();
            },

            reorderSchedule: (fromIndex, toIndex) => {
                const item = state.schedule.splice(fromIndex, 1)[0];
                state.schedule.splice(toIndex, 0, item);

                // Adjust active match index if needed
                if (state.activeMatchIndex === fromIndex) {
                    state.activeMatchIndex = toIndex;
                } else if (state.activeMatchIndex > fromIndex && state.activeMatchIndex <= toIndex) {
                    state.activeMatchIndex--;
                } else if (state.activeMatchIndex < fromIndex && state.activeMatchIndex >= toIndex) {
                    state.activeMatchIndex++;
                }

                ui.renderSchedule();
                admin.saveToStorage(); game.syncProjection();
            },

            playSignal: () => {
                // P≈ôeru≈°it aktu√°lnƒõ hraj√≠c√≠ jingle, pokud nƒõjak√Ω hraje
                if (currentAnthemAudio) {
                    currentAnthemAudio.pause();
                    currentAnthemAudio = null;
                }

                // P≈ôeru≈°it hudbu na pozad√≠, pokud hraje
                if (!currentMusicAudio.paused) {
                    currentMusicAudio.pause();
                    clearInterval(music.fadeInterval);
                    music.fadeInterval = null;
                }

                if (state.audioData) {
                    try {
                        const snd = new Audio(state.audioData);
                        snd.volume = state.volSignal || 1.0;
                        snd.play().catch(e => console.error("Audio play failed:", e));
                    } catch (err) {
                        console.error("Invalid audio data", err);
                    }
                }
            }
        };


        // ===================================================================================
        // AUDIO MODUL (MUSIC & JINGLES)
        // ===================================================================================
        // Music Audio Events for Indicator stability
        musicAudioA.addEventListener('ended', () => {
            if (currentMusicAudio === musicAudioA) music.next();
        });
        musicAudioB.addEventListener('ended', () => {
            if (currentMusicAudio === musicAudioB) music.next();
        });

        // Update indicator when either audio plays/pauses
        musicAudioA.addEventListener('play', () => {
            if (currentMusicAudio === musicAudioA) ui.updateMusicIndicatorState();
        });
        musicAudioA.addEventListener('pause', () => {
            if (currentMusicAudio === musicAudioA) ui.updateMusicIndicatorState();
        });
        musicAudioB.addEventListener('play', () => {
            if (currentMusicAudio === musicAudioB) ui.updateMusicIndicatorState();
        });
        musicAudioB.addEventListener('pause', () => {
            if (currentMusicAudio === musicAudioB) ui.updateMusicIndicatorState();
        });

        const music = {
            fadeInterval: null,
            async openDB() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open("MusicDB", 1);
                    req.onupgradeneeded = () => req.result.createObjectStore("handles");
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            async saveHandle(handle) {
                const db = await music.openDB();
                const tx = db.transaction("handles", "readwrite");
                tx.objectStore("handles").put(handle, "lastDirectory");
            },
            async getHandle() {
                try {
                    const db = await music.openDB();
                    const tx = db.transaction("handles", "readonly");
                    const req = tx.objectStore("handles").get("lastDirectory");
                    return new Promise(resolve => {
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve(null);
                    });
                } catch (e) { return null; }
            },
            async pickDirectory() {
                try {
                    directoryHandle = await window.showDirectoryPicker();
                    await music.saveHandle(directoryHandle);
                    await music.listTracks();
                } catch (e) { console.warn("Picker error:", e); }
            },
            async listTracks() {
                if (!directoryHandle) return;
                state.musicPlaylist = [];
                try {
                    for await (const entry of directoryHandle.values()) {
                        if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.mp3')) {
                            state.musicPlaylist.push({ name: entry.name, handle: entry });
                        }
                    }
                    state.musicPlaylist.sort((a, b) => a.name.localeCompare(b.name));
                    ui.renderMusic();
                    const mc = document.getElementById('music-controls');
                    const mp = document.getElementById('music-mini-panel');
                    if (mc) mc.style.display = 'block';
                    if (mp) mp.style.display = 'flex';
                } catch (e) {
                    alert("Nutno znovu povolit p≈ô√≠stup ke slo≈æce s hudbou.");
                }
            },
            toggle() {
                if (currentMusicAudio.paused) {
                    if (currentMusicIndex === -1 && state.musicPlaylist.length > 0) {
                        music.play(0);
                    } else {
                        currentMusicAudio.play();
                        music.fadeIn();
                    }
                } else {
                    music.fadeOut();
                }
            },
            next() {
                if (state.musicPlaylist.length === 0) return;
                let targetIndex;
                if (state.musicMode === 'random') {
                    targetIndex = Math.floor(Math.random() * state.musicPlaylist.length);
                } else {
                    targetIndex = currentMusicIndex + 1;
                    if (targetIndex >= state.musicPlaylist.length) targetIndex = 0;
                }
                // Crossfade if music is playing and fade duration > 0
                if (!currentMusicAudio.paused && state.musicFadeDuration > 0) {
                    music.crossfadeTo(targetIndex);
                } else {
                    music.play(targetIndex);
                }
            },
            prev() {
                if (state.musicPlaylist.length === 0) return;
                let targetIndex;
                if (state.musicMode === 'random') {
                    targetIndex = Math.floor(Math.random() * state.musicPlaylist.length);
                } else {
                    targetIndex = currentMusicIndex - 1;
                    if (targetIndex < 0) targetIndex = state.musicPlaylist.length - 1;
                }
                // Crossfade if music is playing and fade duration > 0
                if (!currentMusicAudio.paused && state.musicFadeDuration > 0) {
                    music.crossfadeTo(targetIndex);
                } else {
                    music.play(targetIndex);
                }
            },
            setVolume(val) {
                state.volMusic = parseFloat(val);
                if (!music.fadeInterval && !music.crossfadeInterval) {
                    currentMusicAudio.volume = state.volMusic;
                }
                const disp = document.getElementById('vol-music-disp');
                if (disp) disp.innerText = Math.round(state.volMusic * 100);
                admin.saveToStorage(); game.syncProjection();
            },
            setAutoEnabled(val) {
                state.musicAutoEnabled = val;
                admin.saveToStorage(); game.syncProjection();
            },
            setMode(val) {
                state.musicMode = val;
                admin.saveToStorage(); game.syncProjection();
            },
            setFadeDuration(val) {
                state.musicFadeDuration = parseFloat(val);
                document.getElementById('fade-dur-disp').innerText = state.musicFadeDuration;
                admin.saveToStorage(); game.syncProjection();
            },
            setAutoChangeStrategy(val) {
                state.musicAutoChangeStrategy = val;
                admin.saveToStorage(); game.syncProjection();
            },
            fadeIn() {
                clearInterval(music.fadeInterval);
                if (state.musicFadeDuration === 0) {
                    currentMusicAudio.volume = state.volMusic;
                    return;
                }
                currentMusicAudio.volume = 0;
                const step = state.volMusic / (state.musicFadeDuration * 20);
                music.fadeInterval = setInterval(() => {
                    currentMusicAudio.volume = Math.min(state.volMusic, currentMusicAudio.volume + step);
                    if (currentMusicAudio.volume >= state.volMusic) {
                        clearInterval(music.fadeInterval);
                        music.fadeInterval = null;
                    }
                }, 50);
            },
            fadeOut() {
                clearInterval(music.fadeInterval);
                if (state.musicFadeDuration === 0) {
                    currentMusicAudio.pause();
                    return;
                }
                const step = currentMusicAudio.volume / (state.musicFadeDuration * 20);
                music.fadeInterval = setInterval(() => {
                    currentMusicAudio.volume = Math.max(0, currentMusicAudio.volume - step);
                    if (currentMusicAudio.volume <= 0) {
                        clearInterval(music.fadeInterval);
                        music.fadeInterval = null;
                        currentMusicAudio.pause();
                    }
                }, 50);
            },
            startAuto() {
                if (!state.musicAutoEnabled || state.musicPlaylist.length === 0) return;
                // Start a new track from beginning (only when first entering auto mode)
                if (state.musicMode === 'random') {
                    const idx = Math.floor(Math.random() * state.musicPlaylist.length);
                    music.play(idx, true);
                } else {
                    if (currentMusicIndex === -1) music.play(0, true);
                    else music.play(currentMusicIndex, true);
                }
            },
            resumeAuto(phaseIndex, previousPhase) {
                if (!state.musicAutoEnabled || state.musicPlaylist.length === 0) return;

                // Check if we should start a new track based on strategy
                const shouldStartNew = (
                    currentMusicIndex === -1 || // No track loaded
                    (state.musicAutoChangeStrategy === 'per-step' && (phaseIndex === 0 || phaseIndex === 2)) // New track per step
                );

                if (shouldStartNew) {
                    // Start new track only if not already playing or if strategy requires it
                    music.startNewTrack();
                } else if (currentMusicAudio.paused) {
                    // Resume from where it was paused
                    currentMusicAudio.play().then(() => {
                        music.fadeIn();
                    }).catch(e => console.warn("Resume failed, likely interupted:", e));
                }
            },
            startNewTrack() {
                // Start a new track (used by both auto strategies)
                if (state.musicMode === 'random') {
                    const idx = Math.floor(Math.random() * state.musicPlaylist.length);
                    music.play(idx, true);
                } else {
                    let nextIdx = currentMusicIndex + 1;
                    if (nextIdx >= state.musicPlaylist.length) nextIdx = 0;
                    music.play(nextIdx, true);
                }
            },
            pauseAuto() {
                if (!state.musicAutoEnabled) return;
                // Pause (not stop) - will resume from this position
                if (!currentMusicAudio.paused) {
                    music.fadeOut();
                }
            },
            stopAuto() {
                if (!state.musicAutoEnabled) return;
                music.fadeOut();
            },
            reorder(fromIndex, toIndex) {
                const item = state.musicPlaylist.splice(fromIndex, 1)[0];
                state.musicPlaylist.splice(toIndex, 0, item);
                state.musicPlaylistOrder = state.musicPlaylist.map(t => t.name);
                admin.saveToStorage(); game.syncProjection();
                ui.renderMusic();
            },
            crossfadeTo(index) {
                // True crossfade: both tracks play simultaneously
                clearInterval(music.crossfadeInterval);

                // Determine which audio element to use for the new track
                const oldAudio = currentMusicAudio;
                const newAudio = (currentMusicAudio === musicAudioA) ? musicAudioB : musicAudioA;

                // Load and start the new track
                music.loadTrack(newAudio, index).then(() => {
                    newAudio.volume = 0;
                    newAudio.play();

                    // Crossfade: old fades out, new fades in
                    const steps = state.musicFadeDuration * 20;
                    const oldStep = oldAudio.volume / steps;
                    const newStep = state.volMusic / steps;
                    let stepCount = 0;

                    music.crossfadeInterval = setInterval(() => {
                        stepCount++;
                        oldAudio.volume = Math.max(0, oldAudio.volume - oldStep);
                        newAudio.volume = Math.min(state.volMusic, newAudio.volume + newStep);

                        if (stepCount >= steps) {
                            clearInterval(music.crossfadeInterval);
                            music.crossfadeInterval = null;
                            oldAudio.pause();
                            oldAudio.volume = state.volMusic; // Reset for next use
                            currentMusicAudio = newAudio; // Switch active audio
                        }
                    }, 50);
                }).catch(e => {
                    console.error("Crossfade error:", e);
                });
            },
            async loadTrack(audioElement, index) {
                const track = state.musicPlaylist[index];
                const file = await track.handle.getFile();
                const url = URL.createObjectURL(file);
                audioElement.src = url;
                currentMusicIndex = index;
                document.getElementById('current-track-name').textContent = track.name;
                ui.renderMusic();
            },
            async play(index, isAuto = false) {
                if (index < 0 || index >= state.musicPlaylist.length) return;
                try {
                    await music.loadTrack(currentMusicAudio, index);

                    // CRITICAL: Double check if we are still in a musical phase after async load
                    // Musical phases are 0 (Nastupuje) and 2 (P≈ôest√°vka)
                    const pIdx = state.currentMatch.phaseIndex;
                    const isMusicalPhase = (pIdx === 0 || pIdx === 2);

                    if (isAuto && !isMusicalPhase) {
                        console.log("Music play cancelled: current phase is not musical", pIdx);
                        return;
                    }

                    if (isAuto || state.musicFadeDuration > 0) {
                        currentMusicAudio.volume = 0;
                        currentMusicAudio.play().then(() => {
                            music.fadeIn();
                        }).catch(e => console.warn("Auto play interupted:", e));
                    } else {
                        currentMusicAudio.volume = state.volMusic;
                        currentMusicAudio.play().catch(e => console.warn("Manual play failed:", e));
                    }
                } catch (e) {
                    console.error("Play error:", e);
                    if (!isAuto) alert("Chyba p≈ôi p≈ôehr√°v√°n√≠.");
                }
            }
        };

        const jingles = {
            async openDB() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open("JingleDB", 1);
                    req.onupgradeneeded = () => {
                        const db = req.result;
                        if (!db.objectStoreNames.contains("files")) {
                            db.createObjectStore("files", { keyPath: "name" });
                        }
                    };
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            async setMode(val) {
                state.jingleMode = val;
                admin.saveToStorage();
            },
            async handleUpload(input) {
                if (!input.files || input.files.length === 0) return;
                const db = await jingles.openDB();
                const tx = db.transaction("files", "readwrite");
                const store = tx.objectStore("files");

                let loaded = 0;
                for (const file of input.files) {
                    store.put({ name: file.name, data: file });
                    loaded++;
                }

                tx.oncomplete = () => {
                    jingles.list();
                    alert(`Nahr√°no ${loaded} jingl≈Ø.`);
                    input.value = "";
                };
            },
            async list() {
                try {
                    const db = await jingles.openDB();
                    const tx = db.transaction("files", "readonly");
                    const store = tx.objectStore("files");
                    const req = store.getAllKeys();

                    req.onsuccess = () => {
                        const keys = req.result;
                        state.jinglePool = keys;
                        const countEl = document.getElementById('jingle-pool-count');
                        if (countEl) countEl.innerText = `Poƒçet jingl≈Ø: ${keys.length}`;

                        const listEl = document.getElementById('jingle-pool-list');
                        if (listEl) {
                            listEl.innerHTML = keys.map(k => `<div style="padding:2px 0;">‚Ä¢ ${k}</div>`).join('');
                        }
                    };
                } catch (e) {
                    console.error("Jingle list error:", e);
                }
            },
            async clear() {
                if (!confirm("Opravdu chcete vymazat cel√Ω z√°sobn√≠k jingl≈Ø?")) return;
                const db = await jingles.openDB();
                const tx = db.transaction("files", "readwrite");
                tx.objectStore("files").clear();
                tx.oncomplete = () => {
                    jingles.list();
                };
            },
            async getRandomJingle() {
                if (state.jinglePool.length === 0) return null;
                const db = await jingles.openDB();
                const tx = db.transaction("files", "readonly");
                const store = tx.objectStore("files");
                const randomName = state.jinglePool[Math.floor(Math.random() * state.jinglePool.length)];

                return new Promise(resolve => {
                    const req = store.get(randomName);
                    req.onsuccess = () => resolve(req.result ? req.result.data : null);
                    req.onerror = () => resolve(null);
                });
            }
        };

        // ===================================================================================
        // ADMINISTRATIVA (ADMIN)
        // ===================================================================================
        // --- ADMIN HELPERS ---
        const admin = {
            saveSettings: (showAlert = true) => {
                if (state.isLoading) return;
                state.tournamentName = document.getElementById('input-tournament-name').value;
                state.tournamentCategory = document.getElementById('input-tournament-category').value;

                state.times.setup = Math.max(0, parseInt(document.getElementById('time-setup').value || 10));
                state.times.play = Math.max(0, parseInt(document.getElementById('time-play').value || 420));
                state.times.break = Math.max(0, parseInt(document.getElementById('time-break').value || 105));

                state.rules.winPoints = parseInt(document.getElementById('rule-win').value || 3);
                state.rules.drawPoints = parseInt(document.getElementById('rule-draw').value || 1);
                state.rules.lossPoints = parseInt(document.getElementById('rule-loss').value || 0);
                state.rules.useMiniTables = document.getElementById('rule-mini-tables').checked;

                // Save teams from dynamic list
                const teamInputs = document.querySelectorAll('.team-name-input');
                const newTeams = [];
                teamInputs.forEach(input => {
                    const id = input.dataset.id;
                    const name = input.value.trim();
                    if (id) {
                        // Find existing team to preserve playerIds etc.
                        const existing = state.teams.find(t => t.id === id);
                        newTeams.push({
                            ...existing,
                            id,
                            name: name || "Dru≈æstvo"
                        });
                    }
                });
                state.teams = newTeams;

                // Save referees from dynamic list
                state.referees = [];
                const refRows = document.querySelectorAll('.referee-identity-row');
                refRows.forEach(row => {
                    const id = row.dataset.id;
                    const surname = row.querySelector('.ref-surname-input').value.trim();
                    const firstName = row.querySelector('.ref-firstname-input').value.trim();
                    if (id) {
                        state.referees.push({
                            id,
                            surname: surname || "Rozhodƒç√≠",
                            firstName: firstName || ""
                        });
                    }
                });

                // Save misc entries
                const miscList = document.getElementById('misc-input-list');
                if (miscList) {
                    const miscInputs = miscList.querySelectorAll('.misc-name-input');
                    if (miscInputs.length > 0) {
                        state.misc = [];
                        miscInputs.forEach(input => {
                            const id = input.dataset.id;
                            const text = input.value.trim();
                            if (id) {
                                state.misc.push({ id, text: text || "" });
                            }
                        });
                    }
                }

                state.volSignal = parseFloat(document.getElementById('input-vol-signal').value);
                state.volAnthem = parseFloat(document.getElementById('input-vol-anthem').value);
                state.showFooter = document.getElementById('input-show-footer').checked;
                state.theme = document.getElementById('input-theme').value;
                state.cloudFileId = document.getElementById('input-cloud-file-id').value.trim();

                // Metadata
                state.tournamentDate = document.getElementById('input-tournament-date').value;
                state.tournamentLocation = document.getElementById('input-tournament-location').value;
                state.tournamentOrganizer = document.getElementById('input-tournament-organizer').value;
                state.pitchSize = document.getElementById('input-pitch-size').value;
                state.officialChiefReferee = {
                    surname: document.getElementById('official-chief-referee-surname').value.trim(),
                    firstName: document.getElementById('official-chief-referee-firstname').value.trim()
                };
                state.officialTimekeeper = {
                    surname: document.getElementById('official-timekeeper-surname').value.trim(),
                    firstName: document.getElementById('official-timekeeper-firstname').value.trim()
                };
                state.officialRecorder = {
                    surname: document.getElementById('official-recorder-surname').value.trim(),
                    firstName: document.getElementById('official-recorder-firstname').value.trim()
                };

                state.qrCyclingEnabled = document.getElementById('input-qr-cycling').checked;
                state.qrCyclingInterval = Math.max(5, parseInt(document.getElementById('input-qr-interval').value || 8));
                state.qrTransitionDuration = parseFloat(document.getElementById('input-qr-transition').value || 1.5);

                const fileInput = document.getElementById('input-audio-file');
                if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    if (file.size > 2 * 1024 * 1024) { // 2MB limit check
                        alert("Soubor je p≈ô√≠li≈° velk√Ω (>2MB). Zvolte men≈°√≠ MP3.");
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        state.audioData = e.target.result;
                        finishSave();
                    };
                    reader.readAsDataURL(file);
                } else {
                    finishSave();
                }

                function finishSave() {
                    admin.saveToStorage(); game.syncProjection();
                    ui.fillSelects();
                    ui.renderSchedule();
                    admin.renderIdentityInputs(); // Refresh labels
                    ui.updateFooterVisibility();

                    game.syncProjection();
                    if (showAlert) alert("Nastaven√≠ ulo≈æeno.");
                }
            },

            toggleRulesLock: () => {
                const unlocked = document.getElementById('rule-lock-toggle').checked;
                const container = document.getElementById('rules-container');
                const inputs = container.querySelectorAll('input');

                container.style.opacity = unlocked ? "1" : "0.6";
                container.style.pointerEvents = unlocked ? "auto" : "none";

                inputs.forEach(input => {
                    input.disabled = !unlocked;
                });
            },

            formatTime: (totalSeconds) => {
                if (isNaN(totalSeconds) || totalSeconds < 0) return "0:00";
                if (totalSeconds >= 3600) return "59:59";
                const m = Math.floor(totalSeconds / 60);
                const s = totalSeconds % 60;
                // User requirement: no leading zero for whole minutes (e.g. 7:00 instead of 07:00)
                // m.toString() naturally has no leading zero.
                return `${m}:${s.toString().padStart(2, '0')}`;
            },

            validateTimeInput: (input) => {
                // Ensure max 4 digits
                if (input.value.length > 4) {
                    input.value = input.value.slice(0, 4);
                }

                let val = parseInt(input.value);
                if (!isNaN(val)) {
                    // Force cap at 3599
                    if (val > 3599) {
                        input.value = 3599;
                    }
                }

                // Save and update UI
                admin.saveSettings(false);
                ui.render();
            },

            validateInputRange: (input, max) => {
                let val = parseInt(input.value);
                if (!isNaN(val)) {
                    if (val > max) input.value = max;
                }
                admin.saveSettings(false);
            },

            restrictToNumbers: (e) => {
                // Allow: backspace, delete, tab, escape, enter
                if ([46, 8, 9, 27, 13].indexOf(e.keyCode) !== -1 ||
                    // Allow: Ctrl+A,C,V,X
                    (e.ctrlKey === true && [65, 67, 86, 88].indexOf(e.keyCode) !== -1) ||
                    // Allow: home, end, left, right
                    (e.keyCode >= 35 && e.keyCode <= 39)) {
                    return true;
                }
                // Ensure that it is a number and stop the keypress
                if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
                    e.preventDefault();
                    return false;
                }
                return true;
            },

            sanitizeInput: (input) => {
                let val = input.value;
                if (val.match(/[<>]/)) {
                    input.value = val.replace(/[<>]/g, '');
                }
            },

            renderIdentityInputs: () => {
                // Teams
                const teamList = document.getElementById('teams-input-list');
                teamList.innerHTML = "";
                state.teams.forEach((team, idx) => {
                    admin.renderIdentityRow(teamList, team, idx, 'team');
                });

                // Referees
                const refList = document.getElementById('referees-input-list');
                refList.innerHTML = "";
                state.referees.forEach((ref, idx) => {
                    admin.renderIdentityRow(refList, ref, idx, 'referee');
                });

                // Players
                const playerList = document.getElementById('players-input-list');
                if (playerList) {
                    playerList.innerHTML = "";
                    state.players.forEach((player, idx) => {
                        admin.renderPlayerRow(playerList, player, idx);
                    });
                }

                // Miscellaneous Notes
                const miscList = document.getElementById('misc-input-list');
                if (miscList) {
                    miscList.innerHTML = "";
                    state.misc.forEach((item, idx) => {
                        admin.renderMiscRow(miscList, item, idx);
                    });
                }
            },

            updateSettingsUI: () => {
                const setVal = (id, val) => {
                    const el = document.getElementById(id);
                    if (el) {
                        if (el.type === 'checkbox') el.checked = !!val;
                        else el.value = val;
                    }
                };

                setVal('input-tournament-name', state.tournamentName);
                setVal('input-tournament-category', state.tournamentCategory);
                setVal('time-setup', state.times.setup);
                setVal('time-play', state.times.play);
                setVal('time-break', state.times.break);
                setVal('rule-win', state.rules.winPoints);
                setVal('rule-draw', state.rules.drawPoints);
                setVal('rule-loss', state.rules.lossPoints);
                setVal('rule-mini-tables', state.rules.useMiniTables);
                setVal('input-vol-signal', state.volSignal);
                setVal('input-vol-anthem', state.volAnthem);
                setVal('input-show-footer', state.showFooter);
                setVal('input-theme', state.theme);
                setVal('input-cloud-file-id', state.cloudFileId);
                setVal('input-tournament-date', state.tournamentDate);
                setVal('input-tournament-location', state.tournamentLocation);
                setVal('input-tournament-organizer', state.tournamentOrganizer);
                setVal('input-pitch-size', state.pitchSize);
                // Official Officials
                setVal('official-chief-referee-surname', state.officialChiefReferee?.surname || "");
                setVal('official-chief-referee-firstname', state.officialChiefReferee?.firstName || "");
                setVal('official-timekeeper-surname', state.officialTimekeeper?.surname || "");
                setVal('official-timekeeper-firstname', state.officialTimekeeper?.firstName || "");
                setVal('official-recorder-surname', state.officialRecorder?.surname || "");
                setVal('official-recorder-firstname', state.officialRecorder?.firstName || "");
                setVal('input-qr-cycling', state.qrCyclingEnabled);
                setVal('input-qr-interval', state.qrCyclingInterval);
                setVal('input-qr-transition', state.qrTransitionDuration);
            },

            renderMiscRow: (container, item, index) => {
                const div = document.createElement('div');
                div.style.display = "flex";
                div.style.gap = "5px";
                div.style.alignItems = "center";
                div.style.marginBottom = "5px";

                const label = document.createElement('span');
                label.style.width = "60px";
                label.style.fontSize = "0.8em";
                label.style.color = "#888";
                label.innerText = "Pozn. " + (index + 1);

                const input = document.createElement('input');
                input.type = "text";
                input.className = "misc-name-input";
                input.dataset.id = item.id;
                input.value = item.text || "";
                input.placeholder = "Dopl≈àuj√≠c√≠ info...";
                input.maxLength = 256;
                input.style.flex = "1";
                input.oninput = () => {
                    admin.sanitizeInput(input);
                    state.misc.find(m => m.id === item.id).text = input.value;
                    admin.saveToStorage(); game.syncProjection();
                };

                const removeBtn = document.createElement('button');
                removeBtn.className = "small-btn btn-red";
                removeBtn.innerText = "x";
                removeBtn.onclick = () => {
                    state.misc = state.misc.filter(m => m.id !== item.id);
                    admin.renderIdentityInputs();
                    admin.saveToStorage(); game.syncProjection();
                };

                div.appendChild(label);
                div.appendChild(input);
                div.appendChild(removeBtn);
                container.appendChild(div);
            },

            renderPlayerRow: (container, item, index) => {
                const div = document.createElement('div');
                div.className = "player-input-row";
                div.style.display = "flex";
                div.style.gap = "5px";
                div.style.alignItems = "center";
                div.style.marginBottom = "8px";
                div.style.padding = "8px";
                div.style.background = "#333";
                div.style.borderRadius = "4px";

                const label = document.createElement('span');
                label.style.width = "40px";
                label.style.fontSize = "0.7em";
                label.style.color = "#888";
                label.innerText = "#" + (index + 1);

                // Surname
                const surnameWrapper = document.createElement('div');
                surnameWrapper.className = "suggestion-container";
                surnameWrapper.style.flex = "2";
                surnameWrapper.style.position = "relative";

                const surnameInput = document.createElement('input');
                surnameInput.type = "text";
                surnameInput.placeholder = "P≈ô√≠jmen√≠";
                surnameInput.value = item.surname || "";
                surnameInput.maxLength = 32;
                surnameInput.style.width = "100%";

                const sSugBox = document.createElement('div');
                sSugBox.className = "suggestion-box";
                sSugBox.style.display = "none";
                sSugBox.style.width = "240px";
                sSugBox.style.zIndex = "1100";

                surnameInput.oninput = () => {
                    admin.sanitizeInput(surnameInput);
                    item.surname = surnameInput.value;
                    const mp = state.masterPlayers.find(p => p.id === item.id);
                    if (mp) mp.surname = item.surname;
                    admin.showPlayerSuggestions(surnameInput, sSugBox, { context: 'players-list', playerRowItem: item, surnameInput });
                    admin.saveToStorage(); game.syncProjection();
                };
                surnameInput.onblur = () => setTimeout(() => { sSugBox.style.display = 'none'; }, 200);

                surnameWrapper.appendChild(surnameInput);
                surnameWrapper.appendChild(sSugBox);

                // Name
                const nameWrapper = document.createElement('div');
                nameWrapper.className = "suggestion-container";
                nameWrapper.style.flex = "2";
                nameWrapper.style.position = "relative";

                const nameInput = document.createElement('input');
                nameInput.type = "text";
                nameInput.placeholder = "Jm√©no";
                nameInput.value = item.firstName || "";
                nameInput.maxLength = 32;
                nameInput.style.width = "100%";

                const nSugBox = document.createElement('div');
                nSugBox.className = "suggestion-box";
                nSugBox.style.display = "none";
                nSugBox.style.width = "240px";
                nSugBox.style.left = "0";
                nSugBox.style.zIndex = "1100";

                nameInput.oninput = () => {
                    admin.sanitizeInput(nameInput);
                    item.firstName = nameInput.value;
                    const mp = state.masterPlayers.find(p => p.id === item.id);
                    if (mp) mp.firstName = item.firstName;
                    admin.showPlayerSuggestions(nameInput, nSugBox, { context: 'players-list', playerRowItem: item, nameInput });
                    admin.saveToStorage(); game.syncProjection();
                };
                nameInput.onblur = () => setTimeout(() => { nSugBox.style.display = 'none'; }, 200);

                nameWrapper.appendChild(nameInput);
                nameWrapper.appendChild(nSugBox);

                // UCI-ID
                const uciInput = document.createElement('input');
                uciInput.type = "text";
                uciInput.placeholder = "UCI-ID";
                uciInput.value = item.uciId || "";
                uciInput.style.flex = "3";
                uciInput.maxLength = 11;
                uciInput.oninput = () => {
                    admin.sanitizeInput(uciInput);
                    const newVal = uciInput.value.trim();
                    // Basic validation: check if UCI-ID is already taken by ANOTHER player
                    if (newVal && state.players.some(p => p.uciId === newVal && p.id !== item.id)) {
                        uciInput.style.border = "1px solid red";
                    } else {
                        uciInput.style.border = "";
                        item.uciId = newVal;
                        const mp = state.masterPlayers.find(p => p.id === item.id);
                        if (mp) mp.uciId = item.uciId;
                        // If UCI-ID is set, we could potentially use it as ID, 
                        // but it's safer to keep the persistent internal ID for references 
                        // and just use UCI-ID for reconciling during import/export.
                        admin.saveToStorage(); game.syncProjection();
                    }
                };

                const removeBtn = document.createElement('button');
                removeBtn.className = "small-btn btn-red";
                removeBtn.innerText = "x";
                removeBtn.onclick = () => {
                    state.players = state.players.filter(p => p.id !== item.id);
                    admin.renderIdentityInputs();
                    admin.saveToStorage(); game.syncProjection();
                };

                div.appendChild(label);
                div.appendChild(surnameWrapper);
                div.appendChild(nameWrapper);
                div.appendChild(uciInput);
                div.appendChild(removeBtn);
                container.appendChild(div);
            },

            renderIdentityRow: (container, item, index, type) => {
                const div = document.createElement('div');
                div.className = "identity-row " + (type === 'referee' ? "referee-identity-row" : "team-identity-row");
                div.dataset.id = item.id;

                const label = document.createElement('span');
                label.className = "identity-label";
                label.innerText = (type === 'team' ? "Dru≈æstvo " : "Rozhodƒç√≠ ") + (index + 1);
                div.appendChild(label);

                if (type === 'team') {
                    const input = document.createElement('input');
                    input.type = "text";
                    input.className = "team-name-input";
                    input.dataset.id = item.id;
                    input.value = item.name || "";
                    input.maxLength = 32;
                    input.style.flex = "1";
                    input.oninput = () => {
                        admin.sanitizeInput(input);
                        item.name = input.value;
                        admin.renderLogoSettings();
                        ui.updateNames();
                        ui.fillSelects();
                        ui.renderSchedule();
                        admin.saveToStorage(); game.syncProjection();
                    };
                    div.appendChild(input);
                } else {
                    // Referee
                    const sInput = document.createElement('input');
                    sInput.type = "text";
                    sInput.className = "ref-surname-input";
                    sInput.placeholder = "P≈ô√≠jmen√≠";
                    sInput.value = item.surname || "";
                    sInput.style.flex = "1.2";
                    sInput.oninput = () => {
                        admin.sanitizeInput(sInput);
                        item.surname = sInput.value;
                        ui.fillSelects();
                        admin.saveToStorage(); game.syncProjection();
                    };
                    const nInput = document.createElement('input');
                    nInput.type = "text";
                    nInput.className = "ref-firstname-input";
                    nInput.placeholder = "Jm√©no";
                    nInput.value = item.firstName || "";
                    nInput.style.flex = "1";
                    nInput.oninput = () => {
                        admin.sanitizeInput(nInput);
                        item.firstName = nInput.value;
                        ui.fillSelects();
                        admin.saveToStorage(); game.syncProjection();
                    };
                    div.appendChild(sInput);
                    div.appendChild(nInput);
                }

                const removeBtn = document.createElement('button');
                removeBtn.className = "small-btn btn-red";
                removeBtn.innerText = "x";
                removeBtn.onclick = () => {
                    if (type === 'team') {
                        // Check if team is used in schedule
                        const isUsed = state.schedule.some(m => m.type === 'match' && (m.home === item.id || m.guest === item.id));
                        if (isUsed) {
                            if (!confirm(`Dru≈æstvo "${item.name}" je nasazeno v z√°pasech. Opravdu ho chcete smazat? Z√°pasy z≈Østanou, ale jm√©no se ztrat√≠.`)) {
                                return;
                            }
                        }
                        state.teams = state.teams.filter(t => t.id !== item.id);
                    } else {
                        state.referees = state.referees.filter(r => r.id !== item.id);
                    }
                    admin.renderIdentityInputs();
                    admin.renderLogoSettings();
                    admin.saveToStorage(); game.syncProjection(); // Auto-save on removal
                };

                if (type === 'team') {
                    // Player selection UI
                    const playerSection = document.createElement('div');
                    playerSection.style.display = "flex";
                    playerSection.style.flexDirection = "column";
                    playerSection.style.flex = "1.5";
                    playerSection.style.marginLeft = "10px";

                    const chipsContainer = document.createElement('div');
                    chipsContainer.className = "chips-container";
                    chipsContainer.style.display = "flex";
                    chipsContainer.style.flexWrap = "wrap";

                    const suggestWrapper = document.createElement('div');
                    suggestWrapper.className = "suggestion-container";

                    const playerInput = document.createElement('input');
                    playerInput.type = "text";
                    playerInput.placeholder = "Hledat v soupisce..."; // More accurate placeholder
                    playerInput.style.fontSize = "0.75em";
                    playerInput.style.padding = "4px 8px";

                    const suggestionBox = document.createElement('div');
                    suggestionBox.className = "suggestion-box";
                    suggestionBox.style.display = "none";

                    playerInput.oninput = () => {
                        admin.sanitizeInput(playerInput);
                        admin.showPlayerSuggestions(playerInput, suggestionBox, {
                            context: 'team-assign',
                            team: item,
                            chipsContainer: chipsContainer
                        });
                    };
                    playerInput.onblur = () => setTimeout(() => { suggestionBox.style.display = 'none'; }, 200);

                    suggestWrapper.appendChild(playerInput);
                    suggestWrapper.appendChild(suggestionBox);

                    // Auto-heal: Filter out IDs of players that no longer exist in the tournament list
                    if (!item.playerIds) item.playerIds = [];
                    item.playerIds = item.playerIds.filter(pid => state.players.some(p => p.id === pid));

                    // Set visibility based on valid player count
                    suggestWrapper.style.display = (item.playerIds.length >= 2) ? "none" : "block";

                    admin.renderPlayerChips(chipsContainer, item);

                    playerSection.appendChild(chipsContainer);
                    playerSection.appendChild(suggestWrapper);
                    div.appendChild(playerSection);
                }

                div.appendChild(removeBtn);
                container.appendChild(div);
            },

            renderPlayerChips: (container, team) => {
                container.innerHTML = "";
                if (!team.playerIds) team.playerIds = [];
                team.playerIds.forEach(pid => {
                    const player = state.players.find(p => p.id === pid);
                    if (player) {
                        const chip = document.createElement('div');
                        chip.className = "player-chip";
                        chip.innerText = (player.surname || player.firstName || "Hr√°ƒç");
                        const remove = document.createElement('span');
                        remove.className = "remove-chip";
                        remove.innerText = "√ó";
                        remove.onclick = (e) => {
                            e.stopPropagation();
                            team.playerIds = team.playerIds.filter(id => id !== pid);
                            admin.renderIdentityInputs(); // Force full re-render
                            admin.saveToStorage(); game.syncProjection();
                        };
                        chip.appendChild(remove);
                        container.appendChild(chip);
                    }
                });
                // REMOVED: Side-effect visibility toggling. Handled in renderIdentityRow.
            },

            showPlayerSuggestions: (input, suggestionBox, contextData) => {
                const val = input.value.trim().toLowerCase();
                suggestionBox.innerHTML = "";
                if (!val) {
                    suggestionBox.style.display = "none";
                    return;
                }

                const { context, team, chipsContainer, playerRowItem, surnameInput, nameInput } = contextData;
                let matches = [];

                if (context === 'team-assign') {
                    // Search strictly in tournament players
                    matches = state.players.filter(p =>
                        (p.surname + " " + p.firstName + " " + (p.uciId || "")).toLowerCase().includes(val) &&
                        !(team.playerIds || []).includes(p.id)
                    ).slice(0, 5);
                } else if (context === 'players-list') {
                    // Search in Global Master DB
                    matches = state.masterPlayers.filter(p =>
                        (p.surname + " " + p.firstName + " " + (p.uciId || "")).toLowerCase().includes(val)
                    ).slice(0, 5);
                }

                matches.forEach(p => {
                    const item = document.createElement('div');
                    item.className = "suggestion-item";
                    item.innerText = `${p.surname} ${p.firstName} ${p.uciId ? `(${p.uciId})` : ""}`;
                    item.onclick = () => {
                        if (context === 'team-assign') {
                            if (!team.playerIds) team.playerIds = [];
                            if (team.playerIds.length < 2) {
                                team.playerIds.push(p.id);
                                input.value = "";
                                suggestionBox.style.display = "none";
                                admin.renderIdentityInputs();
                                admin.saveToStorage(); game.syncProjection();
                            } else {
                                alert("Dru≈æstvo m≈Ø≈æe m√≠t maxim√°lnƒõ 2 hr√°ƒçe.");
                            }
                        } else if (context === 'players-list') {
                            const oldId = playerRowItem.id;

                            // Fill the row in tournament list with suggested data
                            playerRowItem.id = p.id;
                            playerRowItem.surname = p.surname;
                            playerRowItem.firstName = p.firstName;
                            playerRowItem.uciId = p.uciId;

                            // If we swapped ID, we need to remove the "ghost" entry with the old ID
                            // from the tournament list (it was either empty or a partially typed name)
                            if (oldId !== p.id) {
                                state.players = state.players.filter(tp => tp.id !== oldId);
                                // Note: we keep the oldId in masterPlayers just in case the user 
                                // was editing an existing master player, but in state.players 
                                // we only want one entry for this row.
                            }

                            input.value = (surnameInput ? p.surname : p.firstName);
                            if (surnameInput && nameInput) {
                                surnameInput.value = p.surname;
                                nameInput.value = p.firstName;
                            }
                            suggestionBox.style.display = "none";
                            admin.renderIdentityInputs();
                            admin.saveToStorage();
                        }
                    };
                    suggestionBox.appendChild(item);
                });

                suggestionBox.style.display = "block";
            },

            getTeamName: (id) => {
                const team = state.teams.find(t => t.id === id);
                return team ? team.name : (id ? "XXX" : "T√Ωm");
            },

            getRefName: (inp, full = false) => {
                if (!inp) return "-";
                let ref = null;
                if (typeof inp === 'string') {
                    ref = state.referees.find(r => r.id === inp);
                    if (!ref) return inp;
                } else if (typeof inp === 'object') {
                    ref = inp;
                } else return "-";

                if (full) {
                    if (ref.surname || ref.firstName) {
                        return `${ref.surname || ""} ${ref.firstName || ""}`.trim() || "-";
                    }
                    return ref.name || "-";
                } else {
                    // UI view: Surname only (or fallback to shared name)
                    return ref.surname || ref.name || "-";
                }
            },

            getTeamPlayers: (teamId) => {
                const team = state.teams.find(t => t.id === teamId);
                if (!team || !team.playerIds || team.playerIds.length === 0) return "";
                return team.playerIds.map(pid => {
                    const p = state.players.find(x => x.id === pid);
                    return p ? `${p.surname} ${p.firstName[0]}.` : "";
                }).filter(n => n).join(", ");
            },

            addTeamSlot: () => {
                const id = "team_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                state.teams.push({ id, name: "", playerIds: [] });
                admin.renderIdentityInputs();
                admin.saveToStorage(); game.syncProjection();
            },

            addRefereeSlot: () => {
                const id = "ref_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                state.referees.push({ id, surname: "", firstName: "" });
                admin.renderIdentityInputs();
                admin.saveToStorage(); game.syncProjection();
            },

            addMiscSlot: () => {
                const id = "misc_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                state.misc.push({ id, text: "" });
                admin.renderIdentityInputs();
                admin.saveToStorage(); game.syncProjection();
            },

            addPlayerSlot: () => {
                const id = "player_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                const newPlayer = { id, surname: "", firstName: "", uciId: "" };
                state.players.push({ ...newPlayer });
                state.masterPlayers.push({ ...newPlayer });
                admin.renderIdentityInputs();
                admin.saveSettings(false);
            },

            // SHA-256 Hash with fallback for non-secure contexts (local file://)
            _hash: async (text) => {
                try {
                    if (window.crypto && crypto.subtle) {
                        const msgUint8 = new TextEncoder().encode(text);
                        const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                    }
                } catch (e) { console.warn("Crypto API failed, using fallback."); }

                // Fallback: Simple deterministic "hash" for deterrent purposes 
                // ONLY used when modern Crypto API is unavailable (e.g. local file)
                let h = 0;
                for (let i = 0; i < text.length; i++) {
                    h = ((h << 5) - h) + text.charCodeAt(i);
                    h |= 0;
                }
                return "fallback_" + Math.abs(h).toString(16);
            },

            openQRWindow: () => {
                const url = window.location.origin + window.location.pathname + '?projection&mode=qr&session=' + state.sessionId;
                qrWindow = window.open(url, 'sb_qr_' + state.sessionId, 'width=600,height=800');
            },

            // BAKED-IN PASSWORD HASHES
            _targetHash: "39a2c54c5bdaad1c10d81f97243bc7c4c90dbb1ed7c6526886dc243259dd0310",
            _fallbackHash: "fallback_5076cf47", // "KolovaOlomouc1962"

            // Reusable admin verification
            verifyAdminPassword: async () => {
                const pass = prompt("Zadejte administraƒçn√≠ heslo:");
                if (!pass) return false;
                const hashed = await admin._hash(pass);
                if (hashed === admin._targetHash || hashed === admin._fallbackHash) return true;
                alert("≈†patn√© heslo. P≈ô√≠stup odep≈ôen.");
                return false;
            },

            exportPlayersWithPassword: async () => {
                if (await admin.verifyAdminPassword()) {
                    admin.exportPlayers();
                }
            },

            unlockCloudID: async () => {
                if (await admin.verifyAdminPassword()) {
                    const input = document.getElementById('input-cloud-file-id');
                    const btn = document.getElementById('btn-unlock-cloud-id');
                    input.disabled = false;
                    input.style.webkitTextSecurity = 'none'; // Reveal the ID
                    input.style.opacity = '1';
                    input.style.cursor = 'text';
                    input.focus();
                    btn.style.display = 'none';
                }
            },

            updatePlayersFromCloud: async () => {
                let fileId = state.cloudFileId;
                if (!fileId) {
                    alert("Chyb√≠ Google Drive File ID v nastaven√≠ aplikace.");
                    toggleAccordion('acc-app-settings');
                    return;
                }

                // If user pasted a full URL, try to extract the ID
                if (fileId.includes("drive.google.com")) {
                    const match = fileId.match(/\/d\/([a-zA-Z0-9_-]+)/) || fileId.match(/[?&]id=([a-zA-Z0-9_-]+)/);
                    if (match && match[1]) {
                        fileId = match[1];
                        console.log("Extrahov√°no ID z URL:", fileId);
                    }
                }

                const btn = document.querySelector('button[onclick="admin.updatePlayersFromCloud()"]');
                const originalText = btn.innerText;
                btn.innerText = "‚è≥ Stahov√°n√≠...";
                btn.disabled = true;

                try {
                    // 1. Prepare clean file ID
                    const cleanFileId = fileId.trim();

                    // 2. Define methods to try (Direct -> AllOrigins -> CORSProxy)
                    // Note: 'https://drive.google.com/uc?export=download&id=' is the standard export URL
                    const exportUrl = `https://drive.google.com/uc?export=download&id=${cleanFileId}`;

                    const methods = [
                        // Method 1: Direct fetch (works if same-origin or CORS headers allow - rare for Drive)
                        exportUrl,
                        // Method 2: AllOrigins Proxy (reliable free proxy)
                        `https://api.allorigins.win/raw?url=${encodeURIComponent(exportUrl)}`,
                        // Method 3: CORSProxy.io (another reliable proxy)
                        `https://corsproxy.io/?${encodeURIComponent(exportUrl)}`,
                        // Method 4: Fallback alternate Drive URL (sometimes works differently)
                        `https://drive.usercontent.google.com/download?id=${cleanFileId}&export=download`
                    ];

                    let lastError = null;
                    let imported = null;

                    for (let i = 0; i < methods.length; i++) {
                        const url = methods[i];
                        try {
                            console.log(`Cloud Sync: Zkou≈°√≠m metodu ${i + 1}/${methods.length}...`);
                            const resp = await fetch(url);

                            if (!resp.ok) {
                                // If 403/401, it's definitely a permission issue
                                if (resp.status === 403 || resp.status === 401) {
                                    throw new Error(`P≈ô√≠stup odep≈ôen (HTTP ${resp.status}). Je soubor sd√≠len√Ω pro "Ka≈æd√Ω s odkazem"?`);
                                }
                                throw new Error(`HTTP ${resp.status}`);
                            }

                            const text = await resp.text();

                            // Google Drive sometimes returns an HTML login page instead of the file
                            if (text.trim().startsWith('<!DOCTYPE html') || text.trim().startsWith('<html')) {
                                throw new Error("Sta≈æen HTML nam√≠sto JSON. (Pravdƒõpodobnƒõ vy≈æaduje p≈ôihl√°≈°en√≠ - zkontrolujte sd√≠len√≠).");
                            }

                            try {
                                const rawData = JSON.parse(text);
                                if (!Array.isArray(rawData)) throw new Error("Sta≈æen√Ω JSON nen√≠ pole hr√°ƒç≈Ø.");

                                // VALIDATION & SANITIZATION
                                imported = rawData.map(item => {
                                    // 1. Structure check - must be object
                                    if (typeof item !== 'object' || item === null) return null;

                                    // 2. Extract and Sanitize known fields only
                                    // Helper to strip dangerous chars/tags
                                    const sanitize = (str) => {
                                        if (typeof str !== 'string') return "";
                                        return str.replace(/[<>]/g, "").trim().substring(0, 100);
                                    };

                                    return {
                                        id: sanitize(item.id) || ("player_" + Math.random().toString(36).substr(2, 9)),
                                        firstName: sanitize(item.firstName),
                                        surname: sanitize(item.surname),
                                        uciId: sanitize(item.uciId)
                                    };
                                }).filter(item => {
                                    // 3. Filter valid items: must have at least surname
                                    return item && item.surname.length > 0;
                                });

                                if (imported.length === 0) throw new Error("JSON neobsahuje ≈æ√°dn√© platn√© z√°znamy o hr√°ƒç√≠ch.");

                            } catch (e) {
                                throw new Error("Chyba p≈ôi zpracov√°n√≠ JSON: " + e.message);
                            }

                            console.log("‚úì Cloud Sync: √öspƒõch metodou", i + 1);
                            break;
                        } catch (err) {
                            lastError = err;
                            console.warn(`‚úó Cloud Sync: Metoda ${i + 1} selhala:`, err.message);
                        }
                    }

                    if (!imported) {
                        // Construct a helpful error message
                        let msg = "V≈°echny pokusy o sta≈æen√≠ selhaly.\n\n";
                        if (lastError?.message.includes("HTML") || lastError?.message.includes("P≈ô√≠stup odep≈ôen")) {
                            msg += "D≈ÆVOD: Soubor pravdƒõpodobnƒõ nen√≠ ve≈ôejnƒõ sd√≠len√Ω.\n";
                            msg += "≈òE≈†EN√ç: Na Google Disku nastavte sd√≠len√≠ na 'Ka≈æd√Ω s odkazem m√° p≈ô√≠stup' (Anyone with the link).";
                        } else {
                            msg += `POSLEDN√ç CHYBA: ${lastError?.message}\n`;
                            msg += "ZKONTROLUJTE: Je File ID spr√°vn√©? M√°te p≈ôipojen√≠ k internetu?";
                        }
                        throw new Error(msg);
                    }

                    // Reuse the existing conflict logic
                    admin.importPlayersData(imported);

                } catch (err) {
                    alert("Chyba p≈ôi aktualizaci z cloudu: " + err.message);
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            },

            // Helper to handle data without File object
            importPlayersData: (imported) => {
                const conflicts = [];
                const newEntries = [];

                imported.forEach(pImp => {
                    const byUci = pImp.uciId ? state.masterPlayers.find(p => p.uciId === pImp.uciId) : null;
                    const byName = state.masterPlayers.find(p =>
                        p.surname?.toLowerCase() === pImp.surname?.toLowerCase() &&
                        p.firstName?.toLowerCase() === pImp.firstName?.toLowerCase()
                    );

                    const existing = byUci || byName;
                    if (existing) {
                        // Check if it's an exact match (ignoring ID differences)
                        const isExactMatch =
                            existing.surname?.toLowerCase() === pImp.surname?.toLowerCase() &&
                            existing.firstName?.toLowerCase() === pImp.firstName?.toLowerCase() &&
                            (existing.uciId || "") === (pImp.uciId || "");

                        if (!isExactMatch) {
                            conflicts.push({
                                imported: pImp,
                                existing: existing,
                                type: byUci ? 'uci' : 'name',
                                choice: 'keep'
                            });
                        }
                    } else {
                        newEntries.push(pImp);
                    }
                });

                if (conflicts.length > 0) {
                    admin.showConflictReview(conflicts, newEntries);
                } else {
                    newEntries.forEach(p => {
                        if (!p.id) p.id = "player_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                        state.masterPlayers.push(p);
                    });
                    admin.saveToStorage();
                    alert(`Importov√°no ${newEntries.length} nov√Ωch hr√°ƒç≈Ø do hlavn√≠ datab√°ze.`);
                }
            },

            exportPlayers: () => {
                if (state.players.length === 0) {
                    alert("Seznam hr√°ƒç≈Ø je pr√°zdn√Ω.");
                    return;
                }
                const dataStr = JSON.stringify(state.players, null, 2);
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.href = url;
                link.download = `CycleBall_UCI-ID.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            },

            importPlayers: (input) => {
                const file = input.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (!Array.isArray(imported)) throw new Error("Neplatn√Ω form√°t dat.");

                        const conflicts = [];
                        const newEntries = [];

                        imported.forEach(pImp => {
                            // Find conflicts by UCI or Name
                            const byUci = pImp.uciId ? state.players.find(p => p.uciId === pImp.uciId) : null;
                            const byName = state.players.find(p =>
                                p.surname?.toLowerCase() === pImp.surname?.toLowerCase() &&
                                p.firstName?.toLowerCase() === pImp.firstName?.toLowerCase()
                            );

                            const existing = byUci || byName;
                            if (existing) {
                                // Ignore exact matches
                                const isExactMatch =
                                    existing.surname?.toLowerCase() === pImp.surname?.toLowerCase() &&
                                    existing.firstName?.toLowerCase() === pImp.firstName?.toLowerCase() &&
                                    (existing.uciId || "") === (pImp.uciId || "");

                                if (!isExactMatch) {
                                    conflicts.push({
                                        imported: pImp,
                                        existing: existing,
                                        type: byUci ? 'uci' : 'name',
                                        choice: 'keep'
                                    });
                                }
                            } else {
                                newEntries.push(pImp);
                            }
                        });

                        if (conflicts.length > 0) {
                            admin.showConflictReview(conflicts, newEntries);
                        } else {
                            // No conflicts, just merge to master
                            newEntries.forEach(p => {
                                if (!p.id) p.id = "player_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                                state.masterPlayers.push(p);
                            });
                            admin.saveToStorage();
                            alert(`Importov√°no ${newEntries.length} nov√Ωch hr√°ƒç≈Ø do hlavn√≠ datab√°ze.`);
                        }
                    } catch (err) {
                        alert("Chyba p≈ôi importu: " + err.message);
                    }
                    input.value = "";
                };
                reader.readAsText(file);
            },

            showConflictReview: (conflicts, newEntries) => {
                const modal = document.getElementById('modal-player-conflicts');
                const container = document.getElementById('conflict-list-container');
                container.innerHTML = "";
                modal.style.display = 'flex';

                conflicts.forEach((conf, idx) => {
                    const row = document.createElement('div');
                    row.className = "conflict-row";

                    const headerTxt = conf.type === 'uci' ? `Shoda v UCI-ID: ${conf.imported.uciId}` : `Shoda ve jm√©nƒõ: ${conf.imported.surname} ${conf.imported.firstName}`;

                    row.innerHTML = `
                        <div class="conflict-header">${headerTxt}</div>
                        <div class="conflict-grid">
                            <div class="conflict-cell">
                                <span class="conflict-label">St√°vaj√≠c√≠ v hlavn√≠ DB</span>
                                <div class="conflict-value">${conf.existing.surname} ${conf.existing.firstName}</div>
                                <div class="conflict-value" style="font-size:0.8em; color:#888;">UCI: ${conf.existing.uciId || "-"}</div>
                            </div>
                            <div class="conflict-cell" style="border-left:1px solid #333;">
                                <span class="conflict-label">V importu (Cloud/Soubor)</span>
                                <div class="conflict-value ${conf.existing.surname !== conf.imported.surname || conf.existing.firstName !== conf.imported.firstName ? 'val-diff' : ''}">
                                    ${conf.imported.surname} ${conf.imported.firstName}
                                </div>
                                <div class="conflict-value ${conf.existing.uciId !== conf.imported.uciId ? 'val-diff' : ''}" style="font-size:0.8em;">
                                    UCI: ${conf.imported.uciId || "-"}
                                </div>
                            </div>
                        </div>
                        <div class="conflict-choice" id="choice-group-${idx}">
                            <button class="choice-btn active" onclick="admin.setConflictChoice(${idx}, 'keep')"
                                title="Data v aplikaci OmS z≈Østanou beze zmƒõny. Ignorovat data z cloudu/souboru.">Ponechat p≈Øvodn√≠</button>
                            <button class="choice-btn" onclick="admin.setConflictChoice(${idx}, 'update')"
                                title="Aktualizovat st√°vaj√≠c√≠ho hr√°ƒçe v OmS daty z cloudu/souboru.">P≈ôepsat z cloudu</button>
                            <button class="choice-btn" onclick="admin.setConflictChoice(${idx}, 'both')"
                                title="V OmS z≈Østane st√°vaj√≠c√≠ z√°znam a z√°rove≈à se vytvo≈ô√≠ nov√Ω z importu (budou tam oba).">Ponechat oba</button>
                        </div>
                    `;
                    container.appendChild(row);
                });

                // Attach resolution data
                admin._pendingImport = { conflicts, newEntries };

                document.getElementById('btn-resolve-all').onclick = () => {
                    const data = admin._pendingImport;
                    data.conflicts.forEach(c => {
                        if (c.choice === 'update') {
                            Object.assign(c.existing, c.imported);
                            // Also update references in current tourney players if they exist there
                            const inTourney = state.players.find(p => p.id === c.existing.id);
                            if (inTourney) Object.assign(inTourney, c.imported);
                        } else if (c.choice === 'both') {
                            const p = { ...c.imported };
                            p.id = "player_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                            state.masterPlayers.push(p);
                        }
                    });

                    data.newEntries.forEach(p => {
                        if (!p.id) p.id = "player_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                        state.masterPlayers.push(p);
                    });

                    modal.style.display = 'none';
                    admin.renderIdentityInputs();
                    admin.saveToStorage(); game.syncProjection();
                    alert(`Import do hlavn√≠ datab√°ze dokonƒçen.`);
                };
            },

            setConflictChoice: (idx, choice) => {
                admin._pendingImport.conflicts[idx].choice = choice;
                const group = document.getElementById(`choice-group-${idx}`);
                const buttons = group.querySelectorAll('.choice-btn');
                buttons.forEach(btn => btn.classList.remove('active'));

                if (choice === 'keep') buttons[0].classList.add('active');
                else if (choice === 'update') buttons[1].classList.add('active');
                else if (choice === 'both') buttons[2].classList.add('active');
            },

            cancelConflictReview: () => {
                document.getElementById('modal-player-conflicts').style.display = 'none';
                admin._pendingImport = null;
            },

            propagateRenames: (oldList, newList, type) => {
                // This helper is largely deprecated but kept for manual logic if needed.
                // ID-based system handles renames implicitly.
            },

            resetTournament: () => {
                if (confirm("Opravdu chcete resetovat TURNAJ? Vyma≈æe se rozpis, dru≈æstva a v√Ωsledky. Nastaven√≠ aplikace (zvuky, t√©ma, master datab√°ze) z≈Østane zachov√°no.")) {
                    // 1. Stop timer
                    if (state.timer.running) {
                        game.toggleTimer();
                    }

                    // 2. Clear Tournament Data
                    state.tournamentName = "";
                    state.tournamentCategory = "";
                    state.tournamentDate = new Date().toISOString().split('T')[0];
                    state.tournamentLocation = "";
                    state.tournamentOrganizer = "";
                    state.pitchSize = "11 x 14 (m)";
                    state.officialChiefReferee = "";
                    state.officialRecorder = "";
                    state.officialTimekeeper = "";

                    state.teams = [];
                    state.players = []; // Tournament players
                    state.referees = [];
                    state.schedule = [];
                    state.misc = []; // Misc info

                    // 3. Clear Assets linked to teams (optional, but good for cleanup)
                    state.teamLogos = {};
                    state.teamAnthems = {};

                    // 4. Reset Match State
                    state.currentMatch = {
                        title: "",
                        homeName: "Dom√°c√≠",
                        guestName: "Host√©",
                        homeScore: 0,
                        guestScore: 0,
                        referee: "",
                        phaseIndex: 0,
                        isEvent: false,
                        duration: 600
                    };
                    state.activeMatchIndex = -1;
                    state.pendingEditIndex = -1;
                    state.selectedIndices = [];

                    // 5. Reset Timer State
                    state.timer.timeLeft = state.times.play; // Default to play time
                    state.timer.lastTick = 0;
                    state.playTimeAccumulated = 0;
                    state.tournamentStartTime = null;

                    // 6. Save and Reload/Render
                    admin.saveToStorage();
                    alert("Turnaj byl resetov√°n.");
                    location.reload();
                }
            },

            resetApp: () => {
                if (confirm("Opravdu chcete vymazat v≈°echna data aplikace (dru≈æstva, rozpis, zvuk, jingly)? Tuto akci nelze vz√≠t zpƒõt.")) {
                    localStorage.removeItem('scoreboardState');

                    const deleteDB = (name) => {
                        return new Promise((resolve) => {
                            const req = indexedDB.deleteDatabase(name);
                            req.onsuccess = resolve;
                            req.onerror = resolve; // Proceed even on error
                            req.onblocked = resolve;
                        });
                    };

                    // Cleanup Firebase session if possible
                    let firebaseCleanup = Promise.resolve();
                    if (typeof firebase !== 'undefined' && !state.isProjectionMode) {
                        try {
                            firebaseCleanup = firebase.database().ref('sessions/' + state.sessionId).remove();
                        } catch (e) { console.warn("Firebase reset cleanup failed:", e); }
                    }

                    Promise.all([deleteDB("MusicDB"), deleteDB("JingleDB"), firebaseCleanup]).then(() => {
                        location.reload();
                    });
                }
            },



            updateCurrentMatch: () => {
                // Manually updating from input fields is deprecated as fields were removed.
                // Keeping function stub if needed for future logic, or removing.
                // For now, let's just sync projection if called.
                ui.updateNames();
                game.syncProjection();
            },

            generateScheduleFromTemplate: () => {
                const templateId = document.getElementById('sched-template-select').value;
                const template = SCHEDULE_TEMPLATES[templateId];
                if (!template) return;

                const count = template.teams;
                if (state.teams.length < count) {
                    alert(`Pro toto sch√©ma je pot≈ôeba definovat alespo≈à ${count} dru≈æstev. Aktu√°lnƒõ jich m√°te ${state.teams.length}.`);
                    return;
                }

                // Always replace
                state.schedule = [];
                state.activeMatchIndex = -1;

                const startIdx = state.schedule.length;
                const pairs = template.matches;
                const defaultDuration = (state.times.play * 2) + state.times.break;
                const refsPerMatch = template.refsPerMatch || 1;
                let refIdx = 0;

                pairs.forEach((pair, idx) => {
                    // Resolve home team
                    let home = pair[0];
                    if (typeof home === 'number') {
                        home = state.teams[home - 1].id;
                    }

                    // Resolve guest team
                    let guest = pair[1];
                    if (typeof guest === 'number') {
                        guest = state.teams[guest - 1].id;
                    }

                    // Resolve title (optional 3rd element)
                    const title = pair[2] || `Z√°pas ${startIdx + idx + 1}`;

                    // Assign Referees
                    let assignedRefs = [];
                    if (state.referees.length > 0) {
                        for (let r = 0; r < refsPerMatch; r++) {
                            const ref = state.referees[(refIdx + r) % state.referees.length];
                            if (ref) assignedRefs.push(ref.id);
                        }
                        refIdx += refsPerMatch;
                    }

                    state.schedule.push({
                        type: 'match',
                        title: title,
                        home: home,
                        guest: guest,
                        referee: assignedRefs.join(', '),
                        homeScore: null,
                        guestScore: null,
                        phaseIndex: 0,
                        duration: defaultDuration
                    });
                });

                // CLEANUP: Keep only used identities and their assets
                const usedTeamIds = new Set(state.schedule.filter(m => m.type === 'match').flatMap(m => [m.home, m.guest]));
                const usedRefIds = new Set(state.schedule.filter(m => m.type === 'match').map(m => m.referee));

                state.teams = state.teams.filter(t => usedTeamIds.has(t.id));
                state.referees = state.referees.filter(r => usedRefIds.has(r.id));

                Object.keys(state.teamLogos).forEach(id => {
                    if (!usedTeamIds.has(id)) delete state.teamLogos[id];
                });
                Object.keys(state.teamAnthems).forEach(id => {
                    if (!usedTeamIds.has(id)) delete state.teamAnthems[id];
                });

                admin.saveSettings(false); // Silent save
                ui.renderSchedule();
                admin.renderIdentityInputs(); // Refresh lists
                admin.renderLogoSettings();   // Refresh logo section
                game.syncProjection();
                game.syncProjection();
                alert(`Rozpis pro ${count} dru≈æstev byl vygenerov√°n.`);
            },

            addMatch: () => {
                const type = document.getElementById('sched-type').value;
                const isEvent = type === 'event';
                const titleSel = document.getElementById('sched-title');
                const customTitleEl = document.getElementById('sched-custom-title');
                const isCustomVisible = customTitleEl.style.display !== 'none';
                const customTitle = customTitleEl.value.trim();
                const title = (isEvent || isCustomVisible) ? (customTitle || titleSel.value) : titleSel.value;

                const match = {
                    type,
                    title,
                    home: isEvent ? "" : document.getElementById('sched-home').value,
                    guest: isEvent ? "" : document.getElementById('sched-guest').value,
                    referee: isEvent ? "" : document.getElementById('sched-referee').value,
                    duration: isEvent ? parseInt(document.getElementById('sched-duration').value || 600) : null,
                    homeScore: null,
                    guestScore: null
                };
                state.schedule.push(match);
                admin.clearSchedInputs();
                admin.toggleScheduleForm(false); // Hide after add
                ui.renderSchedule();
                admin.saveToStorage(); game.syncProjection();
                game.syncProjection();
            },

            toggleScheduleForm: (forceShow) => {
                const f = document.getElementById('sched-form-container');
                const btn = document.getElementById('btn-toggle-sched-form');

                let show = forceShow !== undefined ? forceShow : (f.style.display === 'none');

                f.style.display = show ? 'block' : 'none';
                if (btn) {
                    btn.innerHTML = show ? '<b style="font-weight: 900;">-</b> Zav≈ô√≠t formul√°≈ô' : '<b style="font-weight: 900;">+</b> P≈ôidat z√°pas';
                }

                if (show) {
                    const form = document.getElementById('sched-form-container');
                    const header = document.querySelector('#acc-schedule h4');
                    if (state.pendingEditIndex === -1 && form && header) {
                        // Move back to top (below header) if adding new
                        header.after(form);
                        admin.clearSchedInputs();
                    }
                }
            },

            toggleAddMode: () => {
                const f = document.getElementById('sched-form-container');
                const isVisible = f.style.display !== 'none';
                const isAdding = state.pendingEditIndex === -1;

                if (isVisible && isAdding) {
                    // Already adding - hide it
                    admin.toggleScheduleForm(false);
                } else {
                    // Closed or editing - switch to add mode
                    state.pendingEditIndex = -1;
                    admin.toggleScheduleForm(true);
                    ui.renderSchedule(); // Refresh highlighting
                }
            },

            editScheduleMatch: (index) => {
                state.pendingEditIndex = index;
                const m = state.schedule[index];
                const type = m.type || 'match';
                document.getElementById('sched-type').value = type;

                // Title handling
                const titleSel = document.getElementById('sched-title');
                const customInput = document.getElementById('sched-custom-title');
                let found = false;
                for (let i = 0; i < titleSel.options.length; i++) {
                    if (titleSel.options[i].value === m.title) {
                        titleSel.selectedIndex = i;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    customInput.value = m.title;
                    customInput.style.display = 'block';
                    titleSel.style.display = 'none';
                } else {
                    customInput.style.display = 'none';
                    titleSel.style.display = 'block';
                }

                document.getElementById('sched-home').value = m.home || "";
                document.getElementById('sched-guest').value = m.guest || "";
                document.getElementById('sched-referee').value = m.referee || "";
                document.getElementById('sched-home-score').value = (m.homeScore !== undefined && m.homeScore !== null) ? m.homeScore : "";
                document.getElementById('sched-guest-score').value = (m.guestScore !== undefined && m.guestScore !== null) ? m.guestScore : "";
                document.getElementById('sched-duration').value = m.duration || 600;

                admin.onSchedTypeChange(); // UI Sync

                // Toggle buttons
                document.getElementById('sched-controls-add').style.display = 'none';
                document.getElementById('sched-controls-edit').style.display = 'flex';

                // Ensure form section is open
                admin.toggleScheduleForm(true);

                // Open accordion if closed
                const acc = document.getElementById('acc-schedule');
                if (!acc.classList.contains('open')) acc.classList.add('open');

                ui.renderSchedule(); // RE-RENDER to move form and highlight match
            },

            saveEditedMatch: () => {
                if (state.pendingEditIndex > -1) {
                    const type = document.getElementById('sched-type').value;
                    const isEvent = type === 'event';
                    const titleSel = document.getElementById('sched-title');
                    const customTitleEl = document.getElementById('sched-custom-title');
                    const isCustomVisible = customTitleEl.style.display !== 'none';
                    const customTitle = customTitleEl.value.trim();
                    const title = (isEvent || isCustomVisible) ? (customTitle || titleSel.value) : titleSel.value;

                    let hScore = document.getElementById('sched-home-score').value;
                    let gScore = document.getElementById('sched-guest-score').value;

                    // Validation: Ensure non-negative
                    // Validation: Ensure valid numbers
                    let parsedH = (hScore !== "" && !isNaN(hScore)) ? parseInt(hScore) : null;
                    let parsedG = (gScore !== "" && !isNaN(gScore)) ? parseInt(gScore) : null;

                    if (parsedH !== null && parsedH < 0) parsedH = 0;
                    if (parsedG !== null && parsedG < 0) parsedG = 0;

                    state.schedule[state.pendingEditIndex] = {
                        type,
                        title,
                        home: isEvent ? "" : document.getElementById('sched-home').value,
                        guest: isEvent ? "" : document.getElementById('sched-guest').value,
                        referee: isEvent ? "" : document.getElementById('sched-referee').value,
                        homeScore: isEvent ? null : parsedH,
                        guestScore: isEvent ? null : parsedG,
                        duration: isEvent ? parseInt(document.getElementById('sched-duration').value || 600) : null
                    };
                    const wasActive = (state.pendingEditIndex === state.activeMatchIndex);
                    admin.cancelEdit(); // Reset UI
                    ui.renderSchedule();
                    admin.saveToStorage();

                    if (wasActive) {
                        // Refresh active display immediately
                        admin.loadMatch(state.activeMatchIndex, false);
                    } else {
                        game.syncProjection();
                    }
                    admin.toggleScheduleForm(false); // Hide
                }
            },

            deleteMatch: () => {
                if (state.pendingEditIndex > -1 && confirm("Opravdu smazat tento z√°pas?")) {
                    state.schedule.splice(state.pendingEditIndex, 1);
                    // Adjust active index if needed
                    if (state.activeMatchIndex === state.pendingEditIndex) state.activeMatchIndex = -1;
                    else if (state.activeMatchIndex > state.pendingEditIndex) state.activeMatchIndex--;

                    admin.cancelEdit();
                    ui.renderSchedule();
                    admin.saveToStorage(); game.syncProjection();
                    admin.toggleScheduleForm(false); // Hide
                }
            },

            cancelEdit: () => {
                state.pendingEditIndex = -1;
                ui.renderSchedule(); // Re-render to clear highlights
                admin.clearSchedInputs();
                document.getElementById('sched-controls-add').style.display = 'block';
                document.getElementById('sched-controls-edit').style.display = 'none';
                admin.toggleScheduleForm(false); // Hide
            },

            clearSchedInputs: () => {
                document.getElementById('sched-type').value = "match";
                document.getElementById('sched-title').selectedIndex = 0;
                document.getElementById('sched-title').style.display = 'block';
                document.getElementById('sched-custom-title').value = "";
                document.getElementById('sched-custom-title').style.display = 'none';
                document.getElementById('sched-home').value = "";
                document.getElementById('sched-guest').value = "";
                document.getElementById('sched-referee').value = "";
                document.getElementById('sched-home-score').value = "";
                document.getElementById('sched-guest-score').value = "";
                document.getElementById('sched-duration').value = 600;
                admin.onSchedTypeChange();

                // CRITIAL FIX: Ensure dropdowns are populated if empty (e.g. after refresh)
                if (document.getElementById('sched-home').options.length <= 1) {
                    ui.fillSelects();
                }
            },

            handleScheduleImport: (input) => {
                if (!input.files || !input.files[0]) return;
                const file = input.files[0];

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const sheetName = workbook.SheetNames[0];
                        const sheet = workbook.Sheets[sheetName];
                        const json = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                        if (json.length < 1) {
                            alert("Soubor je pr√°zdn√Ω nebo neƒçiteln√Ω.");
                            input.value = "";
                            return;
                        }

                        // --- INTELLIGENT DETECTION: Backup vs Schedule ---

                        // Check for Backup Signature:
                        // 1. Row 12 (index 12) usually contains header "Po≈ôad√≠" | "N√°zev / Skupina" | "Dom√°c√≠ dru≈æstvo"
                        // 2. Row 0 (index 0) usually has tournament name
                        let isBackup = false;
                        let backupHeaderRow = -1;

                        // Scan specifically for Backup Header signature around row 12 (allow some slack)
                        for (let r = 10; r < 15; r++) {
                            if (json[r]) {
                                const rowStr = json[r].join(" ").toLowerCase();
                                if (rowStr.includes("po≈ôad√≠") && rowStr.includes("dom√°c√≠ dru≈æstvo") && rowStr.includes("hostuj√≠c√≠ dru≈æstvo")) {
                                    isBackup = true;
                                    backupHeaderRow = r;
                                    break;
                                }
                            }
                        }

                        if (isBackup) {
                            if (confirm(`Detekov√°na z√°loha turnaje "${json[0]?.[0] || 'Nezn√°m√Ω'}".\n\nChcete OBNOVIT cel√Ω turnaj ze z√°lohy?\n(Tato akce nahrad√≠ v≈°echna data turnaje)`)) {
                                admin._restoreTournamentFromBackup(json, backupHeaderRow);
                                input.value = "";
                                return;
                            }
                            // If user cancels, we fall through to try standard schedule import
                        }

                        // --- STANDARD SCHEDULE IMPORT LOGIC (Original) ---
                        const newMatches = [];
                        let colMap = { title: 0, home: 1, guest: 2, referee: 3, duration: 4 };
                        let headerRowIndex = -1;

                        // Smart Header Detection: Scan first 20 rows
                        for (let r = 0; r < Math.min(json.length, 20); r++) {
                            const row = json[r];
                            if (!row || row.length < 2) continue;

                            let detected = {};
                            row.forEach((cell, c) => {
                                const val = String(cell || "").toLowerCase();
                                if (val.includes("dom√°c√≠") || val.includes("home")) detected.home = c;
                                if (val.includes("host") || val.includes("guest")) detected.guest = c;
                                if (val.includes("rozhodƒç√≠") || val.includes("ref")) detected.referee = c;
                                if (val.includes("n√°zev") || val.includes("skupina") || val.includes("f√°ze")) detected.title = c;
                                if (val.includes("d√©lka") || val.includes("duration") || val.includes("minut")) detected.duration = c;
                            });

                            // If we found at least 2 key columns (Home & Guest), consider this the header row
                            if (detected.home !== undefined && detected.guest !== undefined) {
                                colMap = { ...colMap, ...detected };
                                headerRowIndex = r;
                                break;
                            }
                        }

                        let startRow = headerRowIndex + 1;
                        // Determine basic duration fallback
                        const fallbackDuration = (state.times.play * 2) + state.times.break;

                        const usedTeamIds = new Set();
                        const usedRefIds = new Set();
                        let addedTeams = 0;
                        let addedRefs = 0;

                        for (let i = startRow; i < json.length; i++) {
                            const row = json[i];
                            if (!row || row.length < 2) continue;

                            const title = String(row[colMap.title] || "Z√°pas").trim();
                            const home = String(row[colMap.home] || "").trim();
                            const guest = String(row[colMap.guest] || "").trim();
                            const ref = String(row[colMap.referee] || "").trim();

                            // Parse duration if column exists, else use rule-based default
                            let duration = fallbackDuration;
                            if (colMap.duration !== undefined) {
                                const dVal = parseInt(row[colMap.duration]);
                                if (!isNaN(dVal) && dVal > 0) duration = dVal;
                            }

                            const resHome = admin.ensureIdentityExists(home, 'team');
                            if (resHome) {
                                addedTeams++;
                                usedTeamIds.add(resHome);
                            }
                            const resGuest = admin.ensureIdentityExists(guest, 'team');
                            if (resGuest) {
                                addedTeams++;
                                usedTeamIds.add(resGuest);
                            }
                            const resRef = admin.ensureIdentityExists(ref, 'ref');
                            if (resRef) {
                                addedRefs++;
                                usedRefIds.add(resRef);
                            }

                            newMatches.push({
                                type: 'match',
                                title: title,
                                home: resHome || home,
                                guest: resGuest || guest,
                                referee: resRef || ref,
                                homeScore: null,
                                guestScore: null,
                                duration: duration
                            });
                        }

                        // CLEANUP: Remove unused identities and their assets
                        state.teams = state.teams.filter(t => usedTeamIds.has(t.id));
                        state.referees = state.referees.filter(r => usedRefIds.has(r.id));

                        // Cleanup logos and anthems
                        Object.keys(state.teamLogos).forEach(id => {
                            if (!usedTeamIds.has(id)) delete state.teamLogos[id];
                        });
                        Object.keys(state.teamAnthems).forEach(id => {
                            if (!usedTeamIds.has(id)) delete state.teamAnthems[id];
                        });

                        // Always overwrite
                        state.schedule = newMatches;
                        state.activeMatchIndex = -1;

                        ui.renderSchedule();
                        admin.saveToStorage();
                        admin.renderIdentityInputs(); // Refresh lists
                        admin.renderLogoSettings();   // Refresh logo section
                        game.syncProjection();
                        alert(`Importov√°no ${newMatches.length} z√°pas≈Ø.\n(Aplikace byla vyƒçi≈°tƒõna: ponech√°no ${state.teams.length} dru≈æstev a ${state.referees.length} rozhodƒç√≠ch)`);
                        input.value = "";
                    } catch (err) {
                        console.error(err);
                        alert("Chyba p≈ôi ƒçten√≠ souboru. Ujistƒõte se, ≈æe je to platn√Ω Excel nebo CSV.\n\n" + err.message);
                        input.value = "";
                    }
                };
                reader.readAsArrayBuffer(file);
            },

            _restoreTournamentFromBackup: (json, headerRowIndex) => {
                try {
                    // Parse metadata (rows 0-10)
                    state.tournamentName = json[0][0] || "";
                    state.tournamentCategory = json[1][1] || "";
                    state.tournamentOrganizer = json[2][1] || "";

                    let dateStr = json[3][1];
                    if (dateStr && dateStr !== "-") {
                        if (dateStr instanceof Date) {
                            state.tournamentDate = dateStr.toISOString().split('T')[0];
                        } else {
                            // Robust parsing of "D. M. YYYY" or "D.M.YYYY"
                            const cleanDate = String(dateStr).replace(/\s/g, '');
                            const parts = cleanDate.split('.');
                            if (parts.length === 3) {
                                const d = parts[0].padStart(2, '0');
                                const m = parts[1].padStart(2, '0');
                                const y = parts[2];
                                // Check if year is 4 digits
                                if (y.length === 4) {
                                    state.tournamentDate = `${y}-${m}-${d}`;
                                }
                            }
                        }
                    }

                    state.tournamentLocation = json[4][1] || "";
                    state.pitchSize = json[5][1] || "";

                    const splitName = (val) => {
                        if (!val || val === "-") return { surname: "", firstName: "" };
                        const p = String(val).trim().split(" ");
                        return { surname: p[0] || "", firstName: p.slice(1).join(" ") || "" };
                    };

                    state.officialChiefReferee = splitName(json[6][1]);
                    state.officialTimekeeper = splitName(json[7][1]);
                    state.officialRecorder = splitName(json[8][1]);

                    // Scoring Rules
                    const ruleStr = json[9][1];
                    if (ruleStr && String(ruleStr).includes("/")) {
                        const pts = String(ruleStr).split("/");
                        if (!state.rules) state.rules = {};
                        state.rules.winPoints = parseInt(pts[0]) || 3;
                        state.rules.drawPoints = parseInt(pts[1]) || 1;
                        state.rules.lossPoints = parseInt(pts[2]) || 0;
                    }
                    const miniStr = json[10][1];
                    if (!state.rules) state.rules = {};
                    state.rules.useMiniTables = (miniStr === "Ano");

                    // Times
                    const timeStr = json[11][1];
                    if (timeStr && String(timeStr).includes("/")) {
                        const tpt = String(timeStr).split("/");
                        if (!state.times) state.times = {};
                        state.times.play = parseInt(tpt[0]) || 420;
                        state.times.break = parseInt(tpt[1]) || 105;
                        state.times.setup = parseInt(tpt[2]) || 10;
                    }

                    // Clear basics
                    state.teams = [];
                    state.players = [];
                    state.referees = [];
                    state.schedule = [];
                    state.teamLogos = {};
                    state.teamAnthems = {};
                    state.activeMatchIndex = -1;
                    state.misc = [];

                    // --- 1. Parse Schedule FIRST to build base Team/Ref maps ---
                    const teamMap = new Map(); // name -> id
                    const refMap = new Map(); // name -> id

                    let currentRowIndex = headerRowIndex + 1;

                    // Keep reading until we hit an empty row or a known section header
                    for (; currentRowIndex < json.length; currentRowIndex++) {
                        const row = json[currentRowIndex];
                        if (!row || row.length < 2) break; // Break on empty/short row between sections

                        const firstCell = String(row[0] || "").trim().toUpperCase();
                        if (firstCell.includes("SBOR ROZHODƒå√çCH") || firstCell.includes("SOUPISKY DRU≈ΩSTEV") || firstCell.includes("R≈ÆZN√â")) {
                            break; // End of schedule, start of new section
                        }

                        const title = String(row[1] || "").trim();
                        const homeTeam = String(row[2] || "").trim();
                        const guestTeam = String(row[3] || "").trim();
                        const scoreStr = String(row[4] || "").trim();
                        const refName = String(row[5] || "").trim();
                        const duration = parseInt(row[6]) || 600;

                        const isEvent = homeTeam === "-" || homeTeam === "" || title.includes("UD√ÅLOST");

                        if (isEvent) {
                            state.schedule.push({
                                type: 'event',
                                title: title,
                                duration: duration
                            });
                        } else {
                            if (homeTeam && !teamMap.has(homeTeam)) {
                                const id = "team_" + Date.now() + "_" + Math.floor(Math.random() * 100000);
                                teamMap.set(homeTeam, id);
                                state.teams.push({ id, name: homeTeam, playerIds: [] });
                            }
                            if (guestTeam && !teamMap.has(guestTeam)) {
                                const id = "team_" + Date.now() + "_" + Math.floor(Math.random() * 100000);
                                teamMap.set(guestTeam, id);
                                state.teams.push({ id, name: guestTeam, playerIds: [] });
                            }
                            if (refName && refName !== "-" && !refMap.has(refName)) {
                                const id = "ref_" + Date.now() + "_" + Math.floor(Math.random() * 100000);
                                refMap.set(refName, id);
                                const p = String(refName).trim().split(" ");
                                state.referees.push({
                                    id,
                                    surname: p[0] || "",
                                    firstName: p.slice(1).join(" ") || ""
                                });
                            }

                            let homeScore = null;
                            let guestScore = null;
                            if (scoreStr && scoreStr !== "-" && scoreStr.includes(":")) {
                                const parts = scoreStr.split(":");
                                homeScore = parseInt(parts[0]);
                                guestScore = parseInt(parts[1]);
                                if (isNaN(homeScore) || isNaN(guestScore)) { homeScore = null; guestScore = null; }
                            }

                            state.schedule.push({
                                type: 'match',
                                title: title,
                                home: teamMap.get(homeTeam),
                                guest: teamMap.get(guestTeam),
                                referee: refMap.get(refName) || "",
                                homeScore: homeScore,
                                guestScore: guestScore,
                                duration: duration
                            });
                        }
                    }

                    // --- 2. Parse Other Sections ---
                    // Scan remaining rows for section headers
                    let section = null; // 'refs', 'rosters', 'misc'

                    for (; currentRowIndex < json.length; currentRowIndex++) {
                        const row = json[currentRowIndex];
                        if (!row || row.length === 0) continue;

                        const val0 = String(row[0] || "").trim().toUpperCase();
                        const val1 = String(row[1] || "").trim().toUpperCase();

                        // Detect Section Headers
                        if (val0 === "SBOR ROZHODƒå√çCH") { section = 'refs'; continue; }
                        if (val0 === "SOUPISKY DRU≈ΩSTEV" || (val0 === "DRU≈ΩSTVO" && val1.includes("HR√Åƒå"))) { section = 'rosters'; continue; }
                        if (val0 === "R≈ÆZN√â") { section = 'misc'; continue; }

                        // Parse Content based on current section
                        if (section === 'refs') {
                            const name = String(row[0] || "").trim();
                            if (name && !refMap.has(name)) {
                                const id = "ref_" + Date.now() + "_" + Math.floor(Math.random() * 100000);
                                refMap.set(name, id);
                                const p = String(name).trim().split(" ");
                                state.referees.push({
                                    id,
                                    surname: p[0] || "",
                                    firstName: p.slice(1).join(" ") || ""
                                });
                            }
                        }
                        else if (section === 'rosters') {
                            // Column 0: Team Name
                            // Column 1: Player 1 Name, Column 2: UCI-ID 1
                            // Column 3: Player 2 Name, Column 4: UCI-ID 2
                            const tName = String(row[0] || "").trim();
                            // Skip header row if repeated
                            if (tName === "SOUPISKY DRU≈ΩSTEV" || tName === "DRU≈ΩSTVO") continue;

                            if (tName) {
                                // Find team
                                let tId = teamMap.get(tName);
                                if (!tId) {
                                    tId = "team_" + Date.now() + "_" + Math.floor(Math.random() * 100000);
                                    teamMap.set(tName, tId);
                                    state.teams.push({ id: tId, name: tName, playerIds: [] });
                                }
                                const teamObj = state.teams.find(t => t.id === tId);

                                // Helper to process player
                                const processPlayer = (name, uci) => {
                                    if (!name || name === "-") return null;
                                    // Parse name
                                    const parts = name.split(" ");
                                    const surname = parts[0] || "";
                                    const firstname = parts.slice(1).join(" ") || "";

                                    // Make new player (no complex lookup needed for backup restore, we trust the file)
                                    const pid = "player_" + Date.now() + "_" + Math.floor(Math.random() * 100000);
                                    state.players.push({
                                        id: pid,
                                        firstName: firstname,
                                        surname: surname,
                                        uciId: uci || ""
                                    });
                                    return pid;
                                };

                                const p1Id = processPlayer(String(row[1] || "").trim(), String(row[2] || "").trim());
                                const p2Id = processPlayer(String(row[3] || "").trim(), String(row[4] || "").trim());

                                teamObj.playerIds = [];
                                if (p1Id) teamObj.playerIds.push(p1Id);
                                if (p2Id) teamObj.playerIds.push(p2Id);
                            }
                        }
                        else if (section === 'misc') {
                            const text = String(row[0] || "").trim();
                            if (text) {
                                state.misc.push({ id: "misc_" + Date.now() + "_" + Math.floor(Math.random() * 1000), text });
                            }
                        }
                    }

                    // Reset current match
                    state.currentMatch = {
                        title: "",
                        homeName: "Dom√°c√≠",
                        guestName: "Host√©",
                        homeScore: 0,
                        guestScore: 0,
                        referee: "",
                        phaseIndex: 0,
                        isEvent: false,
                        duration: 600
                    };

                    // Save and refresh UI
                    admin.saveToStorage();
                    admin.renderIdentityInputs();
                    admin.renderLogoSettings();
                    ui.fillSelects();
                    ui.renderSchedule();
                    admin.updateSettingsUI(); // Update metadata inputs!
                    ui.renderStandings();
                    game.syncProjection();

                    alert(`Obnoven√≠ turnaje dokonƒçeno!\n\nTurnaj: ${state.tournamentName}\nDru≈æstva: ${state.teams.length}\nZ√°pasy: ${state.schedule.filter(m => m.type === 'match').length}\nRozhodƒç√≠: ${state.referees.length}`);
                } catch (e) {
                    console.error(e);
                    alert("Chyba p≈ôi obnovƒõ ze z√°lohy: " + e.message);
                }
            },

            ensureIdentityExists: (name, type) => {
                if (!name || name === "-" || name.toLowerCase() === "volno") return null;
                const list = type === 'team' ? state.teams : state.referees;
                const existing = list.find(item => {
                    if (type === 'team') return item.name && item.name.toLowerCase() === name.toLowerCase();
                    const fullName = admin.getRefName(item.id).toLowerCase();
                    return fullName === name.toLowerCase();
                });
                if (existing) return existing.id;
                const id = (type === 'team' ? "team_" : "ref_") + Date.now() + "_" + Math.floor(Math.random() * 1000);
                if (type === 'team') {
                    list.push({ id, name });
                } else {
                    const p = name.trim().split(" ");
                    list.push({ id, surname: p[0] || "", firstName: p.slice(1).join(" ") || "" });
                }
                return id;
            },

            onSchedTypeChange: () => {
                const type = document.getElementById('sched-type').value;
                const isEvent = type === 'event';
                document.getElementById('sched-match-fields').style.display = isEvent ? 'none' : 'block';
                document.getElementById('sched-event-fields').style.display = isEvent ? 'block' : 'none';

                // Show custom title input for events, or allow toggle for match?
                // Let's force custom title for events.
                const titleSel = document.getElementById('sched-title');
                const customInput = document.getElementById('sched-custom-title');
                if (isEvent) {
                    titleSel.style.display = 'none';
                    customInput.style.display = 'block';
                } else {
                    titleSel.style.display = 'block';
                    customInput.style.display = 'none';
                }
            },

            moveMatch: (from, to) => {
                game.reorderSchedule(from, to);
            },

            renderLogoSettings: () => {
                const container = document.getElementById('team-logo-list');
                const teams = state.teams;

                if (teams.length === 0) {
                    container.innerHTML = '<div style="color:#666; font-size:0.8em;">P≈ôidejte dru≈æstva pro nahr√°n√≠ vlajek, log a jingles...</div>';
                    return;
                }

                container.innerHTML = '<small style="color:#aaa; display:block; margin-bottom:10px;">Dru≈æstva: vlajky, loga, jingly</small>';
                teams.forEach(teamObj => {
                    const team = teamObj.id;
                    const displayName = teamObj.name || "Dru≈æstvo";
                    const row = document.createElement('div');
                    row.style = 'display:flex; align-items:center; gap:10px; margin-bottom:8px; border-bottom:1px solid #444; padding-bottom:5px;';

                    const logoSrc = state.teamLogos[team] || '';
                    const hasAnthem = !!state.teamAnthems[team];

                    row.innerHTML = `
                        <div style="flex:1; font-size:0.9em; overflow:hidden; text-overflow:ellipsis;">${displayName}</div>
                        <img src="${logoSrc}" 
                             onclick="document.getElementById('logo-file-${team}').click()" 
                             title="Kliknut√≠m zmƒõn√≠te logo"
                             style="width:30px; height:30px; object-fit:contain; background:#444; border-radius:3px; cursor:pointer; display:${logoSrc ? 'block' : 'none'}">
                        
                        <input type="file" accept="image/*" style="display:none" id="logo-file-${team}" onchange="admin.handleLogoUpload('${team}', this)">
                        <button class="small-btn" onclick="document.getElementById('logo-file-${team}').click()" title="Nahr√°t Logo">üñºÔ∏è</button>
                        
                        <input type="file" accept="audio/*" style="display:none" id="anthem-file-${team}" onchange="admin.handleAnthemUpload('${team}', this)">
                        <button class="small-btn ${hasAnthem ? 'btn-green' : ''}" onclick="document.getElementById('anthem-file-${team}').click()" title="Nahr√°t Jingle">üéµ</button>
                    `;
                    container.appendChild(row);
                });
            },

            handleAnthemUpload: (teamName, input) => {
                if (input.files && input.files[0]) {
                    const file = input.files[0];
                    if (file.size > 1024 * 1024) {
                        alert("Jingle je p≈ô√≠li≈° velk√Ω (max 1MB).");
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        state.teamAnthems[teamName] = e.target.result;
                        admin.renderLogoSettings();
                    };
                    reader.readAsDataURL(file);
                }
            },

            handleLogoUpload: (teamName, input) => {
                if (input.files && input.files[0]) {
                    const file = input.files[0];
                    if (file.size > 500 * 1024) {
                        alert("Logo je p≈ô√≠li≈° velk√© (max 500KB).");
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        state.teamLogos[teamName] = e.target.result;
                        admin.renderLogoSettings();
                        ui.updateLogos();
                        game.syncProjection();
                    };
                    reader.readAsDataURL(file);
                }
            },

            handleDefaultLogo: (input) => {
                if (input.files && input.files[0]) {
                    const file = input.files[0];
                    if (file.size > 500 * 1024) {
                        alert("Logo je p≈ô√≠li≈° velk√© (max 500KB).");
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const base64 = e.target.result;
                        let count = 0;
                        state.teams.forEach(team => {
                            if (!state.teamLogos[team.id]) {
                                state.teamLogos[team.id] = base64;
                                count++;
                            }
                        });
                        if (count > 0) {
                            admin.renderLogoSettings();
                            ui.updateLogos();
                            game.syncProjection();
                            admin.saveToStorage();
                            alert(`Logo p≈ôi≈ôazeno ${count} dru≈æstv≈Øm.`);
                        } else {
                            alert("V≈°echna dru≈æstva ji≈æ maj√≠ sv√° loga.");
                        }
                        input.value = ""; // Reset input
                    };
                    reader.readAsDataURL(file);
                }
            },

            loadMatch: (index, resetPhase = false, snapshot = null) => {
                // Save current result if it was a real match before loading new one
                if (state.activeMatchIndex !== -1 && !state.currentMatch.isEvent) {
                    const currentMatchInSched = state.schedule[state.activeMatchIndex];
                    if (currentMatchInSched && currentMatchInSched.type === 'match') {
                        currentMatchInSched.homeScore = state.currentMatch.homeScore;
                        currentMatchInSched.guestScore = state.currentMatch.guestScore;
                        admin.saveToStorage(); // ENSURE STORAGE IS UPDATED
                    }
                }

                // Handle PO transition
                if (snapshot) {
                    game.triggerPoTransition(snapshot);
                } else if (state.poTransitionActive) {
                    // Manual load - cancel transition
                    if (poTransitionTimeoutID) clearTimeout(poTransitionTimeoutID);
                    state.poTransitionActive = false;
                    state.poTransitionData = null;
                }

                const m = state.schedule[index];
                if (!m) return;

                state.activeMatchIndex = index;
                state.currentMatch = {
                    ...state.currentMatch,
                    isEvent: (m.type === 'event'),
                    title: m.title || "",
                    homeName: m.home || "",
                    guestName: m.guest || "",
                    referee: m.referee || "",
                    homeScore: (m.homeScore !== null) ? m.homeScore : 0,
                    guestScore: (m.guestScore !== null) ? m.guestScore : 0,
                    duration: m.duration || 600
                };

                ui.updateNames();
                ui.updateScores();
                ui.renderSchedule(); // update active highlight
                ui.renderStandings(); // AUTOMATICALLY UPDATE TABLES

                if (resetPhase) {
                    game.setPhase(0, true);
                } else {
                    // Force sync even if phase is not reset
                    game.syncProjection();
                }
            },

            toggleSelection: (index, isShift, isCtrl, silent = false) => {
                if (index < 0 || index >= state.schedule.length) return;

                // Cancel edit if clicking a different item (single click)
                if (!isShift && !isCtrl && state.pendingEditIndex !== -1) {
                    if (state.pendingEditIndex !== index) {
                        admin.cancelEdit();
                    } else {
                        // Clicking the same item that's being edited - close it
                        admin.cancelEdit();
                        return; // Done
                    }
                }

                if (isShift && state.selectedIndices.length > 0) {
                    const last = state.selectedIndices[state.selectedIndices.length - 1];
                    const start = Math.min(last, index);
                    const end = Math.max(last, index);
                    // Add the range to current selection
                    for (let i = start; i <= end; i++) {
                        if (!state.selectedIndices.includes(i)) state.selectedIndices.push(i);
                    }
                } else if (isCtrl) {
                    const idx = state.selectedIndices.indexOf(index);
                    if (idx > -1) state.selectedIndices.splice(idx, 1);
                    else state.selectedIndices.push(index);
                } else {
                    state.selectedIndices = [index];
                }
                state.selectedIndices.sort((a, b) => a - b);
                if (!silent) ui.renderSchedule();
            },

            moveSelected: (direction) => {
                if (state.selectedIndices.length === 0) return;

                // Direction: -1 (up), 1 (down)
                // Need to move items without stepping on each other
                const indices = [...state.selectedIndices].sort((a, b) => direction > 0 ? b - a : a - b);

                let movedAny = false;
                const newSelection = [];

                indices.forEach(idx => {
                    const targetIdx = idx + direction;
                    if (targetIdx >= 0 && targetIdx < state.schedule.length) {
                        const item = state.schedule.splice(idx, 1)[0];
                        state.schedule.splice(targetIdx, 0, item);
                        newSelection.push(targetIdx);
                        movedAny = true;

                        // Adjust active match index
                        if (state.activeMatchIndex === idx) state.activeMatchIndex = targetIdx;
                        else if (direction > 0 && state.activeMatchIndex > idx && state.activeMatchIndex <= targetIdx) state.activeMatchIndex--;
                        else if (direction < 0 && state.activeMatchIndex < idx && state.activeMatchIndex >= targetIdx) state.activeMatchIndex++;
                    } else {
                        newSelection.push(idx);
                    }
                });

                if (movedAny) {
                    state.selectedIndices = newSelection.sort((a, b) => a - b);
                    ui.renderSchedule();
                    admin.saveToStorage(); game.syncProjection();
                    game.syncProjection();
                }
            },

            deleteSelected: () => {
                if (state.selectedIndices.length === 0) return;
                if (!confirm(`Opravdu smazat vybran√© z√°pasy (${state.selectedIndices.length})?`)) return;

                const indices = [...state.selectedIndices].sort((a, b) => b - a);
                indices.forEach(idx => {
                    state.schedule.splice(idx, 1);
                    if (state.activeMatchIndex === idx) state.activeMatchIndex = -1;
                    else if (state.activeMatchIndex > idx) state.activeMatchIndex--;
                });

                state.selectedIndices = [];
                state.pendingEditIndex = -1;
                ui.renderSchedule();
                admin.saveToStorage(); game.syncProjection();
            },

            resetSelectedScores: () => {
                if (state.selectedIndices.length === 0) return;
                state.selectedIndices.forEach(idx => {
                    if (state.schedule[idx]) {
                        state.schedule[idx].homeScore = null;
                        state.schedule[idx].guestScore = null;
                    }
                });
                ui.renderSchedule();
                admin.saveToStorage(); game.syncProjection();
                game.syncProjection();
            },

            loadSelected: () => {
                if (state.selectedIndices.length === 0) return;
                admin.loadMatch(state.selectedIndices[0], true);
            },

            editSelected: () => {
                if (state.selectedIndices.length === 0) return;
                const index = state.selectedIndices[0];
                if (state.pendingEditIndex === index) {
                    admin.cancelEdit();
                } else {
                    admin.editScheduleMatch(index);
                }
            },

            moveMatchesTo: (indices, targetIdx) => {
                if (!indices || indices.length === 0) return;

                // Sort indices to move items in correct order
                indices.sort((a, b) => a - b);

                // Keep track of the active match
                const activeMatch = state.activeMatchIndex > -1 ? state.schedule[state.activeMatchIndex] : null;

                // Extract items to be moved
                const itemsToMove = indices.map(idx => state.schedule[idx]);

                // Create new schedule by removing items and inserting at target
                const remainingItems = state.schedule.filter((_, idx) => !indices.includes(idx));

                // Calculate actual insertion point in the remaining items array
                // We need to count how many items before targetIdx were removed
                let actualInsertIdx = targetIdx;
                let removedBefore = indices.filter(idx => idx < targetIdx).length;
                actualInsertIdx -= removedBefore;

                // Ensure bounds
                actualInsertIdx = Math.max(0, Math.min(actualInsertIdx, remainingItems.length));

                remainingItems.splice(actualInsertIdx, 0, ...itemsToMove);
                state.schedule = remainingItems;

                // Update active match index if it exists
                if (activeMatch) {
                    state.activeMatchIndex = state.schedule.indexOf(activeMatch);
                }

                // Update selected indices to point to the new positions
                state.selectedIndices = [];
                for (let i = 0; i < itemsToMove.length; i++) {
                    state.selectedIndices.push(actualInsertIdx + i);
                }

                ui.renderSchedule();
                admin.saveToStorage(); game.syncProjection();
            },

            calculateStandings: () => {
                const teamsMap = {};

                // Identify active teams from schedule
                const activeTeamIds = new Set();
                if (state.schedule.length > 0) {
                    state.schedule.forEach(m => {
                        if (m.home) activeTeamIds.add(m.home);
                        if (m.guest) activeTeamIds.add(m.guest);
                    });
                } else {
                    // Fallback: If schedule is empty, maybe show all? Or none? 
                    // Let's show all to avoid empty table confusion during setup.
                    state.teams.forEach(t => activeTeamIds.add(t.id));
                }

                // Initialize map with ACTIVE teams only
                state.teams.forEach(t => {
                    if (activeTeamIds.has(t.id)) {
                        teamsMap[t.id] = { id: t.id, name: t.name, gp: 0, w: 0, d: 0, l: 0, gf: 0, ga: 0, gd: 0, pts: 0 };
                    }
                });

                // Process schedule
                state.schedule.forEach(m => {
                    const hs = parseInt(m.homeScore);
                    const gs = parseInt(m.guestScore);

                    if (m.type === 'match' && !isNaN(hs) && !isNaN(gs)) {
                        const h = teamsMap[m.home];
                        const g = teamsMap[m.guest];
                        if (!h || !g) return;

                        h.gp++; g.gp++;
                        h.gf += hs; h.ga += gs;
                        g.gf += gs; g.ga += hs;

                        if (hs > gs) {
                            h.w++; g.l++;
                            h.pts += (state.rules ? state.rules.winPoints : 3);
                            g.pts += (state.rules ? state.rules.lossPoints : 0);
                        } else if (hs < gs) {
                            g.w++; h.l++;
                            g.pts += (state.rules ? state.rules.winPoints : 3);
                            h.pts += (state.rules ? state.rules.lossPoints : 0);
                        } else {
                            h.d++; g.d++;
                            h.pts += (state.rules ? state.rules.drawPoints : 1);
                            g.pts += (state.rules ? state.rules.drawPoints : 1);
                        }
                        h.gd = h.gf - h.ga;
                        g.gd = g.gf - g.ga;
                    }
                });

                // Convert to array
                let standingsList = Object.values(teamsMap);

                // SORTING LOGIC
                if (!state.rules || !state.rules.useMiniTables) {
                    // Standard sorting: Points -> GD -> GF
                    standingsList.sort((a, b) => {
                        if (b.pts !== a.pts) return b.pts - a.pts;
                        if (b.gd !== a.gd) return b.gd - a.gd;
                        return b.gf - a.gf;
                    });
                    return standingsList;
                }

                // Advanced sorting: Mini-tables for ties
                const groups = {};
                standingsList.forEach(s => {
                    if (!groups[s.pts]) groups[s.pts] = [];
                    groups[s.pts].push(s);
                });

                const sortedPointsKeys = Object.keys(groups).map(Number).sort((a, b) => b - a);
                let finalStandings = [];

                sortedPointsKeys.forEach(p => {
                    const subgroup = groups[p];
                    if (subgroup.length === 1) {
                        finalStandings.push(subgroup[0]);
                    } else {
                        // Tie! Create mini-table from mutual matches
                        const teamIds = subgroup.map(t => t.id);
                        const mini = admin.calculateMiniTable(teamIds);

                        subgroup.sort((a, b) => {
                            const ma = mini[a.id];
                            const mb = mini[b.id];
                            if (mb.pts !== ma.pts) return mb.pts - ma.pts;
                            if (mb.gd !== ma.gd) return mb.gd - ma.gd;
                            if (mb.gf !== ma.gf) return mb.gf - ma.gf;
                            // Fallback to overall
                            if (b.gd !== a.gd) return b.gd - a.gd;
                            if (b.gf !== a.gf) return b.gf - a.gf;
                            return 0;
                        });
                        finalStandings.push(...subgroup);
                    }
                });

                return finalStandings;
            },

            calculateMiniTable: (teamIds) => {
                const mini = {};
                teamIds.forEach(id => {
                    mini[id] = { pts: 0, gf: 0, ga: 0, gd: 0 };
                });

                state.schedule.forEach(m => {
                    const hs = parseInt(m.homeScore);
                    const gs = parseInt(m.guestScore);

                    if (m.type === 'match' && !isNaN(hs) && !isNaN(gs)) {
                        if (teamIds.includes(m.home) && teamIds.includes(m.guest)) {
                            const h = mini[m.home];
                            const g = mini[m.guest];

                            h.gf += hs; h.ga += gs;
                            g.gf += gs; g.ga += hs;

                            if (hs > gs) {
                                h.pts += (state.rules ? state.rules.winPoints : 3);
                                g.pts += (state.rules ? state.rules.lossPoints : 0);
                            } else if (hs < gs) {
                                g.pts += (state.rules ? state.rules.winPoints : 3);
                                h.pts += (state.rules ? state.rules.lossPoints : 0);
                            } else {
                                h.pts += (state.rules ? state.rules.drawPoints : 1);
                                g.pts += (state.rules ? state.rules.drawPoints : 1);
                            }
                            h.gd = h.gf - h.ga;
                            g.gd = g.gf - g.ga;
                        }
                    }
                });
                return mini;
            },

            setStandingsTab: (tab) => {
                state.activeStandingsTab = tab;
                ui.renderStandings(); // This will now delegate to cross table if needed
                admin.saveToStorage();
            },

            deselectAll: () => {
                if (state.selectedIndices.length > 0) {
                    state.selectedIndices = [];
                    ui.renderSchedule();
                }
            },

            updateSettingsUI: () => {
                const setVal = (id, val) => {
                    const el = document.getElementById(id);
                    if (el) el.value = val || "";
                };
                setVal('input-tournament-name', state.tournamentName);
                setVal('input-tournament-date', state.tournamentDate);
                setVal('input-tournament-location', state.tournamentLocation);
                setVal('input-tournament-organizer', state.tournamentOrganizer);
                setVal('input-pitch-size', state.pitchSize);

                // Officials (handle objects or strings)
                const populateOfficial = (prefix, val) => {
                    if (val && typeof val === 'object') {
                        setVal(prefix + '-surname', val.surname);
                        setVal(prefix + '-firstname', val.firstName);
                    } else if (typeof val === 'string') {
                        // Migration-on-the-fly for UI display
                        const p = val.trim().split(' ');
                        setVal(prefix + '-surname', p[0]);
                        setVal(prefix + '-firstname', p.slice(1).join(' '));
                    }
                };
                populateOfficial('official-chief-referee', state.officialChiefReferee);
                populateOfficial('official-timekeeper', state.officialTimekeeper);
                populateOfficial('official-recorder', state.officialRecorder);
                // Category needs special handling to match options
                const catEl = document.getElementById('input-tournament-category');
                if (catEl) catEl.value = state.tournamentCategory || "";

                // Times
                if (state.times) {
                    setVal('time-play', state.times.play);
                    setVal('time-break', state.times.break);
                    setVal('time-setup', state.times.setup);
                }

                if (state.rules) {
                    setVal('rule-win', state.rules.winPoints);
                    setVal('rule-draw', state.rules.drawPoints);
                    setVal('rule-loss', state.rules.lossPoints);
                    const miniEl = document.getElementById('rule-mini-tables');
                    if (miniEl) miniEl.checked = !!state.rules.useMiniTables;
                }

                setVal('input-cloud-file-id', state.cloudFileId);
                setVal('input-vol-signal', state.volSignal || 1.0);
                const vsDisp = document.getElementById('vol-signal-disp');
                if (vsDisp) vsDisp.innerText = Math.round((state.volSignal || 1.0) * 100);

                setVal('input-vol-anthem', state.volAnthem || 1.0);
                const vaDisp = document.getElementById('vol-anthem-disp');
                if (vaDisp) vaDisp.innerText = Math.round((state.volAnthem || 1.0) * 100);

                setVal('input-theme', state.theme || "light");
                setVal('input-po-delay', state.poTransitionDelay || 10);
                const footerEl = document.getElementById('input-show-footer');
                if (footerEl) footerEl.checked = (state.showFooter !== false);

                const jingleEl = document.getElementById('input-jingle-mode');
                if (jingleEl) jingleEl.value = state.jingleMode || "manual";

                const musicAuto = document.getElementById('input-music-auto');
                if (musicAuto) musicAuto.checked = !!state.musicAutoEnabled;
                const musicMode = document.getElementById('input-music-mode');
                if (musicMode) musicMode.value = state.musicMode || 'continuous';
                const musicFade = document.getElementById('input-music-fade');
                if (musicFade) musicFade.value = state.musicFadeDuration || 1;
                const fadeDisp = document.getElementById('fade-dur-disp');
                if (fadeDisp) fadeDisp.innerText = state.musicFadeDuration || 1;
            },

            saveToStorage: () => {
                localStorage.setItem('scoreboardState', JSON.stringify(state));
            },

            loadFromStorage: () => {
                state.isLoading = true;
                const loaded = localStorage.getItem('scoreboardState');
                if (loaded) {
                    const parsed = JSON.parse(loaded);
                    state.tournamentName = parsed.tournamentName || "";
                    state.tournamentCategory = parsed.tournamentCategory || "";
                    if (parsed.times) {
                        state.times = parsed.times;
                        // FIX: If user has stuck '2' values, force new defaults
                        if (state.times.play === 2 || state.times.play === 5) state.times.play = 420;
                        if (state.times.break === 2 || state.times.break === 5) state.times.break = 105;
                        if (state.times.setup === 2 || state.times.setup === 5) state.times.setup = 10;
                    }
                    if (parsed.teams) state.teams = parsed.teams;
                    if (parsed.teamLogos) state.teamLogos = parsed.teamLogos;
                    if (parsed.teamAnthems) state.teamAnthems = parsed.teamAnthems;
                    if (typeof parsed.volSignal !== 'undefined') state.volSignal = parsed.volSignal;
                    if (typeof parsed.volAnthem !== 'undefined') state.volAnthem = parsed.volAnthem;
                    if (parsed.referees) state.referees = parsed.referees;
                    if (parsed.players) state.players = parsed.players;
                    if (parsed.masterPlayers) state.masterPlayers = parsed.masterPlayers;
                    if (parsed.schedule) state.schedule = parsed.schedule;
                    if (parsed.audioData) state.audioData = parsed.audioData;
                    if (parsed.theme) state.theme = parsed.theme;
                    if (typeof parsed.musicAutoEnabled !== 'undefined') state.musicAutoEnabled = parsed.musicAutoEnabled;
                    if (parsed.musicMode) state.musicMode = parsed.musicMode;
                    if (typeof parsed.musicFadeDuration !== 'undefined') state.musicFadeDuration = parsed.musicFadeDuration;
                    if (parsed.musicPlaylistOrder) state.musicPlaylistOrder = parsed.musicPlaylistOrder;
                    if (parsed.musicAutoChangeStrategy) state.musicAutoChangeStrategy = parsed.musicAutoChangeStrategy;
                    if (typeof parsed.activeMatchIndex !== 'undefined') state.activeMatchIndex = parsed.activeMatchIndex;
                    if (parsed.currentMatch) state.currentMatch = parsed.currentMatch;
                    if (parsed.timer) state.timer = parsed.timer;
                    if (parsed.jingleMode) state.jingleMode = parsed.jingleMode;
                    if (parsed.misc && parsed.misc.length > 0) {
                        state.misc = parsed.misc;
                    }
                    if (typeof parsed.qrCyclingEnabled !== 'undefined') state.qrCyclingEnabled = parsed.qrCyclingEnabled;
                    if (parsed.qrCyclingInterval) state.qrCyclingInterval = parsed.qrCyclingInterval;
                    if (parsed.qrTransitionDuration) state.qrTransitionDuration = parsed.qrTransitionDuration;

                    // Metadata
                    if (parsed.tournamentDate) state.tournamentDate = parsed.tournamentDate;
                    if (parsed.tournamentLocation) state.tournamentLocation = parsed.tournamentLocation;
                    if (parsed.tournamentOrganizer) state.tournamentOrganizer = parsed.tournamentOrganizer;
                    if (parsed.pitchSize) state.pitchSize = parsed.pitchSize;
                    if (parsed.officialChiefReferee) state.officialChiefReferee = parsed.officialChiefReferee;
                    if (parsed.officialTimekeeper) state.officialTimekeeper = parsed.officialTimekeeper;
                    if (parsed.officialRecorder) state.officialRecorder = parsed.officialRecorder;

                    const migrateOfficial = (val) => {
                        if (typeof val === 'string' && val.trim()) {
                            const p = val.trim().split(' ');
                            return { surname: p[0], firstName: p.slice(1).join(' ') };
                        }
                        if (val && typeof val === 'object' && (val.surname || val.firstName)) return val;
                        return { surname: "", firstName: "" };
                    };
                    state.officialChiefReferee = migrateOfficial(state.officialChiefReferee);
                    state.officialTimekeeper = migrateOfficial(state.officialTimekeeper);
                    state.officialRecorder = migrateOfficial(state.officialRecorder);

                    // Migrate referees
                    state.referees.forEach(r => {
                        if (r.name && !r.surname && !r.firstName) {
                            const p = r.name.trim().split(' ');
                            r.surname = p[0];
                            r.firstName = p.slice(1).join(' ');
                            delete r.name;
                        }
                    });
                    if (parsed.cloudFileId) state.cloudFileId = parsed.cloudFileId;

                    // Fallback to default if empty or only empty rows exist
                    const hasData = state.misc && state.misc.some(m => m.text && m.text.trim().length > 0);
                    if (!hasData) {
                        state.misc = [
                            { id: "misc_default_1", text: "Startovn√© dru≈æstev bylo uhrazeno. N√°hrady rozhodƒç√≠m byly vyplaceny podle STS ƒåSC." }
                        ];
                    }

                    if (typeof parsed.tournamentStartTime !== 'undefined') state.tournamentStartTime = parsed.tournamentStartTime;
                    if (typeof parsed.playTimeAccumulated !== 'undefined') state.playTimeAccumulated = parsed.playTimeAccumulated;

                    admin.updateSettingsUI();

                    // MIGRATION: Strings -> Objects with IDs
                    if (state.teams.length > 0 && typeof state.teams[0] === 'string') {
                        const teamMap = {};
                        const oldTeamsArr = [...state.teams];
                        state.teams = oldTeamsArr.map((name, i) => {
                            const id = "team_legacy_" + i;
                            teamMap[name] = id;
                            return { id, name };
                        });
                        // Migrate logos/anthems
                        const newLogos = {};
                        const newAnthems = {};
                        Object.keys(state.teamLogos).forEach(oldName => {
                            if (teamMap[oldName]) newLogos[teamMap[oldName]] = state.teamLogos[oldName];
                        });
                        Object.keys(state.teamAnthems).forEach(oldName => {
                            if (teamMap[oldName]) newAnthems[teamMap[oldName]] = state.teamAnthems[oldName];
                        });
                        state.teamLogos = newLogos;
                        state.teamAnthems = newAnthems;
                        // Migrate schedule references
                        state.schedule.forEach(m => {
                            if (teamMap[m.home]) m.home = teamMap[m.home];
                            if (teamMap[m.guest]) m.guest = teamMap[m.guest];
                        });
                        // Migrate current match
                        if (teamMap[state.currentMatch.homeName]) state.currentMatch.homeName = teamMap[state.currentMatch.homeName];
                        if (teamMap[state.currentMatch.guestName]) state.currentMatch.guestName = teamMap[state.currentMatch.guestName];
                    }

                    if (state.referees.length > 0 && typeof state.referees[0] === 'string') {
                        const refMap = {};
                        const oldRefsArr = [...state.referees];
                        state.referees = oldRefsArr.map((name, i) => {
                            const id = "ref_legacy_" + i;
                            refMap[name] = id;
                            return { id, name };
                        });
                        // Migrate schedule
                        state.schedule.forEach(m => {
                            if (refMap[m.referee]) m.referee = refMap[m.referee];
                        });
                        // Migrate current
                        if (refMap[state.currentMatch.referee]) state.currentMatch.referee = refMap[state.currentMatch.referee];
                    }
                }

                admin.renderIdentityInputs();

                // Keyboard Selection Listeners
                window.addEventListener('keydown', (e) => {
                    if (e.shiftKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                        // Don't scroll if we are in the list
                        if (state.selectedIndices.length === 0) {
                            admin.toggleSelection(0, false);
                        } else {
                            const last = state.selectedIndices[state.selectedIndices.length - 1];
                            const next = last + (e.key === 'ArrowUp' ? -1 : 1);
                            if (next >= 0 && next < state.schedule.length) {
                                e.preventDefault();
                                admin.toggleSelection(next, true);
                            }
                        }
                    }
                });

                // Deselect on click outside match items
                const schedContent = document.getElementById('acc-schedule');
                if (schedContent) {
                    schedContent.addEventListener('click', (e) => {
                        // If click is directly on the accordion content or the list (not on items or toolbar buttons)
                        const target = e.target;
                        const isMatchItem = target.closest('.match-item');
                        const isToolbar = target.closest('.schedule-toolbar');
                        const isForm = target.closest('#sched-form-container');

                        if (!isMatchItem && !isToolbar && !isForm) {
                            admin.deselectAll();
                        }
                    });
                }

                admin.updateSettingsUI();
                jingles.list();

                state.isLoading = false;

                ui.updateFooterVisibility();

                const elAutoChange = document.getElementById('input-music-auto-change');
                if (elAutoChange) elAutoChange.value = state.musicAutoChangeStrategy || 'continuous';

                const volSlider = document.getElementById('input-vol-music');
                if (volSlider) volSlider.value = state.volMusic || 0.5;

                const elVolDisp = document.getElementById('vol-music-disp');
                if (elVolDisp) elVolDisp.innerText = Math.round((state.volMusic || 0.5) * 100);

                admin.renderLogoSettings();
                ui.fillSelects();
                ui.renderSchedule();
                ui.updateProjection();
                game.resetTimer();

                ui.updateDurationHints(); // INIT DURATION HINTS

                // Init music handle if exists
                if (typeof music !== 'undefined' && music.getHandle) {
                    music.getHandle().then(h => {
                        if (h) {
                            directoryHandle = h;
                            music.listTracks();
                            const mList = document.getElementById('music-list');
                            if (mList) mList.innerHTML = `<li style="color:#4caf50; font-size:0.8em; text-align:center; padding:10px;">Slo≈æka nalezena.</li>`;
                        }
                    });
                }

                // Ensure Rules are locked on load
                const lockToggle = document.getElementById('rule-lock-toggle');
                if (lockToggle) {
                    lockToggle.checked = false;
                    admin.toggleRulesLock();
                }

                state.isLoading = false;
            },

            openPublicView: (view) => {
                const url = window.location.origin + window.location.pathname + '?view=' + view + '&session=' + state.sessionId;
                window.open(url, "ScoreboardView_" + view + "_" + state.sessionId, "width=1000,height=700");
            },

            openQRWindow: (v = null) => {
                const baseUrl = window.location.origin + window.location.pathname;
                let url = baseUrl + '?projection&mode=qr&session=' + state.sessionId;
                if (v) url += '&view=' + v;
                qrWindow = window.open(url, "ScoreboardQR_" + (v || "proj") + "_" + state.sessionId, "width=600,height=600");
                if (!qrWindow) alert("Vyskakovac√≠ okno bylo zablokov√°no.");
            },

            openAllQRWindow: () => {
                const baseUrl = window.location.origin + window.location.pathname;
                const url = baseUrl + '?projection&mode=qr-all&session=' + state.sessionId;
                qrWindow = window.open(url, "ScoreboardQR_ALL_" + state.sessionId, "width=1000,height=900");
                if (!qrWindow) alert("Vyskakovac√≠ okno bylo zablokov√°no.");
            },
        };




        const exporter = {
            resolveName: (id, type) => {
                if (!id) return "-";
                if (type === 'ref') return admin.getRefName(id, true);
                const team = state.teams.find(item => item.id === id);
                return team ? team.name : id;
            },
            toXLSX: () => {
                const wb = XLSX.utils.book_new();

                // --- Metadata Header for Excel ---
                const metaRows = [
                    [state.tournamentName || "Turnajov√Ω rozpis"],
                    ["Kategorie:", state.tournamentCategory || "-"],
                    ["Po≈ôadatel:", state.tournamentOrganizer || "-"],
                    ["Datum:", state.tournamentDate ? new Date(state.tournamentDate).toLocaleDateString('cs-CZ') : "-"],
                    ["M√≠sto:", state.tournamentLocation || "-"],
                    ["Plocha:", state.pitchSize || "-"],
                    ["Hlavn√≠ rozhodƒç√≠:", admin.getRefName(state.officialChiefReferee, true)],
                    ["ƒåasomƒõ≈ôiƒç:", admin.getRefName(state.officialTimekeeper, true)],
                    ["Zapisovatel:", admin.getRefName(state.officialRecorder, true)],
                    ["Pravidla (V/R/P):", `${state.rules.winPoints}/${state.rules.drawPoints}/${state.rules.lossPoints}`],
                    ["Minitabulky:", state.rules.useMiniTables ? "Ano" : "Ne"],
                    ["ƒåasy (Hra/P≈ôest./√ökl.):", `${state.times.play}/${state.times.break}/${state.times.setup}`],
                    ["Exportov√°no:", new Date().toLocaleString('cs-CZ')],
                    [] // divider row
                ];

                const scheduleData = state.schedule.map((m, i) => {
                    return {
                        "Po≈ôad√≠": i + 1,
                        "N√°zev / Skupina": m.title || "Match",
                        "Dom√°c√≠ dru≈æstvo": m.type === 'match' ? exporter.resolveName(m.home, 'team') : "-",
                        "Hostuj√≠c√≠ dru≈æstvo": m.type === 'match' ? exporter.resolveName(m.guest, 'team') : "-",
                        "Sk√≥re": m.type === 'match' ? (m.homeScore !== null ? `${m.homeScore}:${m.guestScore}` : "-") : "-",
                        "Rozhodƒç√≠": m.type === 'match' ? exporter.resolveName(m.referee, 'ref') : "-",
                        "D√©lka (s)": m.duration || (m.type === 'match' ? (state.times.play * 2 + state.times.break) : 600)
                    };
                });

                const ws = XLSX.utils.aoa_to_sheet(metaRows);
                XLSX.utils.sheet_add_json(ws, scheduleData, { origin: "A13" });
                XLSX.utils.book_append_sheet(wb, ws, "Rozpis");

                const filename = (state.tournamentName || "Export") + " (OmS).xlsx";

                // --- SECTIONS APPENDING ---

                // 0. Standings
                const standings = admin.calculateStandings();
                const standingsStartRow = 13 + scheduleData.length + 2;
                const standingsData = [["TABULKA TURNAJE", "Z", "V", "R", "P", "Sk√≥re", "Rozd√≠l", "Body"]];
                standings.forEach(s => {
                    standingsData.push([s.name, s.gp, s.w, s.d, s.l, `${s.gf}:${s.ga}`, s.gd, s.pts]);
                });
                XLSX.utils.sheet_add_aoa(ws, standingsData, { origin: "A" + standingsStartRow });

                // 1. Referees
                const refStartRow = standingsStartRow + standingsData.length + 2;
                const refData = [["SBOR ROZHODƒå√çCH"]];
                state.referees.forEach(r => refData.push([admin.getRefName(r.id, true)]));
                XLSX.utils.sheet_add_aoa(ws, refData, { origin: "A" + refStartRow });

                // 2. Rosters (Teams + Players)
                const rosterStartRow = refStartRow + refData.length + 2;
                const rosterData = [["SOUPISKY DRU≈ΩSTEV", "Hr√°ƒç 1", "UCI-ID 1", "Hr√°ƒç 2", "UCI-ID 2"]];
                state.teams.forEach(t => {
                    const idx1 = t.playerIds && t.playerIds[0];
                    const idx2 = t.playerIds && t.playerIds[1];
                    const p1 = idx1 ? state.players.find(p => p.id === idx1) : null;
                    const p2 = idx2 ? state.players.find(p => p.id === idx2) : null;
                    rosterData.push([
                        t.name,
                        p1 ? `${p1.surname} ${p1.firstName}` : "",
                        p1 ? p1.uciId : "",
                        p2 ? `${p2.surname} ${p2.firstName}` : "",
                        p2 ? p2.uciId : ""
                    ]);
                });
                XLSX.utils.sheet_add_aoa(ws, rosterData, { origin: "A" + rosterStartRow });

                // 3. Misc
                const miscStartRow = rosterStartRow + rosterData.length + 2;
                const miscData = [["R≈ÆZN√â"]];
                state.misc.forEach(m => {
                    if (m.text) miscData.push([m.text]);
                });
                XLSX.utils.sheet_add_aoa(ws, miscData, { origin: "A" + miscStartRow });

                XLSX.writeFile(wb, filename);
            },
            toPrintable: () => {
                const win = window.open('', '_blank');
                let html = `<html><head><title>${state.tournamentName || "Turnaj"} (OmS)</title>
                <style>
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 40px; color: #333; line-height: 1.6; }
                    table { width: 100%; border-collapse: collapse; margin-top: 30px; box-shadow: 0 2px 3px rgba(0,0,0,0.1); }
                    th, td { border: 1px solid #ddd; padding: 12px 15px; text-align: left; }
                    th { background-color: #f8f9fa; color: #333; font-weight: bold; text-transform: uppercase; font-size: 0.8em; letter-spacing: 1px; }
                    tr:nth-child(even) { background-color: #fcfcfc; }
                    h1 { color: #1a73e8; margin-bottom: 5px; }
                    .meta { color: #666; font-size: 0.9em; margin-bottom: 30px; }
                    .event-row { background-color: #fff9c4 !important; font-style: italic; color: #555; text-align: center; font-weight: 500; }
                    @media print {
                        body { padding: 0; }
                        table { box-shadow: none; border-color: #000; }
                        th { background-color: #eee !important; -webkit-print-color-adjust: exact; }
                        .event-row { background-color: #ffffdd !important; -webkit-print-color-adjust: exact; }
                    }
                </style></head><body>`;

                html += `<h1>${state.tournamentName || "Turnajov√Ω rozpis"}</h1>`;
                html += `<div class="meta" style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:30px; background:#f9f9f9; padding:15px; border-radius:8px; border:1px solid #eee;">
                    <div>
                        <strong>Kategorie:</strong> ${state.tournamentCategory || "-"}<br>
                        <strong>Po≈ôadatel:</strong> ${state.tournamentOrganizer || "-"}<br>
                        <strong>Datum:</strong> ${state.tournamentDate ? new Date(state.tournamentDate).toLocaleDateString('cs-CZ') : "-"}<br>
                        <strong>M√≠sto:</strong> ${state.tournamentLocation || "-"}<br>
                        <strong>Plocha:</strong> ${state.pitchSize || "-"}
                    </div>
                    <div>
                        <strong>Hlavn√≠ rozhodƒç√≠:</strong> ${admin.getRefName(state.officialChiefReferee, true) || "-"}<br>
                        <strong>ƒåasomƒõ≈ôiƒç:</strong> ${admin.getRefName(state.officialTimekeeper, true) || "-"}<br>
                        <strong>Zapisovatel:</strong> ${admin.getRefName(state.officialRecorder, true) || "-"}
                    </div>
                    
                    <div style="grid-column: span 2; margin-top:10px; padding:10px; background:#f1f1f1; border-radius:4px; font-size:0.85em; display:flex; gap:30px; border: 1px solid #ddd;">
                        <div><strong>Bodov√°n√≠:</strong> V√Ωhra ${state.rules.winPoints} / Rem√≠za ${state.rules.drawPoints} / Prohra ${state.rules.lossPoints}</div>
                        <div><strong>Minitabulky:</strong> ${state.rules.useMiniTables ? "Ano" : "Ne"}</div>
                        <div><strong>ƒåasy:</strong> Hra ${Math.floor(state.times.play / 60)}:${(state.times.play % 60).toString().padStart(2, '0')} | P≈ôest√°vka ${Math.floor(state.times.break / 60)}:${(state.times.break % 60).toString().padStart(2, '0')}</div>
                    </div>

                    <div style="grid-column: span 2; margin-top:5px; padding-top:5px; border-top:1px solid #ddd; font-size:0.8em; color:#888;">
                        Exportov√°no: ${new Date().toLocaleString('cs-CZ')}
                    </div>
                </div>`;

                // --- NEW: Referee List ---
                if (state.referees.length > 0) {
                    html += `<h2 style="margin-top:20px;">Sbor rozhodƒç√≠ch</h2>`;
                    html += `<ul style="list-style-type:none; padding:0; display:flex; flex-wrap:wrap; gap:15px;">`;
                    state.referees.forEach(r => {
                        html += `<li style="background:#f1f1f1; padding:5px 10px; border-radius:4px;">${admin.getRefName(r, true)}</li>`;
                    });
                    html += `</ul>`;
                }

                // --- NEW: Team Roster Table ---
                if (state.teams.length > 0) {
                    html += `<h2 style="margin-top:20px;">Soupisky dru≈æstev</h2>`;
                    html += `<table style="margin-top:10px;"><thead><tr>
                        <th style="width:40px">#</th>
                        <th>Dru≈æstvo</th>
                        <th>Hr√°ƒç 1</th>
                        <th style="width:100px">UCI-ID 1</th>
                        <th>Hr√°ƒç 2</th>
                        <th style="width:100px">UCI-ID 2</th>
                    </tr></thead><tbody>`;
                    state.teams.forEach((t, i) => {
                        const p1Id = (t.playerIds && t.playerIds[0]) ? t.playerIds[0] : null;
                        const p2Id = (t.playerIds && t.playerIds[1]) ? t.playerIds[1] : null;
                        const p1 = p1Id ? state.players.find(x => x.id === p1Id) : null;
                        const p2 = p2Id ? state.players.find(x => x.id === p2Id) : null;

                        html += `<tr>
                            <td>${i + 1}</td>
                            <td style="font-weight:bold">${t.name}</td>
                            <td>${p1 ? `${p1.surname} ${p1.firstName}` : "-"}</td>
                            <td style="font-size:0.9em;">${p1 ? (p1.uciId || "-") : "-"}</td>
                            <td>${p2 ? `${p2.surname} ${p2.firstName}` : "-"}</td>
                            <td style="font-size:0.9em;">${p2 ? (p2.uciId || "-") : "-"}</td>
                        </tr>`;
                    });
                    html += `</tbody></table>`;
                }

                html += `<h2 style="margin-top:40px;">Po≈ôad√≠ z√°pas≈Ø</h2>`;
                html += `<table><thead><tr>
                    <th style="width:40px">#</th>
                    <th style="width:120px">Skupina / F√°ze</th>
                    <th>Dom√°c√≠</th>
                    <th>Host√©</th>
                    <th style="width:80px; text-align:center;">V√Ωsledek</th>
                    <th>Rozhodƒç√≠</th>
                </tr></thead><tbody>`;

                state.schedule.forEach((m, i) => {
                    if (m.type === 'match') {
                        html += `<tr>
                            <td>${i + 1}</td>
                            <td>${m.title}</td>
                            <td style="font-weight:bold">${exporter.resolveName(m.home, 'team')}</td>
                            <td style="font-weight:bold">${exporter.resolveName(m.guest, 'team')}</td>
                            <td style="text-align:center; font-family:monospace; font-weight:bold; font-size:1.1em;">
                                ${m.homeScore !== null ? `${m.homeScore}:${m.guestScore}` : "- : -"}
                            </td>
                            <td>${exporter.resolveName(m.referee, 'ref')}</td>
                        </tr>`;
                    } else {
                        html += `<tr class="event-row">
                            <td>${i + 1}</td>
                            <td>${m.title}</td>
                            <td colspan="4">UD√ÅLOST / P≈òEST√ÅVKA (${Math.floor(m.duration / 60)} min)</td>
                        </tr>`;
                    }
                });

                html += `</tbody></table>`;

                if (state.teams.length > 0) {
                    html += `<h2 style="margin-top:50px; page-break-before:always;">K≈ô√≠≈æov√° tabulka v√Ωsledk≈Ø</h2>`;
                    html += `<table style="font-size:0.8em; text-align:center;"><thead style="background:#eee;"><tr>
                        <th style="width:30px">#</th>
                        <th style="text-align:left;">Dru≈æstvo</th>`;
                    state.teams.forEach((_, i) => html += `<th style="width:30px;">${i + 1}</th>`);
                    html += `<th style="width:40px;">Body</th><th style="width:70px;">Sk√≥re</th><th style="width:30px;">M</th></tr></thead><tbody>`;

                    const standings = admin.calculateStandings();
                    const statsMap = {};
                    standings.forEach(s => statsMap[s.id] = s);

                    state.teams.forEach((tRow, i) => {
                        html += `<tr><td>${i + 1}.</td><td style="text-align:left; font-weight:bold;">${tRow.name}</td>`;
                        state.teams.forEach((tCol, j) => {
                            if (i === j) {
                                html += `<td style="background:#ddd;"></td>`;
                            } else {
                                const match = state.schedule.find(m =>
                                    m.type === 'match' &&
                                    ((m.home === tRow.id && m.guest === tCol.id) || (m.home === tCol.id && m.guest === tRow.id)) &&
                                    m.homeScore !== null && m.guestScore !== null
                                );
                                if (match) {
                                    const score = (match.home === tRow.id) ? `${match.homeScore}:${match.guestScore}` : `${match.guestScore}:${match.homeScore}`;
                                    html += `<td>${score}</td>`;
                                } else {
                                    html += `<td>-</td>`;
                                }
                            }
                        });
                        const s = statsMap[tRow.id] || { pts: 0, gf: 0, ga: 0 };
                        const rank = (standings.findIndex(st => st.id === tRow.id) + 1);
                        html += `<td style="font-weight:bold;">${s.pts}</td><td>${s.gf}:${s.ga}</td><td style="font-weight:bold; background:#f9f9f9;">${rank || "-"}</td></tr>`;
                    });
                    html += `</tbody></table>`;
                }

                const standings = admin.calculateStandings();
                if (standings.length > 0) {
                    html += `<h2 style="margin-top:50px;">Koneƒçn√© po≈ôad√≠ / Tabulka</h2>`;
                    html += `<table><thead><tr>
                        <th style="width:40px">#</th>
                        <th>Dru≈æstvo</th>
                        <th style="text-align:center; width:40px;">Z</th>
                        <th style="text-align:center; width:40px;">V</th>
                        <th style="text-align:center; width:40px;">R</th>
                        <th style="text-align:center; width:40px;">P</th>
                        <th style="text-align:center; width:60px;">Sk√≥re</th>
                        <th style="text-align:center; width:50px;">Body</th>
                    </tr></thead><tbody>`;
                    standings.forEach((s, idx) => {
                        html += `<tr>
                            <td>${idx + 1}.</td>
                            <td style="font-weight:bold;">${s.name}</td>
                            <td style="text-align:center;">${s.gp}</td>
                            <td style="text-align:center;">${s.w}</td>
                            <td style="text-align:center;">${s.d}</td>
                            <td style="text-align:center;">${s.l}</td>
                            <td style="text-align:center;">${s.gf}:${s.ga}</td>
                            <td style="text-align:center; font-weight:bold;">${s.pts}</td>
                        </tr>`;
                    });
                    html += `</tbody></table>`;
                }

                if (state.misc && state.misc.length > 0) {
                    html += `<h2 style="margin-top:50px;">R≈Øzn√©</h2>`;
                    html += `<ul style="margin-top:10px; font-size:0.9em; color:#444;">`;
                    state.misc.forEach(m => {
                        if (m.text.trim()) {
                            html += `<li style="margin-bottom:5px;">${m.text}</li>`;
                        }
                    });
                    html += `</ul>`;
                }

                html += `
                <div style="margin-top:40px; text-align:right; font-size:0.8em; color:#999;">
                    Generov√°no aplikac√≠ OmniScore
                </div>
                </body></html>`;
                win.document.write(html);
                win.document.close();
            },


        };

        function openProjectionWindow() {
            game.syncProjection();
        }


        // (End of UI Engine)

        // ===================================================================================
        // UI ENGINE
        // ===================================================================================
        const ui = {
            updateFooterVisibility: () => {
                const footer = document.getElementById('admin-footer');
                if (footer) {
                    footer.style.display = state.showFooter ? 'grid' : 'none';
                    document.body.style.paddingBottom = state.showFooter ? '55px' : '20px';
                }
            },
            updateAdminFooter: () => {
                const telemetry = game.getTelemetry();
                const prog = document.getElementById('admin-footer-progress');
                const end = document.getElementById('admin-footer-end');
                const time = document.getElementById('admin-footer-time');
                const sess = document.getElementById('admin-footer-session');
                if (prog) prog.innerText = `\u00A0\u00A0\u00A0\u00A0${telemetry.progress}`;
                if (end) end.innerText = telemetry.end;
                if (time) time.innerText = telemetry.time;
                if (sess) sess.innerText = state.sessionId;
            },
            render: () => {
                try {
                    ui.renderPhase();
                    ui.updateScores();
                    ui.updateNames();
                    ui.updateTimer();
                    ui.updateTimerBtn();
                    ui.renderSchedule();
                    ui.renderMusic();
                    ui.renderStandings();
                    ui.updateDurationHints(); // Force update hints on every render
                } catch (e) {
                    console.error("UI: Fatal error in render()", e);
                }
            },

            renderStandings: () => {
                const container = document.getElementById('standings-container');
                if (!container) return;

                // Update tab buttons style
                const btnS = document.getElementById('tab-btn-standings');
                const btnC = document.getElementById('tab-btn-cross');
                if (btnS && btnC) {
                    const activeStyle = "background: var(--accent-blue); color: #fff; transform: translateY(-1px); border: 1px solid #555;";
                    const inactiveStyle = "background: #333; color: #aaa; border: 1px solid #444;";
                    btnS.style = (state.activeStandingsTab !== 'cross') ? activeStyle : inactiveStyle;
                    btnC.style = (state.activeStandingsTab === 'cross') ? activeStyle : inactiveStyle;
                }

                if (state.activeStandingsTab === 'cross') {
                    ui.renderCrossTable(container);
                    return;
                }

                const standings = admin.calculateStandings();
                if (standings.length === 0) {
                    container.innerHTML = `<p style="text-align:center; color:#666; font-size:0.9em; padding:10px;">≈Ω√°dn√° data pro tabulku.</p>`;
                    return;
                }

                let html = `<table style="width:100%; border-collapse:collapse; font-size:0.85em; margin-top:5px;">
                    <thead><tr style="background:#222; color:#aaa; text-align:left;">
                        <th style="padding:5px;">#</th>
                        <th style="padding:5px;">Dru≈æstvo</th>
                        <th style="padding:5px; text-align:center;">Z</th>
                        <th style="padding:5px; text-align:center;">S</th>
                        <th style="padding:5px; text-align:center;">R</th>
                        <th style="padding:5px; text-align:center;">B</th>
                    </tr></thead><tbody>`;

                standings.forEach((s, i) => {
                    html += `<tr style="border-bottom:1px solid #444;">
                        <td style="padding:5px;">${i + 1}.</td>
                        <td style="padding:5px; font-weight:bold; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:120px;">${s.name}</td>
                        <td style="padding:5px; text-align:center;">${s.gp}</td>
                        <td style="padding:5px; text-align:center; color:#888;">${s.gf}:${s.ga}</td>
                        <td style="padding:5px; text-align:center; color:${s.gd > 0 ? 'var(--accent-green)' : (s.gd < 0 ? 'var(--accent-red)' : '#888')}">${s.gd > 0 ? '+' + s.gd : s.gd}</td>
                        <td style="padding:5px; text-align:center; font-weight:bold; color:var(--accent-blue);">${s.pts}</td>
                    </tr>`;
                });

                html += `</tbody></table>`;
                container.innerHTML = html;
            },

            renderCrossTable: (container) => {
                const standings = admin.calculateStandings();

                // FILTER: Use teams present in standings (which are filtered by active schedule)
                // We map IDs back to full team objects for rendering, preserving original order if possible, 
                // or just using standings order. Let's use standings order for axes? 
                // Actually, cross tables usually use a fixed order (e.g. 1st vs 2nd defined team).
                // Let's filter state.teams by IDs found in standings.
                const activeIds = new Set(standings.map(s => s.id));
                const teams = state.teams.filter(t => activeIds.has(t.id));

                if (teams.length === 0) {
                    container.innerHTML = `<p style="text-align:center; color:#666; font-size:0.9em; padding:10px;">≈Ω√°dn√° dru≈æstva pro zobrazen√≠.</p>`;
                    return;
                }

                // Map of ranks for easy lookup
                const ranks = {};
                standings.forEach((s, i) => ranks[s.id] = i + 1);

                // Map of points/goals for easy lookup
                const stats = {};
                standings.forEach(s => stats[s.id] = s);

                let html = `<div style="overflow-x:auto;"><table style="width:100%; border-collapse:collapse; font-size:0.75em; text-align:center; table-layout:fixed;">
                    <thead><tr style="background:#222; color:#aaa;">
                        <th style="padding:4px; width:25px;">#</th>
                        <th style="padding:4px; text-align:left; width:100px;">Dru≈æstvo</th>`;

                teams.forEach((t, i) => {
                    html += `<th style="padding:4px; border-left:1px solid #444;">${i + 1}</th>`;
                });

                html += `<th style="padding:4px; border-left:2px solid #555; width:30px;">B</th>
                         <th style="padding:4px; border-left:1px solid #444; width:50px;">Sk√≥re</th>
                         <th style="padding:4px; border-left:1px solid #444; width:30px;">R</th>
                         <th style="padding:4px; border-left:1px solid #444; width:30px; background:#332;">M</th>
                    </tr></thead><tbody>`;

                teams.forEach((tRow, i) => {
                    html += `<tr style="border-bottom:1px solid #444;">
                        <td style="padding:4px; color:#666;">${i + 1}</td>
                        <td style="padding:4px; text-align:left; font-weight:bold; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${tRow.name}</td>`;

                    teams.forEach((tCol, j) => {
                        let cellContent = "";
                        let cellStyle = "border-left:1px solid #444; padding:4px;";

                        if (i === j) {
                            cellStyle += "background:#111;";
                        } else {
                            // Find match between tRow and tCol
                            const match = state.schedule.find(m =>
                                m.type === 'match' &&
                                ((m.home === tRow.id && m.guest === tCol.id) || (m.home === tCol.id && m.guest === tRow.id)) &&
                                m.homeScore !== null && m.guestScore !== null
                            );

                            if (match) {
                                if (match.home === tRow.id) {
                                    cellContent = `${match.homeScore}:${match.guestScore}`;
                                } else {
                                    cellContent = `${match.guestScore}:${match.homeScore}`;
                                }
                            } else {
                                cellContent = "-";
                            }
                        }
                        html += `<td style="${cellStyle}">${cellContent}</td>`;
                    });

                    const s = stats[tRow.id] || { pts: 0, gf: 0, ga: 0 };
                    const rank = ranks[tRow.id] || "-";

                    html += `<td style="padding:4px; border-left:2px solid #555; font-weight:bold; color:var(--accent-blue);">${s.pts}</td>
                             <td style="padding:4px; border-left:1px solid #444; color:#888;">${s.gf}:${s.ga}</td>
                             <td style="padding:4px; border-left:1px solid #444; color:#aaa; font-size:0.9em;">${s.gd > 0 ? '+' + s.gd : s.gd}</td>
                             <td style="padding:4px; border-left:1px solid #444; background:#332; font-weight:bold;">${rank}.</td>
                    </tr>`;
                });

                html += `</tbody></table></div>`;
                container.innerHTML = html;
            },

            renderMusic: () => {
                const list = document.getElementById('music-list');
                const container = document.getElementById('music-controls');
                if (state.musicPlaylist.length === 0) {
                    list.innerHTML = `<li style="color:#666; font-size:0.8em; text-align:center; padding:10px;">Slo≈æka nebyla vybr√°na nebo neobsahuje MP3</li>`;
                    container.style.display = 'none';
                    return;
                }
                container.style.display = 'block';
                list.innerHTML = "";
                state.musicPlaylist.forEach((track, idx) => {
                    const li = document.createElement('li');
                    li.className = "match-item" + (idx === currentMusicIndex ? " active-match" : "");
                    li.style.display = "flex";
                    li.style.alignItems = "center";
                    li.style.padding = "5px 10px";
                    li.draggable = true;
                    li.dataset.index = idx;

                    li.innerHTML = `
                        <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; cursor:move;">${track.name}</span>
                        <span style="font-size:1.2em; cursor:pointer;" onclick="event.stopPropagation(); music.play(${idx})">${idx === currentMusicIndex && !currentMusicAudio.paused ? '‚ô´' : '‚ñ∂'}</span>
                    `;

                    // Drag & Drop
                    li.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', idx);
                        li.style.opacity = '0.5';
                    });
                    li.addEventListener('dragend', () => li.style.opacity = '1');
                    li.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        li.classList.add('drag-over');
                    });
                    li.addEventListener('dragleave', () => li.classList.remove('drag-over'));
                    li.addEventListener('drop', (e) => {
                        e.preventDefault();
                        li.classList.remove('drag-over');
                        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                        const toIdx = idx;
                        if (fromIdx !== toIdx) {
                            music.reorder(fromIdx, toIdx);
                        }
                    });

                    li.onclick = () => music.play(idx);
                    list.appendChild(li);
                });
            },

            renderPhase: () => {
                try {
                    const isEvent = state.currentMatch.isEvent;
                    const phaseControls = document.getElementById('phase-controls');
                    const eventLabel = document.getElementById('event-label');
                    const phase = state.currentMatch.phaseIndex;

                    if (isEvent) {
                        if (phaseControls) phaseControls.style.display = 'none';
                        if (eventLabel) {
                            eventLabel.style.display = 'block';
                            eventLabel.textContent = state.currentMatch.title;
                        }
                        // Hide score controls for events
                        const hp = document.getElementById('home-team-panel');
                        const gp = document.getElementById('guest-team-panel');
                        if (hp) hp.style.visibility = 'hidden';
                        if (gp) gp.style.visibility = 'hidden';
                    } else {
                        if (phaseControls) phaseControls.style.display = 'flex';
                        if (eventLabel) eventLabel.style.display = 'none';

                        const buttons = document.querySelectorAll('.phase-btn');
                        buttons.forEach(btn => {
                            const bPhase = parseInt(btn.dataset.phase);
                            const isActive = (bPhase === phase);
                            btn.classList.toggle('active', isActive);
                        });

                        // Show score controls for matches
                        const hp = document.getElementById('home-team-panel');
                        const gp = document.getElementById('guest-team-panel');
                        if (hp) hp.style.visibility = 'visible';
                        if (gp) gp.style.visibility = 'visible';
                    }
                    ui.updateMatchInfo();
                } catch (e) {
                    console.error("UI: Error in renderPhase", e);
                }
            },

            updateMatchInfo: () => {
                const infoDiv = document.getElementById('match-info-display');
                if (state.activeMatchIndex > -1 && state.schedule[state.activeMatchIndex]) {
                    const m = state.schedule[state.activeMatchIndex];
                    let html = `<div style="font-weight:bold;">${state.activeMatchIndex + 1}. ${m.title || ""}</div>`;

                    const refName = admin.getRefName(m.referee);
                    if (refName && refName !== "-") {
                        html += `<div style="font-size: 0.8em; font-weight: normal; font-style: italic; margin-top: 2px;">${refName}</div>`;
                    }
                    infoDiv.innerHTML = html;
                } else {
                    infoDiv.innerHTML = `<div style="font-weight:bold;">${state.tournamentName || "Z√°pas"}</div>`;
                }
            },



            updateDurationHints: () => {
                try {
                    const ids = ['time-play', 'time-break', 'time-setup'];
                    ids.forEach(id => {
                        const input = document.getElementById(id);
                        const hint = document.getElementById(`hint-${id}`);
                        if (input && hint) {
                            const val = parseInt(input.value) || 0;
                            hint.innerText = admin.formatTime(val);
                        }
                    });
                } catch (e) {
                    console.error("UI: Error updating duration hints:", e);
                }
            },

            updateScores: () => {
                document.getElementById('home-score-disp').textContent = state.currentMatch.homeScore;
                document.getElementById('guest-score-disp').textContent = state.currentMatch.guestScore;
            },

            updateNames: () => {
                document.getElementById('home-name-disp').textContent = admin.getTeamName(state.currentMatch.homeName);
                document.getElementById('guest-name-disp').textContent = admin.getTeamName(state.currentMatch.guestName);
                ui.updateLogos();
            },

            updateLogos: () => {
                const hImg = document.getElementById('home-logo-disp');
                const gImg = document.getElementById('guest-logo-disp');

                const hLogo = state.teamLogos[state.currentMatch.homeName];
                const gLogo = state.teamLogos[state.currentMatch.guestName];

                if (hLogo) {
                    hImg.src = hLogo;
                    hImg.style.opacity = '1';
                } else {
                    hImg.src = '';
                    hImg.style.opacity = '0';
                }

                if (gLogo) {
                    gImg.src = gLogo;
                    gImg.style.opacity = '1';
                } else {
                    gImg.src = '';
                    gImg.style.opacity = '0';
                }
            },

            updateTimer: () => {
                const m = Math.floor(state.timer.timeLeft / 60).toString().padStart(2, '0');
                const s = Math.floor(state.timer.timeLeft % 60).toString().padStart(2, '0');
                document.getElementById('main-timer').textContent = `${m}:${s}`;
            },

            updateTimerBtn: () => {
                const btn = document.getElementById('btn-timer-toggle');
                const tDisp = document.getElementById('main-timer');
                const up = document.getElementById('btn-time-up');
                const down = document.getElementById('btn-time-down');

                if (state.timer.running) {
                    btn.textContent = "‚è∏"; // Pause
                    btn.classList.remove('btn-green');
                    btn.classList.add('btn-yellow');
                    tDisp.contentEditable = "false";
                    if (up) up.disabled = true;
                    if (down) down.disabled = true;
                } else {
                    btn.textContent = "‚ñ∂"; // Play
                    btn.classList.remove('btn-yellow');
                    btn.classList.add('btn-green');
                    tDisp.contentEditable = "true";
                    if (up) up.disabled = false;
                    if (down) down.disabled = false;
                }
            },

            fillSelects: () => {
                // Teams
                const teamSelects = ['sched-home', 'sched-guest'];
                teamSelects.forEach(id => {
                    const sel = document.getElementById(id);
                    if (!sel) return;
                    const currentVal = sel.value;
                    sel.innerHTML = '<option value="">-- Vyber Dru≈æstvo --</option>';
                    state.teams.forEach(t => {
                        sel.innerHTML += `<option value="${t.id}">${t.name}</option>`;
                    });
                    // Only restore value if it still exists in the list or is empty
                    if (state.teams.some(t => t.id === currentVal) || currentVal === "") sel.value = currentVal;
                });

                // Referees
                const refSelects = ['sched-referee'];
                refSelects.forEach(id => {
                    const sel = document.getElementById(id);
                    if (!sel) return;
                    const currentVal = sel.value;
                    sel.innerHTML = '<option value="">-- Vyber Rozhodƒç√≠ho --</option>';
                    state.referees.forEach(r => {
                        sel.innerHTML += `<option value="${r.id}">${admin.getRefName(r.id)}</option>`;
                    });
                    if (state.referees.some(r => r.id === currentVal) || currentVal === "") sel.value = currentVal;
                });
            },

            renderSchedule: () => {
                const list = document.getElementById('match-queue');
                const form = document.getElementById('sched-form-container');
                const header = document.getElementById('sched-list-header'); // Po≈ôad√≠:

                // Move form back to safe spot (below header) before clearing
                if (form && header) {
                    header.after(form);
                }

                list.innerHTML = "";
                state.schedule.forEach((m, idx) => {
                    const li = document.createElement('li');
                    li.className = "match-item";
                    li.draggable = true;
                    li.dataset.index = idx;
                    li.title = "Dvojklik pro editaci, Ta≈æen√≠m zmƒõ≈à po≈ôad√≠";

                    // Double Click to Edit
                    li.addEventListener('dblclick', (e) => {
                        admin.editScheduleMatch(idx);
                    });

                    // Drag Events
                    li.addEventListener('dragstart', (e) => {
                        // If we are dragging an item that's part of a selection, move the whole selection
                        // If not, select just this item and move it
                        if (!state.selectedIndices.includes(idx)) {
                            // IMPORTANT: Use silent mode to avoid re-rendering and destroying the dragged element
                            admin.toggleSelection(idx, false, false, true);
                            li.classList.add('selected-match');
                        }

                        e.dataTransfer.effectAllowed = 'move';
                        // Store the indices as a JSON string
                        const data = JSON.stringify(state.selectedIndices);
                        e.dataTransfer.setData('text/plain', data);

                        // Set a drag image if multiple items are selected? (Browser default is usually fine)
                        li.style.opacity = '0.5';
                    });

                    li.addEventListener('dragend', (e) => {
                        li.style.opacity = '1';
                        // Remove drop indicator styles from all items
                        document.querySelectorAll('.match-item').forEach(item => {
                            item.classList.remove('drop-indicator-top', 'drop-indicator-bottom');
                        });
                    });

                    li.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';

                        // Remove indicators from all items first
                        document.querySelectorAll('.match-item').forEach(item => {
                            item.classList.remove('drop-indicator-top', 'drop-indicator-bottom');
                        });

                        // Calculate if mouse is in top or bottom half of item
                        const rect = li.getBoundingClientRect();
                        const relY = e.clientY - rect.top;

                        if (relY > rect.height / 2) {
                            li.classList.add('drop-indicator-bottom');
                        } else {
                            li.classList.add('drop-indicator-top');
                        }
                    });

                    li.addEventListener('dragleave', (e) => {
                        li.classList.remove('drop-indicator-top', 'drop-indicator-bottom');
                    });

                    li.addEventListener('drop', (e) => {
                        e.preventDefault();
                        li.classList.remove('drop-indicator-top', 'drop-indicator-bottom');

                        try {
                            const indices = JSON.parse(e.dataTransfer.getData('text/plain'));
                            let toIndex = idx;

                            // Calculate if we should insert AFTER the target item
                            // This allows reaching the end of the list when dropping on the bottom half of the last item
                            const rect = li.getBoundingClientRect();
                            const relY = e.clientY - rect.top;
                            if (relY > rect.height / 2) {
                                toIndex++;
                            }

                            // If it's just one index and it's same as target, do nothing
                            if (Array.isArray(indices)) {
                                admin.moveMatchesTo(indices, toIndex);
                            } else if (typeof indices === 'number') {
                                // Fallback for old single-item behavior if any
                                admin.moveMatch(indices, toIndex);
                            }
                        } catch (err) {
                            console.error("Drop error", err);
                        }
                    });

                    if (idx === state.activeMatchIndex) {
                        li.classList.add('active-match');
                    }
                    if (idx === state.pendingEditIndex) {
                        li.classList.add('editing-match');
                    }
                    if (state.selectedIndices.includes(idx)) {
                        li.classList.add('selected-match');
                    }

                    const isEvent = m.type === 'event';
                    let hasScore = (m.homeScore !== undefined && m.homeScore !== null && m.guestScore !== undefined && m.guestScore !== null);
                    let scoreDisplay = hasScore ? `${m.homeScore}:${m.guestScore}` : "-:-";

                    if (isEvent) {
                        const durMin = Math.floor((m.duration || 600) / 60);
                        li.innerHTML = `
                            <div style="flex:1; display:grid; grid-template-columns: 120px 1fr 15px 1fr 60px 1fr; align-items:center; font-size:0.85em; gap:5px; padding-right:10px; overflow:hidden;">
                                <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><b>${idx + 1}.</b> ${m.title || "Ud√°lost"}</div>
                                <div style="grid-column: 2 / 5; text-align:center; color:#aaa; white-space:nowrap;">‚è± ${durMin}m</div>
                                <div></div>
                                <div></div>
                            </div>
                        `;
                    } else {
                        li.innerHTML = `
                            <div style="flex:1; display:grid; grid-template-columns: 120px 1fr 15px 1fr 60px 1fr; align-items:center; font-size:0.85em; gap:5px; padding-right:10px; overflow:hidden;">
                                <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><b>${idx + 1}.</b> ${m.title}</div>
                                <div style="text-align:right; font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                                    ${admin.getTeamName(m.home)}
                                </div>
                                <div style="text-align:center; color:#888;">:</div>
                                <div style="text-align:left; font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                                    ${admin.getTeamName(m.guest)}
                                </div>
                                <div style="text-align:center; ${hasScore ? 'font-weight:900; color:var(--accent-green);' : 'font-weight:300; color:#fff;'}">${scoreDisplay}</div>
                                <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:#aaa; font-style:italic;">${admin.getRefName(m.referee)}</div>
                            </div>
                        `;
                    }

                    li.onclick = (e) => {
                        admin.toggleSelection(idx, e.shiftKey, e.ctrlKey);
                    };

                    list.appendChild(li);
                });

                // If editing, move form to the correct spot (below item)
                if (state.pendingEditIndex > -1 && form) {
                    const targetLi = list.querySelector(`.match-item[data-index="${state.pendingEditIndex}"]`);
                    if (targetLi) {
                        targetLi.after(form);
                    }
                }
            },

            updateMusicIndicatorState: () => {
                const btnMini = document.getElementById('btn-music-toggle-mini');
                if (btnMini) {
                    if (!currentMusicAudio.paused) {
                        btnMini.classList.add('active');
                        btnMini.innerText = '‚ô´';
                    } else {
                        btnMini.classList.remove('active');
                        btnMini.innerText = '‚ô´';
                    }
                }
                // Also update the note symbols in the music playlist list
                ui.renderMusic();
            },

            updateProjection: () => {
                try {
                    if (!state.isProjectionMode && !state.viewMode) return;

                    // Apply CSS variable for QR transition duration
                    document.body.style.setProperty('--qr-transition-duration', (state.qrTransitionDuration || 1.5) + 's');

                    const pLayout = document.getElementById('projection-layout');
                    const qrLayout = document.getElementById('qr-layout');

                    if (isQR) {
                        if (pLayout) pLayout.style.display = 'none';
                        if (qrLayout) {
                            qrLayout.style.display = 'flex';

                            // 1. Handle SINGLE QR Mode (view=...)
                            const v = urlParams.get('view');
                            const mode = urlParams.get('mode');

                            if (mode === 'qr-all') {
                                // GRID MODE
                                document.getElementById('qr-single-view').style.display = 'none';
                                document.getElementById('qr-grid-view').style.display = 'flex';
                                document.getElementById('qr-session-id-grid').innerText = state.sessionId;
                                document.getElementById('qr-tournament-name').innerText = (state.tournamentName || "OmniScore") + " - V≈°echny QR k√≥dy";
                                document.title = (state.tournamentName || "OmniScore") + " - V≈°echny QR k√≥dy";


                                const configs = [
                                    { id: 'qr-grid-projection', param: 'projection' },
                                    { id: 'qr-grid-schedule', param: 'view=schedule' },
                                    { id: 'qr-grid-standings', param: 'view=standings' },
                                    { id: 'qr-grid-cross', param: 'view=cross' }
                                ];

                                configs.forEach(cfg => {
                                    const container = document.getElementById(cfg.id);
                                    if (container && container.innerHTML.trim() === "" && !container.dataset.generated) {
                                        container.dataset.generated = "true";
                                        setTimeout(() => {
                                            try {
                                                if (typeof QRCode === 'undefined') return;
                                                const poUrl = window.location.origin + window.location.pathname + '?session=' + state.sessionId + '&' + cfg.param;
                                                new QRCode(container, {
                                                    text: poUrl,
                                                    width: 150,
                                                    height: 150,
                                                    colorDark: "#000000",
                                                    colorLight: "#ffffff",
                                                    correctLevel: QRCode.CorrectLevel.L
                                                });
                                                // Make interactive - Open as standalone window
                                                container.onclick = () => {
                                                    const winName = "ScoreboardClick_" + cfg.id + "_" + state.sessionId;
                                                    window.open(poUrl, winName, "width=1000,height=700");
                                                };
                                                container.title = "Kliknut√≠m otev≈ôete v samostatn√©m oknƒõ";
                                            } catch (err) {
                                                console.error("Grid QR Generation failed", err);
                                                delete container.dataset.generated;
                                            }
                                        }, 500);
                                    }
                                });
                            } else {
                                // SINGLE MODE
                                document.getElementById('qr-single-view').style.display = 'flex';
                                document.getElementById('qr-grid-view').style.display = 'none';

                                let viewName = "";
                                if (v === 'schedule') viewName = " - PO≈òAD√ç Z√ÅPAS≈Æ";
                                else if (v === 'standings') viewName = " - TABULKA PO≈òAD√ç";
                                else if (v === 'cross') viewName = " - TABULKA K≈ò√ç≈ΩOV√Å";
                                else if (v === 'all') viewName = " - Hub (V≈°echna zobrazen√≠)";
                                else viewName = ' - "Projekce Sk√≥re"';

                                const titleStr = (state.tournamentName || "OmniScore") + viewName;
                                document.getElementById('qr-tournament-name').innerText = titleStr;
                                document.title = titleStr;
                                document.getElementById('qr-session-id').innerText = state.sessionId;

                                // Generate single QR
                                const container = document.getElementById('qr-container');
                                const isEmpty = container && container.innerHTML.trim() === "";
                                const isGenerated = container && container.dataset.generated === "true";

                                if (container && isEmpty && !isGenerated) {
                                    container.dataset.generated = "true";
                                    setTimeout(() => {
                                        try {
                                            if (typeof QRCode === 'undefined') {
                                                delete container.dataset.generated;
                                                return;
                                            }

                                            let poUrlParams = "";
                                            if (v === 'all') poUrlParams = '&mode=qr-all';
                                            else poUrlParams = (v ? '&view=' + v : '&projection');

                                            const poUrl = window.location.origin + window.location.pathname + '?session=' + state.sessionId + poUrlParams;
                                            new QRCode(container, {
                                                text: poUrl,
                                                width: 260,
                                                height: 260,
                                                colorDark: "#000000",
                                                colorLight: "#ffffff",
                                                correctLevel: QRCode.CorrectLevel.L
                                            });
                                        } catch (err) {
                                            console.error("QR Generation failed", err);
                                            delete container.dataset.generated;
                                            container.innerHTML = "";
                                        }
                                    }, 500);
                                }
                            }
                        }
                        return;
                    }

                    if (pLayout) pLayout.style.display = 'grid';
                    if (qrLayout) qrLayout.style.display = 'none';


                    const usedState = (state.poTransitionActive && state.poTransitionData) ? state.poTransitionData : state;
                    const isBlinking = state.poTransitionActive;

                    const PHASES_LIST = ["Nastupuje", "1. Poloƒças", "P≈ôest√°vka", "2. Poloƒças"];
                    const matchData = usedState.currentMatch || { title: "Z√°pas", homeName: "Dom√°c√≠", guestName: "Host√©", homeScore: 0, guestScore: 0, phaseIndex: 0 };
                    const teamLogos = usedState.teamLogos || {};
                    const teams = usedState.teams || [];
                    const referees = usedState.referees || [];

                    const getTName = (id) => admin.getTeamName(id);
                    const getRName = (id) => admin.getRefName(id);

                    // Update Theme
                    document.body.classList.toggle('theme-dark', usedState.theme === 'dark');
                    document.body.classList.toggle('theme-light', usedState.theme !== 'dark');

                    // Update Top Row
                    const titleEl = document.getElementById('p-match-title');
                    if (titleEl) {
                        let titleHtml = `<div>${matchData.title || ""}</div>`;
                        // Only add referee if it's a match and has a referee assigned
                        if (matchData.referee && matchData.referee !== "") {
                            const refName = getRName(matchData.referee);
                            if (refName && refName !== "-") {
                                titleHtml += `<div style="font-size: 0.6em; opacity: 0.7; margin-top: 0.5vh; font-weight: 400;">${refName}</div>`;
                            }
                        }
                        titleEl.innerHTML = titleHtml;
                    }

                    const isEventMode = !!matchData.isEvent;
                    const phaseNameEl = document.getElementById('p-phase-name');
                    if (phaseNameEl) {
                        phaseNameEl.innerText = isEventMode ? "" : (PHASES_LIST[matchData.phaseIndex] || "");
                        phaseNameEl.classList.toggle('p-row-blink', isBlinking);
                    }

                    const timerEl = document.getElementById('p-timer');
                    if (timerEl) {
                        const m = Math.floor(usedState.timer.timeLeft / 60).toString().padStart(2, '0');
                        const s = Math.floor(usedState.timer.timeLeft % 60).toString().padStart(2, '0');
                        timerEl.innerText = m + ":" + s;
                    }

                    // Main View Mode (Match vs Event)
                    const matchCont = document.getElementById('p-match-content');
                    if (matchCont) matchCont.style.display = isEventMode ? 'none' : 'grid';
                    const eventCont = document.getElementById('p-event-content');
                    if (eventCont) {
                        eventCont.style.display = isEventMode ? 'flex' : 'none';
                        if (isEventMode) {
                            let title = usedState.currentMatch.title || "Ud√°lost";
                            // CSS truncation is sufficient now
                            eventCont.innerText = title;
                            eventCont.classList.toggle('p-row-blink', isBlinking);
                        }
                    }

                    if (!isEventMode) {
                        const truncate = (str, limit) => (str && str.length > limit) ? str.substring(0, limit - 3) + "..." : str;
                        const hn = document.getElementById('p-home-name');
                        if (hn) hn.innerText = truncate(getTName(matchData.homeName), 20);
                        const gn = document.getElementById('p-guest-name');
                        if (gn) gn.innerText = truncate(getTName(matchData.guestName), 20);
                        const hs = document.getElementById('p-home-score');
                        if (hs) hs.innerText = matchData.homeScore;
                        const gs = document.getElementById('p-guest-score');
                        if (gs) gs.innerText = matchData.guestScore;

                        const scoreBox = document.getElementById('p-score-box');
                        if (scoreBox) scoreBox.classList.toggle('p-row-blink', isBlinking);

                        const hi = document.getElementById('p-home-logo');
                        if (hi) {
                            const hl = teamLogos[matchData.homeName];
                            if (hl) { hi.src = hl; hi.style.opacity = '1'; } else { hi.src = ''; hi.style.opacity = '0'; }
                        }
                        const gi = document.getElementById('p-guest-logo');
                        if (gi) {
                            const gl = teamLogos[matchData.guestName];
                            if (gl) { gi.src = gl; gi.style.opacity = '1'; } else { gi.src = ''; gi.style.opacity = '0'; }
                        }
                    }

                    // Upcoming Matches
                    const upcomingBody = document.getElementById('p-upcoming-body');
                    if (upcomingBody) {
                        upcomingBody.innerHTML = "";
                        const nextItems = (usedState.schedule || []).slice(usedState.activeMatchIndex + 1, usedState.activeMatchIndex + 5);
                        nextItems.forEach((match, idx) => {
                            const tr = document.createElement('tr');
                            tr.className = 'p-sched-row';
                            const isItemEvent = match.type === 'event';

                            if (isItemEvent) {
                                const durMin = Math.floor((match.duration || 600) / 60);
                                tr.innerHTML = `
                                    <td class="p-sched-col-match">${usedState.activeMatchIndex + 1 + idx + 1}. ${match.title || "Ud√°lost"}</td>
                                    <td class="p-sched-col-teams" style="text-align:center; color:var(--accent-blue);">
                                        <div style="font-weight:900; letter-spacing:1px; text-transform:uppercase;">‚è± ${durMin} min</div>
                                    </td>
                                    <td class="p-sched-col-refs"></td>
                                `;
                            } else {
                                const hLogo = teamLogos[match.home];
                                const gLogo = teamLogos[match.guest];

                                tr.innerHTML = `
                                    <td class="p-sched-col-match">${usedState.activeMatchIndex + 1 + idx + 1}. ${match.title || "Z√°pas"}</td>
                                    <td class="p-sched-col-teams">
                                        <div class="p-teams-flex">
                                            <div class="p-teams-side-home">
                                                <span>${getTName(match.home)}</span>
                                                <img src="${hLogo || ''}" class="p-mini-logo" style="opacity:${hLogo ? '1' : '0'}">
                                            </div>
                                            <div class="p-teams-sep">:</div>
                                            <div class="p-teams-side-guest">
                                                <img src="${gLogo || ''}" class="p-mini-logo" style="opacity:${gLogo ? '1' : '0'}">
                                                <span>${getTName(match.guest)}</span>
                                            </div>
                                        </div>
                                    </td>
                                    <td class="p-sched-col-refs">${getRName(match.referee)}</td>
                                `;
                            }
                            upcomingBody.appendChild(tr);
                        });
                    }

                    // Footer Visibility & Telemetry
                    const footer = document.getElementById('p-row-footer');
                    const layout = document.getElementById('projection-layout');
                    if (footer && layout) {
                        const fv = (usedState.showFooter !== false);
                        footer.style.display = fv ? 'grid' : 'none';
                        layout.style.gridTemplateRows = fv ? '18vh 48vh 30vh 4vh' : '18vh 48vh 34vh 0vh';

                        if (usedState.telemetry) {
                            const progEl = document.getElementById('p-footer-progress');
                            if (progEl) progEl.innerText = usedState.telemetry.progress;
                            const endEl = document.getElementById('p-footer-end');
                            if (endEl) endEl.innerText = usedState.telemetry.end;
                            // Time is updated locally by setInterval in game.init for smoother experience
                        }
                    }
                    // Final consistency check
                    const existingLayout = document.getElementById('projection-layout');
                    if (existingLayout) {
                        console.log("UI: layout height", existingLayout.offsetHeight, "rows", existingLayout.style.gridTemplateRows);
                    }
                    // If we are in specific PUBLIC VIEW mode, call specialized renderers
                    if (state.viewMode === 'schedule') ui.renderScheduleView();
                    if (state.viewMode === 'standings') ui.renderStandingsView();
                    if (state.viewMode === 'cross') ui.renderCrossView();

                    // --- QR CYCLING LOGIC (Projection Bottom Row) ---
                    if (!state.viewMode && state.isProjectionMode) {
                        if (state.qrCyclingEnabled) {
                            if (!ui.qrCycleIntervalID || ui.qrCycleCurrentInterval !== state.qrCyclingInterval) {
                                if (ui.qrCycleIntervalID) clearInterval(ui.qrCycleIntervalID);
                                ui.qrCycleCurrentInterval = state.qrCyclingInterval;

                                // Start immediately on first enablement
                                if (!ui.qrCycleIntervalID) {
                                    state.qrCyclingActive = true;
                                }

                                ui.qrCycleIntervalID = setInterval(() => {
                                    state.qrCyclingActive = !state.qrCyclingActive;
                                    ui.updateProjection();
                                }, (state.qrCyclingInterval || 8) * 1000);
                            }
                        } else {
                            if (ui.qrCycleIntervalID) {
                                clearInterval(ui.qrCycleIntervalID);
                                ui.qrCycleIntervalID = null;
                            }
                            state.qrCyclingActive = false;
                        }

                        const upcomingCont = document.getElementById('p-upcoming-container');
                        const qrProjCont = document.getElementById('p-qr-projection-container');

                        if (upcomingCont && qrProjCont) {
                            if (state.qrCyclingActive) {
                                // Generate QR codes if showing the QR container
                                const configs = [
                                    { id: 'p-qr-grid-projection', param: 'projection' },
                                    { id: 'p-qr-grid-schedule', param: 'view=schedule' },
                                    { id: 'p-qr-grid-standings', param: 'view=standings' },
                                    { id: 'p-qr-grid-cross', param: 'view=cross' }
                                ];

                                configs.forEach(cfg => {
                                    const container = document.getElementById(cfg.id);
                                    if (container && container.innerHTML.trim() === "" && !container.dataset.generated) {
                                        container.dataset.generated = "true";
                                        try {
                                            if (typeof QRCode === 'undefined') return;
                                            const poUrl = window.location.origin + window.location.pathname + '?session=' + state.sessionId + '&' + cfg.param;
                                            new QRCode(container, {
                                                text: poUrl,
                                                width: 120,
                                                height: 120,
                                                colorDark: "#000000",
                                                colorLight: "#ffffff",
                                                correctLevel: QRCode.CorrectLevel.L
                                            });
                                        } catch (err) {
                                            console.error("Projection QR Generation failed", err);
                                            delete container.dataset.generated;
                                        }
                                    }
                                });

                                if (qrProjCont.style.display === 'none') {
                                    upcomingCont.style.opacity = '0';
                                    setTimeout(() => {
                                        if (state.qrCyclingActive) {
                                            upcomingCont.style.display = 'none';
                                            qrProjCont.style.display = 'flex';
                                            setTimeout(() => { qrProjCont.style.opacity = '1'; }, 50);
                                        }
                                    }, (state.qrTransitionDuration || 1.5) * 1000);
                                }
                            } else {
                                if (upcomingCont.style.display === 'none') {
                                    qrProjCont.style.opacity = '0';
                                    setTimeout(() => {
                                        if (!state.qrCyclingActive) {
                                            qrProjCont.style.display = 'none';
                                            upcomingCont.style.display = 'block';
                                            setTimeout(() => { upcomingCont.style.opacity = '1'; }, 50);
                                        }
                                    }, (state.qrTransitionDuration || 1.5) * 1000);
                                }
                            }
                        }
                    }

                } catch (err) {
                    console.error("UI Update Error:", err);
                }
            },

            renderScheduleView: () => {
                try {
                    const body = document.getElementById('pv-sched-body');
                    if (!body) return;
                    const prefix = state.tournamentName ? (state.tournamentName + " - ") : "";
                    const titleStr = prefix + "PO≈òAD√ç Z√ÅPAS≈Æ";
                    const tName = document.getElementById('pv-sched-tournament-name');
                    if (tName) tName.innerText = titleStr;
                    document.title = titleStr;

                    const teams = state.teams || [];
                    const referees = state.referees || [];
                    const getTName = (id) => admin.getTeamName(id);
                    const getRName = (id) => admin.getRefName(id);

                    body.innerHTML = "";
                    (state.schedule || []).forEach((match, idx) => {
                        const tr = document.createElement('tr');

                        const isFinished = (match.homeScore !== undefined && match.homeScore !== null);
                        if (idx === state.activeMatchIndex) tr.className = 'active';

                        const isEvent = match.type === 'event';
                        if (isEvent) {
                            tr.innerHTML = `
                            <td>${idx + 1}</td>
                            <td colspan="3" style="color:var(--accent-blue); font-weight:700; text-transform:uppercase; text-align:center;">‚òï ${match.title || "Ud√°lost"}</td>
                            <td>-</td>
                        `;
                        } else {
                            const hLogo = state.teamLogos[match.home];
                            const gLogo = state.teamLogos[match.guest];
                            const scoreText = (match.homeScore !== undefined && match.homeScore !== null)
                                ? (match.homeScore + ' : ' + match.guestScore)
                                : '- : -';

                            tr.innerHTML = `
                            <td>${idx + 1}</td>
                            <td style="font-size: 0.9em; color: #aaa;">${match.title || "Z√°pas"}</td>
                            <td>
                                <div class="pv-team-cell">
                                    <div style="flex:1; text-align:right;">${getTName(match.home)}</div>
                                    <img src="${hLogo || ''}" class="pv-logo" style="opacity:${hLogo ? '1' : '0'}">
                                    <div style="font-weight:900;">:</div>
                                    <img src="${gLogo || ''}" class="pv-logo" style="opacity:${gLogo ? '1' : '0'}">
                                    <div style="flex:1; text-align:left;">${getTName(match.guest)}</div>
                                </div>
                            </td>
                            <td class="pv-score-cell ${isFinished ? 'played-score' : ''}" style="text-align:center;">${scoreText}</td>
                            <td>${getRName(match.referee)}</td>
                        `;
                        }
                        body.appendChild(tr);
                    });
                    if (tName) tName.innerText = titleStr;
                    document.title = titleStr;
                } catch (err) {
                    console.error("renderScheduleView Error:", err);
                }
            },

            renderStandingsView: () => {
                try {
                    const prefix = state.tournamentName ? (state.tournamentName + " - ") : "";
                    const titleStr = prefix + "TABULKA PO≈òAD√ç";
                    document.title = titleStr;
                    const tEl = document.getElementById('pv-stand-title');
                    if (tEl) tEl.innerText = titleStr;
                    const body = document.getElementById('pv-stand-body');
                    if (!body) return;

                    // Calculate standings (ensure we have latest data)
                    const standings = admin.calculateStandings();
                    body.innerHTML = "";
                    standings.forEach((s, idx) => {
                        const tr = document.createElement('tr');
                        const logo = state.teamLogos[s.id];
                        const diffColor = s.gd > 0 ? '#4caf50' : (s.gd < 0 ? '#f44336' : '#888');
                        const diffSign = s.gd > 0 ? '+' : '';

                        tr.innerHTML = `
                        <td class="col-rank">${idx + 1}.</td>
                        <td>
                            <div class="pv-team-cell">
                                <img src="${logo || ''}" class="pv-logo" style="opacity:${logo ? '1' : '0'}">
                                <span style="font-weight:bold;">${s.name}</span>
                            </div>
                        </td>
                        <td class="col-pts">${s.gp}</td>
                        <td class="col-pts" style="color:var(--accent-blue); font-weight:900;">${s.pts}</td>
                        <td class="col-score" style="color:#aaa;">${s.gf}:${s.ga}</td>
                        <td class="col-pts" style="color:${diffColor}; font-weight:normal;">${diffSign}${s.gd}</td>
                    `;
                        body.appendChild(tr);
                    });
                    if (tEl) tEl.innerText = titleStr;
                    // Removed duplicate body declaration
                } catch (err) {
                    console.error("renderStandingsView Error:", err);
                }
            },

            renderCrossView: () => {
                try {
                    const prefix = state.tournamentName ? (state.tournamentName + " - ") : "";
                    const titleStr = prefix + "TABULKA K≈ò√ç≈ΩOV√Å";
                    document.title = titleStr;
                    const tEl = document.getElementById('pv-cross-title');
                    if (tEl) tEl.innerText = titleStr;
                    const container = document.getElementById('pv-cross-container');
                    if (!container) return;

                    const standings = admin.calculateStandings();
                    const activeIds = new Set(standings.map(s => s.id));
                    const teams = (state.teams || []).filter(t => activeIds.has(t.id));

                    if (teams.length === 0) {
                        container.innerHTML = `<p style="text-align:center; color:#666; font-size:1.5vw; padding:5vh;">≈Ω√°dn√° data pro k≈ô√≠≈æovou tabulku.</p>`;
                        return;
                    }

                    let html = `<table class="pv-table cross-table" style="font-size: 1.4vw;">
                    <thead><tr>
                        <th style="width:4vw; text-align:center;">#</th>
                        <th style="text-align:left;">Dru≈æstvo</th>`;

                    teams.forEach((t, i) => {
                        html += `<th style="width:5vw; text-align:center; border-left:1px solid #333;">${i + 1}</th>`;
                    });

                    html += `<th style="width:4vw; text-align:center; border-left:2px solid #444;">B</th>
                         <th style="width:6vw; text-align:center; border-left:1px solid #333;">S</th>
                         <th style="width:4vw; text-align:center; border-left:1px solid #333;">R</th>
                         <th style="width:4vw; text-align:center; border-left:1px solid #333;">M</th>
                    </tr></thead><tbody>`;

                    teams.forEach((tRow, i) => {
                        html += `<tr>
                        <td style="text-align:center; color:#666;">${i + 1}.</td>
                        <td style="font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${tRow.name}</td>`;

                        teams.forEach((tCol, j) => {
                            let cellContent = "-";
                            let cellStyle = "border-left:1px solid #333; text-align:center; color:#888;";

                            if (i === j) {
                                cellStyle += "color:transparent;"; // Ensure it's empty but styled
                                cellContent = "";
                                html += `<td class="cross-self" style="${cellStyle}">${cellContent}</td>`;
                            } else {
                                const match = (state.schedule || []).find(m =>
                                    m.type === 'match' &&
                                    ((m.home === tRow.id && m.guest === tCol.id) || (m.home === tCol.id && m.guest === tRow.id)) &&
                                    m.homeScore !== null && m.homeScore !== undefined
                                );

                                if (match) {
                                    cellStyle = "border-left:1px solid #333; text-align:center; font-weight:700;";
                                    if (match.home === tRow.id) {
                                        cellContent = `${match.homeScore}:${match.guestScore}`;
                                    } else {
                                        cellContent = `${match.guestScore}:${match.homeScore}`;
                                    }
                                }
                                html += `<td style="${cellStyle}">${cellContent}</td>`;
                            }
                        });

                        const s = standings.find(x => x.id === tRow.id) || { pts: 0, gf: 0, ga: 0, gd: 0 };
                        const rank = standings.findIndex(x => x.id === tRow.id) + 1;
                        const diffColor = s.gd > 0 ? '#4caf50' : (s.gd < 0 ? '#f44336' : '#888');
                        const diffSign = s.gd > 0 ? '+' : '';

                        html += `<td style="border-left:2px solid #444; text-align:center; font-weight:900; color:var(--accent-blue);">${s.pts}</td>
                             <td style="border-left:1px solid #333; text-align:center; color:#aaa;">${s.gf}:${s.ga}</td>
                             <td style="border-left:1px solid #333; text-align:center; color:${diffColor};">${diffSign}${s.gd}</td>
                             <td style="border-left:1px solid #333; text-align:center; font-weight:bold;">${rank}.</td>
                     </tr>`;
                    });

                    html += `</tbody></table>`;
                    container.innerHTML = html;
                } catch (err) {
                    console.error("renderCrossView Error:", err);
                }
            },
        };


        // ===================================================================================
        // POMOCN√â FUNKCE (UTILS)
        // ===================================================================================
        // --- UTILS ---
        function toggleAccordion(id) {
            const content = document.getElementById(id);
            if (content.classList.contains('open')) {
                content.classList.remove('open');
            } else {
                content.classList.add('open');
                // Force render if schedule is opened to ensure it is up to date/visible
                if (id === 'acc-schedule') {
                    ui.renderSchedule();
                }
            }
        }

        function openProjectionWindow() {
            const url = window.location.origin + window.location.pathname + '?projection&session=' + state.sessionId;
            projectionWindow = window.open(url, "ScoreboardProjection_" + state.sessionId, "width=800,height=600");
            if (!projectionWindow) {
                alert("Vyskakovac√≠ okno bylo zablokov√°no. Pros√≠m povolte jej pro tuto str√°nku.");
            } else {
                game.syncProjection();
            }
        }

        // ===================================================================================
        // INICIALIZACE
        // ===================================================================================
        // Initial Sync for Admin/Main view (moved inside load handler or kept only if needed)
        // game.syncProjection(); // Removed global call that was causing issues in projection

        // --- INIT ---
        window.addEventListener('load', game.init);

    </script>

    <!-- Conflict Resolution Modal -->
    <div id="modal-player-conflicts" class="modal-overlay"
        style="display:none; z-index: 10000; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); display:none; align-items:center; justify-content:center;">
        <div
            style="background:var(--bg-dark); border:1px solid #444; width:90%; max-width:800px; max-height:85vh; border-radius:8px; display:flex; flex-direction:column; box-shadow:0 10px 30px rgba(0,0,0,0.5);">
            <div
                style="padding:20px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center;">
                <h3 style="margin:0; color:var(--accent-blue);">‚ö†Ô∏è Revize konflikt≈Ø v datab√°zi</h3>
                <span style="font-size:0.8em; color:#888;">Porovnejte st√°vaj√≠c√≠ data s importem</span>
            </div>

            <div id="conflict-list-container" style="flex:1; overflow-y:auto; padding:20px;">
                <!-- Conflicts will be rendered here -->
            </div>

            <div
                style="padding:15px; border-top:1px solid #333; display:flex; justify-content:flex-end; gap:10px; background:#1a1a1a; border-bottom-left-radius:8px; border-bottom-right-radius:8px;">
                <button class="small-btn btn-yellow" onclick="admin.cancelConflictReview()">Zru≈°it import</button>
                <button class="small-btn btn-green" id="btn-resolve-all" style="padding:8px 20px;">Dokonƒçit import
                    ‚úÖ</button>
            </div>
        </div>
    </div>

    <div id="qr-layout" class="pv-container">
        <div class="pv-header">
            <div class="pv-title" id="qr-tournament-name">OmniScore</div>
        </div>

        <!-- Single QR View -->
        <div id="qr-single-view" class="qr-inner">
            <div id="qr-container"
                style="background:white; padding:20px; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.5); width:300px; height:300px; display:flex; align-items:center; justify-content:center; margin:0 auto;">
            </div>
            <div style="margin-top:4vh; font-size:2vw;">
                <p>Naskenujte pro sledov√°n√≠ v√Ωsledk≈Ø na mobilu</p>
                <p style="font-size:1.5vw; color:#888; margin-top:1vh;"><span id="qr-session-id"
                        style="color:var(--accent-blue); font-weight:bold;">---</span></p>
            </div>
        </div>

        <!-- Grid QR View (2x2) -->
        <div id="qr-grid-view" class="qr-inner" style="display:none;">
            <div class="qr-grid-container">
                <div class="qr-grid-item">
                    <div class="qr-grid-label">Projekce Sk√≥re</div>
                    <div id="qr-grid-projection" class="qr-grid-code"></div>
                </div>
                <div class="qr-grid-item">
                    <div class="qr-grid-label">Po≈ôad√≠ Z√°pas≈Ø</div>
                    <div id="qr-grid-schedule" class="qr-grid-code"></div>
                </div>
                <div class="qr-grid-item">
                    <div class="qr-grid-label">Tabulka Po≈ôad√≠</div>
                    <div id="qr-grid-standings" class="qr-grid-code"></div>
                </div>
                <div class="qr-grid-item">
                    <div class="qr-grid-label">Tabulka K≈ô√≠≈æov√°</div>
                    <div id="qr-grid-cross" class="qr-grid-code"></div>
                </div>
            </div>
            <div style="margin-top:4vh; font-size:1.5vw; color:#888;">
                ID relace: <span id="qr-session-id-grid" style="color:var(--accent-blue); font-weight:bold;">---</span>
            </div>
        </div>
    </div>
    </div>

    <style>
        .conflict-row {
            background: #252525;
            border: 1px solid #444;
            border-radius: 6px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .conflict-header {
            background: #333;
            padding: 8px 12px;
            font-size: 0.85em;
            font-weight: bold;
            color: #ccc;
            border-bottom: 1px solid #444;
        }

        .conflict-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: #444;
        }

        .conflict-cell {
            background: #252525;
            padding: 12px;
        }

        .conflict-label {
            display: block;
            font-size: 0.7em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .conflict-value {
            font-size: 0.95em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conflict-choice {
            display: flex;
            gap: 5px;
            padding: 10px;
            background: #1a1a1a;
            justify-content: flex-end;
        }

        .choice-btn {
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: 0.2s;
        }

        .choice-btn:hover {
            background: #444;
        }

        .choice-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
            font-weight: bold;
        }

        .val-diff {
            color: #ffab40;
            font-weight: bold;
        }
    </style>
</body>

</html>