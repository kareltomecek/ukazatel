<!DOCTYPE html>
<html lang="cs">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scoreboard App</title>
    <!-- SheetJS for Excel/CSV import -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-bg: #2d2d2d;
            --text-color: #ffffff;
            --accent-green: #4caf50;
            --accent-red: #f44336;
            --accent-yellow: #ffc107;
            --accent-blue: #2196f3;
            --border-radius: 8px;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
            /* Prevent body scroll if content fits */
        }

        #app-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            height: 100%;
        }

        /* Responsive Layout */
        @media (max-width: 1024px) {
            #app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                overflow-y: auto;
            }

            body {
                overflow-y: auto;
                height: auto;
            }
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        h2,
        h3 {
            margin-top: 0;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }

        /* --- Controls Section (Left Panel) --- */
        #game-controls {
            gap: 20px;
        }

        /* Phase Navigation */
        .phase-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #383838;
            padding: 10px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
        }

        .phase-steps {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .phase-btn {
            background: #555;
            border: none;
            color: #aaa;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .phase-btn.active {
            background: var(--accent-blue);
            color: white;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
        }

        .nav-arrow {
            background: #444;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
        }

        .nav-arrow:hover {
            background: #666;
        }

        /* Score & Time Area */
        .scoreboard-interface {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
            gap: 20px;
            flex-grow: 1;
            align-items: center;
        }

        .team-panel {
            text-align: center;
            background: #333;
            padding: 20px;
            border-radius: var(--border-radius);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 0;
            /* Allow shrinking for ellipsis */
        }

        .team-logo {
            width: 80px;
            height: 80px;
            object-fit: contain;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            display: none;
        }

        .team-name {
            font-size: 1.5em;
            font-weight: bold;
            color: #ddd;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .score-display {
            font-size: 4em;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
        }

        .score-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn-speaker {
            font-size: 0.8em;
            padding: 5px;
        }

        .btn-speaker svg {
            width: 24px;
            height: 24px;
        }

        .round-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .center-panel {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .timer-display {
            font-size: 5em;
            font-family: 'Courier New', monospace;
            background: #000;
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #444;
            color: var(--accent-yellow);
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #main-timer {
            outline: none;
            cursor: default;
        }

        #main-timer[contenteditable="true"]:hover {
            background: #111;
            cursor: text;
        }

        .timer-arrows {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .arrow-btn {
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 0.4em;
            padding: 0;
            line-height: 1;
            transition: color 0.2s;
        }

        .arrow-btn:hover {
            color: var(--accent-yellow);
        }

        .arrow-btn:disabled {
            color: #333;
            cursor: not-allowed;
        }

        .timer-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .music-mini-panel {
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
            background: #222;
            padding: 6px 12px;
            border-radius: 20px;
            margin-top: 10px;
            border: 1px solid #444;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            width: fit-content;
        }

        .music-mini-panel .round-btn {
            background: none !important;
            border: none !important;
            color: #888 !important;
            box-shadow: none !important;
            width: 32px;
            height: 32px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .music-mini-panel .round-btn:hover {
            color: #bbb !important;
        }

        #btn-music-toggle-mini {
            font-size: 1.5em;
        }


        #btn-music-toggle-mini.active {
            color: #00a2ff !important;
        }

        .small-btn {
            padding: 5px 10px;
            font-size: 0.9em;
            background: #555;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* --- Admin Section (Right Panel) --- */
        #admin-panel {
            overflow-y: auto;
        }

        .accordion {
            margin-bottom: 10px;
        }

        .accordion-header {
            background-color: #444;
            padding: 10px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }

        .accordion-content {
            padding: 10px;
            background: #383838;
            margin-top: 2px;
            border-radius: 0 0 4px 4px;
            display: none;
        }

        .accordion-content.open {
            display: block;
        }

        .form-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #ccc;
        }

        input,
        select {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .btn-full {
            width: 100%;
            padding: 10px;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .btn-projection {
            background: #9c27b0;
            margin-bottom: 20px;
        }

        /* Color Utilities (must be after layout classes) */
        .btn-green {
            background-color: var(--accent-green) !important;
        }

        .btn-red {
            background-color: var(--accent-red) !important;
        }

        .btn-yellow {
            background-color: var(--accent-yellow) !important;
            color: #000 !important;
        }

        .btn-orange {
            background-color: #ff9800 !important;
            color: white !important;
        }

        /* List Styling */
        .match-list {
            list-style: none;
            padding: 0;
        }

        .match-item {
            background: #444;
            margin-bottom: 5px;
            padding: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            position: relative;
            /* Required for ::before positioning */
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .match-item.drop-indicator-top::before,
        .match-item.drop-indicator-bottom::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 3px;
            background-color: #4caf50;
            z-index: 10;
        }

        .match-item.drop-indicator-top::before {
            top: -2px;
        }

        .match-item.drop-indicator-bottom::before {
            bottom: -2px;
        }

        .active-match {
            border-left: 5px solid var(--accent-green);
            background-color: #3e5e40;
        }

        .editing-match {
            background-color: #8c2a2a !important;
            /* Redish background for edit */
            border: 2px solid #f44336;
        }

        .selected-match {
            background-color: #2b4b7c !important;
            /* Blue for selection */
            border-left: 5px solid #2196f3;
        }

        .schedule-toolbar {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            background: #333;
            padding: 5px;
            border-radius: var(--border-radius);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .schedule-toolbar .small-btn {
            background: #444;
            min-width: 32px;
            font-weight: bold;
        }

        .schedule-toolbar .small-btn:hover {
            background: #555;
        }

        .schedule-toolbar .btn-red:hover {
            background: #d32f2f !important;
        }

        .schedule-toolbar .btn-green:hover {
            background: #388e3c !important;
        }

        /* --- Admin Footer --- */
        #admin-footer {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            align-items: center;
            background: #111;
            padding: 0 20px;
            color: #888;
            font-size: 0.85em;
            font-weight: bold;
            border-top: 1px solid #333;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 35px;
            box-sizing: border-box;
            z-index: 1000;
        }

        #admin-footer-end {
            text-align: center;
        }

        #admin-footer-time {
            text-align: right;
        }

        body {
            padding-bottom: 55px;
            /* 35px footer + 20px gap */
        }

        /* Space for fixed footer */

        /* PROJECTION MODE OVERRIDES */
        body.mode-projection {
            margin: 0;
            padding: 0 !important;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            background: #000;
            color: #fff;
            display: block;
            /* Overriding possible grid from other modes */
        }

        body.mode-projection #app-container,
        body.mode-projection #admin-footer {
            display: none !important;
        }

        #projection-layout {
            display: none;
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            grid-template-rows: 18vh 48vh 30vh 4vh;
        }

        body.mode-projection #projection-layout {
            display: grid;
        }

        /* Reuse projection styles from old window generation */
        .p-row {
            display: grid;
            align-items: center;
            padding: 0 4vw;
        }

        #p-row-top {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
        }

        #p-match-title {
            font-size: 3vw;
            text-align: left;
            font-weight: 500;
        }

        #p-phase-name {
            font-size: 4vw;
            font-weight: 800;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.1vw;
        }

        #p-timer {
            font-size: 6vw;
            font-family: 'Courier New', monospace;
            text-align: right;
            font-weight: bold;
        }

        #p-row-mid {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
        }

        .p-team {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2vh;
            min-width: 0;
        }

        .p-team-name {
            font-size: 4.5vw;
            font-weight: 900;
            text-align: center;
            line-height: 1.1;
            text-transform: uppercase;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .p-team-logo {
            width: 17vw;
            height: 17vw;
            object-fit: contain;
            border-radius: 2vw;
            display: none;
        }

        #p-score-box {
            font-size: 16vw;
            font-weight: 900;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #p-score-sep {
            margin: 0 1vw;
        }

        #p-event-content {
            display: none;
            grid-column: 1 / span 3;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 9vw;
            font-weight: 900;
            text-transform: uppercase;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 0 5vw;
            box-sizing: border-box;
        }

        #p-row-bot {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            padding: 0;
            overflow: hidden;
        }

        .p-sched-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        #p-upcoming-header {
            display: grid;
            grid-template-columns: 22% 56% 22%;
            align-items: flex-start;
            padding: 0.5vh 4vw 0 4vw;
            font-size: 1.8vw;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05vw;
            height: 5vh;
            margin-bottom: 1vh;
            box-sizing: border-box;
        }

        #p-match-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-column: 1 / span 3;
            width: 100%;
            height: 100%;
            align-items: center;
        }

        .p-sched-row {
            height: 5.5vh;
            font-size: 1.8vw;
        }

        .p-sched-col-match {
            width: 22%;
            text-align: left;
            font-weight: 500;
        }

        .p-sched-col-teams {
            width: 56%;
            font-weight: 700;
            padding: 0;
        }

        .p-sched-col-refs {
            width: 22%;
            text-align: right;
            font-size: 1.5vw;
        }

        .p-teams-flex {
            display: flex;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .p-teams-side-home {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            text-align: right;
            overflow: hidden;
        }

        .p-teams-side-guest {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            text-align: left;
            overflow: hidden;
        }

        .p-teams-sep {
            width: 4vw;
            text-align: center;
            flex-shrink: 0;
            font-size: 2vw;
            font-weight: 900;
        }

        .p-mini-logo {
            width: 2.5vw;
            height: 2.5vw;
            object-fit: contain;
            vertical-align: middle;
            margin: 0 0.8vw;
            border-radius: 0.5vw;
            display: none;
        }

        #p-row-footer {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            align-items: center;
            padding: 0 4vw;
            font-size: 1.0vw;
            font-weight: bold;
            color: #888;
        }

        .p-footer-center {
            text-align: center;
            font-weight: bold;
        }

        .p-footer-right {
            text-align: right;
        }

        /* THEMES for Projection */
        body.mode-projection.theme-light {
            background: #ffffff;
            color: #333333;
        }

        body.mode-projection.theme-light #p-row-top {
            background: #fcfcfc;
        }

        body.mode-projection.theme-light #p-match-title {
            color: #777777;
        }

        body.mode-projection.theme-light #p-phase-name {
            color: #1a73e8;
        }

        body.mode-projection.theme-light #p-timer {
            color: #d32f2f;
        }

        body.mode-projection.theme-light #p-score-box,
        body.mode-projection.theme-light #p-event-content {
            color: #2e7d32;
        }

        body.mode-projection.theme-light #p-row-bot {
            background: #f8f9fa;
        }

        body.mode-projection.theme-light .p-sched-row {
            border-bottom: 1px solid #e9ecef;
            color: #3c4043;
        }

        body.mode-projection.theme-dark {
            background: #000000;
            color: #ffffff;
        }

        body.mode-projection.theme-dark #p-row-top {
            background: #0a0a0a;
        }

        body.mode-projection.theme-dark #p-match-title {
            color: #aaaaaa;
        }

        body.mode-projection.theme-dark #p-timer {
            color: #ffc107;
        }

        body.mode-projection.theme-dark #p-score-box,
        body.mode-projection.theme-dark #p-event-content {
            color: #4caf50;
        }

        body.mode-projection.theme-dark .p-sched-row {
            border-bottom: 1px solid #222222;
            color: #dddddd;
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }

            100% {
                opacity: 1;
            }
        }

        .p-row-blink {
            animation: blink 1s infinite;
        }

        /* Schedule Tabs */
        .sched-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: -1px;
            position: relative;
            z-index: 2;
            padding-left: 0;
        }

        .sched-tab-btn {
            padding: 10px 18px;
            border: 1px solid transparent;
            background: rgba(255, 255, 255, 0.03);
            color: #777;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.75em;
            border-radius: 6px 6px 0 0;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }

        .sched-tab-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: #aaa;
        }

        .sched-tab-btn.active {
            background: #383838;
            /* Matches accordion-content bg */
            color: var(--accent-blue);
            border: 1px solid var(--accent-blue);
            border-bottom-color: #383838 !important;
            /* Hide bottom border to merge with content */
        }

        .sched-tab-btn.active::before,
        .sched-tab-btn.active::after {
            content: "";
            position: absolute;
            bottom: -1px;
            width: 10px;
            height: 10px;
            pointer-events: none;
            border-bottom: 1px solid currentColor;
        }

        .sched-tab-btn.active::before {
            left: -11px;
            border-bottom-right-radius: 10px;
            border-right: 1px solid currentColor;
            box-shadow: 3px 2px 0 0 #383838;
        }

        .sched-tab-btn.active::after {
            right: -11px;
            border-bottom-left-radius: 10px;
            border-left: 1px solid currentColor;
            box-shadow: -3px 2px 0 0 #383838;
        }

        #tab-sched-import.active {
            color: #bbb;
            border-color: #555;
            border-bottom-color: #383838 !important;
        }

        .sched-section {
            display: none;
            border: 1px solid var(--accent-blue);
            padding: 15px;
            border-radius: 0 6px 6px 6px;
            /* Flat top-left to connect with first tab */
            margin-bottom: 20px;
            background: rgba(33, 150, 243, 0.03);
            position: relative;
            z-index: 1;
        }

        #sched-section-import {
            border-color: #555;
            background: rgba(255, 255, 255, 0.01);
        }

        .sched-section.active {
            display: block;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: #222;
            padding: 2px;
            border-radius: 6px;
            margin-bottom: 12px;
            border: 1px solid #444;
        }

        .mode-toggle-btn {
            flex: 1;
            padding: 6px;
            border: none;
            background: none;
            color: #777;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .mode-toggle-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        .mode-toggle-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .icon-sq {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            background: var(--accent-blue);
            border-radius: 4px;
            color: white;
            flex-shrink: 0;
        }

        .mode-toggle-btn.active .icon-sq {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>

<body>

    <div id="app-container">
        <!-- LEFT PANEL: Game Controls -->
        <div id="game-controls" class="panel">
            <button class="btn-full btn-projection" onclick="openProjectionWindow()">üìΩÔ∏è Otev≈ô√≠t Projekƒçn√≠ Okno</button>

            <div class="phase-nav">
                <button class="nav-arrow" onclick="game.step(-1)">‚óÑ</button>
                <div class="phase-steps" id="phase-controls">
                    <button class="phase-btn" data-phase="0">Nastupuje</button>
                    <button class="phase-btn" data-phase="1">1. Poloƒças</button>
                    <button class="phase-btn" data-phase="2">P≈ôest√°vka</button>
                    <button class="phase-btn" data-phase="3">2. Poloƒças</button>
                </div>
                <div id="event-label"
                    style="display:none; flex:1; text-align:center; font-weight:900; text-transform:uppercase; font-size:1.2em; color:var(--accent-blue);">
                    Ud√°lost</div>
                <button class="nav-arrow" onclick="game.step(1)">‚ñ∫</button>
            </div>

            <div class="scoreboard-interface">
                <!-- Home Team -->
                <div class="team-panel" id="home-team-panel">
                    <div class="team-name" id="home-name-disp">Dom√°c√≠</div>
                    <img id="home-logo-disp" class="team-logo" src="" alt="Logo">
                    <div class="score-display" id="home-score-disp">0</div>
                    <div class="score-controls">
                        <button class="round-btn btn-green" onclick="game.adjustScore('home', 1)">+</button>
                        <button class="round-btn btn-green btn-speaker" onclick="game.adjustScore('home', 1, true)"
                            title="G√≥l s jingle">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z" />
                            </svg>
                        </button>
                        <button class="round-btn btn-red" onclick="game.adjustScore('home', -1)">-</button>
                    </div>
                </div>

                <!-- Timer & Center -->
                <div class="center-panel">
                    <div id="match-info-display" style="color:#aaa; margin-bottom:5px; font-weight:bold;">-</div>
                    <div class="timer-display">
                        <span id="main-timer" onblur="game.manualTimeEntry()"
                            onkeydown="if(event.key==='Enter'){this.blur(); event.preventDefault();}">00:00</span>
                        <div class="timer-arrows">
                            <button class="arrow-btn" id="btn-time-up" onclick="game.adjustTime(1)">‚ñ≤</button>
                            <button class="arrow-btn" id="btn-time-down" onclick="game.adjustTime(-1)">‚ñº</button>
                        </div>
                    </div>
                    <div class="timer-controls">
                        <button id="btn-timer-toggle" class="round-btn btn-yellow"
                            onclick="game.toggleTimer()">‚èØ</button>
                        <button class="round-btn btn-red" onclick="game.resetTimer()">‚Ü∫</button>
                    </div>

                    <div class="music-mini-panel" id="music-mini-panel" style="display:none;">
                        <div style="display:flex; align-items:center; gap:8px;">
                            <button class="round-btn" onclick="music.prev()">‚èÆ</button>
                            <button class="round-btn" id="btn-music-toggle-mini" onclick="music.toggle()">‚ô´</button>
                            <button class="round-btn" onclick="music.next()">‚è≠</button>
                        </div>
                        <div style="width: 100%; display: flex; align-items: center; padding: 0 4px;">
                            <input type="range" id="input-vol-music" min="0" max="1" step="0.05" value="0.5"
                                oninput="music.setVolume(this.value)"
                                style="margin:0; height:4px; accent-color:#888; cursor:pointer;">
                        </div>
                    </div>
                </div>

                <!-- Guest Team -->
                <div class="team-panel" id="guest-team-panel">
                    <div class="team-name" id="guest-name-disp">Host√©</div>
                    <img id="guest-logo-disp" class="team-logo" src="" alt="Logo">
                    <div class="score-display" id="guest-score-disp">0</div>
                    <div class="score-controls">
                        <button class="round-btn btn-green" onclick="game.adjustScore('guest', 1)">+</button>
                        <button class="round-btn btn-green btn-speaker" onclick="game.adjustScore('guest', 1, true)"
                            title="G√≥l s jingle">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z" />
                            </svg>
                        </button>
                        <button class="round-btn btn-red" onclick="game.adjustScore('guest', -1)">-</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT PANEL: Administration -->
        <div id="admin-panel" class="panel">
            <h3>Turnajov√° Spr√°va</h3>

            <!-- 1. Tournament Settings -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-settings')">
                    Nastaven√≠ Turnaje <span>‚ñº</span>
                </div>
                <div id="acc-settings" class="accordion-content">
                    <div class="form-group">
                        <label>N√°zev Turnaje</label>
                        <input type="text" id="input-tournament-name" placeholder="Nap≈ô. Zimn√≠ Poh√°r"
                            oninput="admin.saveSettings(false)">
                    </div>

                    <h4 style="margin: 15px 0 10px 0; border: none; padding: 0;">D√©lka krok≈Ø (s)</h4>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">Poloƒças</label>
                            <input type="number" id="time-play" value="420" min="0" style="width: 100%;"
                                oninput="admin.saveSettings(false)">
                        </div>
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">P≈ôest√°vka</label>
                            <input type="number" id="time-break" value="105" min="0" style="width: 100%;"
                                oninput="admin.saveSettings(false)">
                        </div>
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label style="font-size: 0.85em;">Nastupuje</label>
                            <input type="number" id="time-setup" value="10" min="0" style="width: 100%;"
                                oninput="admin.saveSettings(false)">
                        </div>
                    </div>

                </div>
            </div>



            <!-- 2. Team Logos & Anthems -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-logos')">
                    Dru≈æstva a Rozhodƒç√≠ <span>‚ñº</span>
                </div>
                <div id="acc-logos" class="accordion-content">
                    <div class="form-group">
                        <label>Seznam Dru≈æstev</label>
                        <div id="teams-input-list"
                            style="display:flex; flex-direction:column; gap:5px; margin-bottom:10px;">
                            <!-- Dynamically populated numbered inputs -->
                        </div>
                        <button class="small-btn btn-green" onclick="admin.addTeamSlot()">+ P≈ôidat dru≈æstvo</button>
                    </div>
                    <div id="team-logo-list"
                        style="margin-bottom:15px; border:1px solid #444; padding:10px; border-radius:4px; max-height:250px; overflow-y:auto;">
                        <!-- logo items here -->
                    </div>
                    <div class="form-group">
                        <label>Seznam Rozhodƒç√≠ch</label>
                        <div id="referees-input-list"
                            style="display:flex; flex-direction:column; gap:5px; margin-bottom:10px;">
                            <!-- Dynamically populated numbered inputs -->
                        </div>
                        <button class="small-btn btn-green" onclick="admin.addRefereeSlot()">+ P≈ôidat
                            rozhodƒç√≠ho</button>
                    </div>
                </div>
            </div>

            <!-- 3. Schedule -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-schedule')">
                    Rozpis Z√°pas≈Ø <span>‚ñº</span>
                </div>
                <div id="acc-schedule" class="accordion-content">

                    <div class="mode-toggle">
                        <button id="mode-sched-append" class="mode-toggle-btn active"
                            onclick="admin.setModificationMode('append')">
                            <span class="icon-sq">
                                <svg viewBox="0 0 24 24">
                                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                                </svg>
                            </span>
                            P≈ôidat k existuj√≠c√≠mu
                        </button>
                        <button id="mode-sched-replace" class="mode-toggle-btn"
                            onclick="admin.setModificationMode('replace')">
                            <span class="icon-sq">
                                <svg viewBox="0 0 24 24">
                                    <path
                                        d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z" />
                                </svg>
                            </span>
                            Nahradit rozpis
                        </button>
                    </div>

                    <div class="sched-tabs">
                        <button id="tab-sched-gen" class="sched-tab-btn active"
                            onclick="admin.setScheduleMode('gen')">Gener√°tor</button>
                        <button id="tab-sched-import" class="sched-tab-btn"
                            onclick="admin.setScheduleMode('import')">Import (Excel)</button>
                    </div>

                    <div id="sched-section-gen" class="sched-section active">
                        <div id="sched-template-container">
                            <label
                                style="display:block; font-size:0.85em; color:var(--accent-blue); font-weight:bold; margin-bottom:12px;">Automatick√Ω
                                rozpis (podle sch√©matu)</label>
                            <div style="display:flex; gap:8px;">
                                <select id="sched-template-select" style="flex:1">
                                    <optgroup label="Z√°kladn√≠ (ka≈æd√Ω s ka≈æd√Ωm)">
                                        <option value="2">1. Pro 2 dru≈æstva</option>
                                        <option value="3">2. Pro 3 dru≈æstva</option>
                                        <option value="4">3. Pro 4 dru≈æstva</option>
                                        <option value="5">4. Pro 5 dru≈æstev</option>
                                        <option value="6">5. Pro 6 dru≈æstev</option>
                                        <option value="7">6. Pro 7 dru≈æstev</option>
                                        <option value="8">7. Pro 8 dru≈æstev</option>
                                    </optgroup>
                                    <optgroup label="Pokroƒçil√© (Skupiny + Play-off)">
                                        <option value="8_groups">8. 8 t√Ωm≈Ø: 2 sk. po 4 + PO</option>
                                        <option value="9_groups">9. 9 t√Ωm≈Ø: 2 sk. (4,5) + PO</option>
                                        <option value="10_groups">10. 10 t√Ωm≈Ø: 2 sk. po 5 + PO</option>
                                        <option value="11_groups">11. 11 t√Ωm≈Ø: 2 sk. (5,6) + PO</option>
                                        <option value="12_groups">12. 12 t√Ωm≈Ø: 2 sk. po 6 + PO</option>
                                        <option value="13_groups">13. 13 t√Ωm≈Ø: 3 sk. (4,4,5) + PO</option>
                                    </optgroup>
                                    <optgroup label="Turnaj ve skupin√°ch (RR Tiered)">
                                        <option value="12_groups_rr">14. 12 t√Ωm≈Ø: 3 sk. po 4 + RR um√≠stƒõn√≠</option>
                                        <option value="13_groups_rr">15. 13 t√Ωm≈Ø: 3 sk. (4,4,5) + RR um√≠stƒõn√≠</option>
                                        <option value="14_groups_rr">16. 14 t√Ωm≈Ø: 3 sk. (4,5,5) + RR um√≠stƒõn√≠</option>
                                        <option value="15_groups_rr">17. 15 t√Ωm≈Ø: 3 sk. po 5 + RR um√≠stƒõn√≠</option>
                                    </optgroup>
                                </select>
                                <button class="small-btn btn-blue" onclick="admin.generateScheduleFromTemplate()"
                                    style="background:var(--accent-blue);">Generovat</button>
                            </div>
                        </div>
                    </div>

                    <div id="sched-section-import" class="sched-section">
                        <div>
                            <label
                                style="display:block; font-size:0.85em; color:#aaa; font-weight:bold; margin-bottom:12px;">Importovat
                                ze souboru (.xlsx, .xls, .csv)</label>

                            <input type="file" id="input-sched-import" accept=".xlsx, .xls, .csv" style="display:none"
                                onchange="admin.handleScheduleImport(this)">
                            <button class="btn-full" onclick="document.getElementById('input-sched-import').click()"
                                style="background:#555; margin-top:0;">Vybrat soubor...</button>

                            <div
                                style="margin-top:10px; font-size:0.75em; color:#888; border-top:1px solid #444; padding-top:8px;">
                                <b style="color:#bbb; display:block; margin-bottom:4px;">Oƒçek√°van√© sloupce (v
                                    po≈ôad√≠):</b>
                                1. N√°zev / Skupina (A)<br>
                                2. Dom√°c√≠ t√Ωm (B)<br>
                                3. Hostuj√≠c√≠ t√Ωm (C)<br>
                                4. Rozhodƒç√≠ (D)<br>
                                5. D√©lka v min. (E - volitelnƒõ)
                            </div>
                        </div>
                    </div>

                    <div id="sched-form-container"
                        style="display:none; border:1px solid #444; padding:10px; border-radius:4px; margin-bottom:15px; background:#2a2a2a;">
                        <div class="form-group">
                            <label>Typ polo≈æky</label>
                            <select id="sched-type" onchange="admin.onSchedTypeChange()">
                                <option value="match">Z√°pas</option>
                                <option value="event">Ud√°lost</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>N√°zev / Skupina</label>
                            <div style="display:flex; gap:5px;">
                                <select id="sched-title" style="flex:1">
                                    <option value="Skupina A">Skupina A</option>
                                    <option value="Skupina B">Skupina B</option>
                                    <option value="Skupina C">Skupina C</option>
                                    <option value="Skupina D">Skupina D</option>
                                    <option value="ƒåtvrtfin√°le">ƒåtvrtfin√°le</option>
                                    <option value="Semifin√°le">Semifin√°le</option>
                                    <option value="Fin√°le">Fin√°le</option>
                                    <option value="O um√≠stƒõn√≠">O um√≠stƒõn√≠</option>
                                </select>
                                <input type="text" id="sched-custom-title" placeholder="Vlastn√≠ n√°zev..."
                                    style="flex:1; display:none;">
                            </div>
                        </div>
                        <div id="sched-match-fields">
                            <div class="form-group">
                                <label>Dom√°c√≠</label>
                                <select id="sched-home"></select>
                            </div>
                            <div class="form-group">
                                <label>Host√©</label>
                                <select id="sched-guest"></select>
                            </div>
                            <div class="form-group">
                                <label>Rozhodƒç√≠</label>
                                <select id="sched-referee"></select>
                            </div>
                            <div class="form-group" style="display:flex; gap:10px;">
                                <div style="flex:1">
                                    <label>Sk√≥re Dom.</label>
                                    <input type="number" id="sched-home-score" placeholder="-" style="width:100%"
                                        min="0">
                                </div>
                                <div style="flex:1">
                                    <label>Sk√≥re Host.</label>
                                    <input type="number" id="sched-guest-score" placeholder="-" style="width:100%"
                                        min="0">
                                </div>
                            </div>
                        </div>
                        <div id="sched-event-fields" style="display:none;">
                            <div class="form-group">
                                <label>D√©lka trv√°n√≠ (sekundy)</label>
                                <input type="number" id="sched-duration" value="600" min="1" style="width:100%">
                            </div>
                        </div>
                        <div id="sched-controls-add" style="display:flex; gap:5px;">
                            <button class="btn-full" onclick="admin.addMatch()"
                                style="background: var(--accent-blue);">Ulo≈æit</button>
                            <button class="btn-full btn-yellow" onclick="admin.toggleAddMode()">Zru≈°it</button>
                        </div>
                        <div id="sched-controls-edit" style="display:none; gap:5px; margin-top:10px;">
                            <button class="btn-full btn-green" onclick="admin.saveEditedMatch()">Ulo≈æit Zmƒõny</button>
                            <button class="btn-full btn-red" onclick="admin.deleteMatch()">Smazat</button>
                            <button class="btn-full btn-yellow" onclick="admin.cancelEdit()">Zru≈°it</button>
                        </div>
                    </div>

                    <div class="schedule-toolbar">
                        <button class="small-btn btn-green" onclick="admin.toggleAddMode()"
                            title="P≈ôidat z√°pas"><b>+</b></button>
                        <button class="small-btn" onclick="admin.moveSelected(-1)" title="Posunout nahoru">‚ñ≤</button>
                        <button class="small-btn" onclick="admin.moveSelected(1)" title="Posunout dol≈Ø">‚ñº</button>
                        <button class="small-btn btn-red" onclick="admin.deleteSelected()"
                            title="Odstranit vybran√©">x</button>
                        <button class="small-btn btn-yellow" onclick="admin.resetSelectedScores()"
                            title="Resetovat sk√≥re">Reset</button>
                        <button class="small-btn btn-yellow" onclick="admin.editSelected()" title="Upravit vybran√Ω"
                            style="margin-left: auto; background: #fbc02d; color: #000;">Upravit</button>
                        <button class="small-btn btn-blue" onclick="admin.loadSelected()" title="Naƒç√≠st vybran√Ω"
                            style="background: var(--accent-blue);">Naƒç√≠st</button>
                    </div>

                    <h4 style="margin-top:5px; border:none;">Po≈ôad√≠:</h4>
                    <ul class="match-list" id="match-queue"></ul>
                </div>
            </div>

            <!-- 4. Music Player -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-music')">
                    Hudba na pozad√≠ <span>‚ñº</span>
                </div>
                <div id="acc-music" class="accordion-content">
                    <div class="form-group">
                        <button class="btn-full" onclick="music.pickDirectory()" style="background:#444;">
                            üìÅ Vybrat slo≈æku s hudbou
                        </button>
                    </div>

                    <div id="music-controls"
                        style="display:none; margin-bottom:15px; background:#2a2a2a; padding:10px; border-radius:4px;">
                        <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                            <div style="color:#aaa; font-size:0.8em;">Pr√°vƒõ hraje:</div>
                            <div id="current-track-name"
                                style="flex:1; font-size:0.8em; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color:#4caf50;">
                                -</div>
                        </div>

                        <div class="form-group">
                            <label>Skladby p≈ôehr√°vat</label>
                            <select id="input-music-mode" onchange="music.setMode(this.value)">
                                <option value="continuous">Za sebou (podle seznamu)</option>
                                <option value="random">N√°hodnƒõ</option>
                            </select>
                        </div>
                        <div class="form-group"
                            style="border-top: 1px solid #444; padding-top: 10px; margin-top: 10px;">
                            <label
                                style="display:flex; align-items:center; gap:10px; cursor:pointer; font-weight: bold; color: #4caf50;">
                                <input type="checkbox" id="input-music-auto"
                                    onchange="music.setAutoEnabled(this.checked)" style="width:auto;">
                                Automatick√Ω re≈æim
                            </label>
                        </div>
                        <div class="form-group">
                            <label>Zmƒõna skladby</label>
                            <select id="input-music-auto-change" onchange="music.setAutoChangeStrategy(this.value)">
                                <option value="continuous">Nechat hr√°t celou skladbu</option>
                                <option value="per-step">Mƒõnit skladbu se zmƒõnou kroku</option>
                                <option value="per-match">Mƒõnit skladbu se zmƒõnou z√°pasu</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>D√©lka prolnut√≠: <span id="fade-dur-disp">1</span>s</label>
                            <input type="range" id="input-music-fade" min="0" max="5" step="0.5" value="1"
                                oninput="music.setFadeDuration(this.value)">
                        </div>
                    </div>

                    <ul class="match-list" id="music-list" style="max-height:300px; overflow-y:auto;">
                        <li style="color:#666; font-size:0.8em; text-align:center; padding:10px;">Slo≈æka nebyla vybr√°na
                        </li>
                    </ul>
                </div>
            </div>


            <!-- 5. Application Settings -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('acc-app-settings')">
                    Nastaven√≠ Aplikace <span>‚ñº</span>
                </div>
                <div id="acc-app-settings" class="accordion-content">
                    <h4 style="margin-bottom:10px; border:none;">Projekƒçn√≠ Okno</h4>
                    <div class="form-group">
                        <label>Vzhled (T√©ma)</label>
                        <select id="input-theme" onchange="admin.saveSettings(false); game.syncProjection()">
                            <option value="light">Svƒõtl√Ω re≈æim (Light Mode)</option>
                            <option value="dark">Tmav√Ω re≈æim (Dark Mode)</option>
                        </select>
                    </div>
                    <div class="form-group"
                        style="background: rgba(26, 115, 232, 0.1); padding: 10px; border-radius: 8px; border: 1px solid var(--accent-blue); margin-top: 10px;">
                        <label style="color: var(--accent-blue); font-weight: bold;">Projekƒçn√≠ URL (pro OBS / druh√Ω
                            monitor)</label>
                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                            <input type="text" id="projection-url-display" readonly
                                style="flex: 1; font-size: 0.8em; background: rgba(0,0,0,0.2); border: 1px solid #555; color: #fff; padding: 5px;">
                            <button class="small-btn"
                                onclick="const el = document.getElementById('projection-url-display'); el.select(); document.execCommand('copy'); alert('URL zkop√≠rov√°na!');"
                                title="Kop√≠rovat">üìã</button>
                        </div>
                        <small style="display: block; margin-top: 5px; color: #aaa; font-size: 0.75em;">Vlo≈æte tuto
                            adresu do OBS Browser Source nebo otev≈ôete v nov√©m oknƒõ.</small>
                    </div>
                    <div class="form-group">
                        <label>Prodleva p≈ôed dal≈°√≠ polo≈ækou (s)</label>
                        <input type="number" id="input-po-delay" value="10" min="1" max="30"
                            oninput="admin.saveSettings(false)">
                    </div>


                    <h4 style="margin: 20px 0 10px 0; border:none;">Zvuky a Hlasitost</h4>
                    <div class="form-group">
                        <label>Vlastn√≠ sir√©na</label>
                        <input type="file" id="input-audio-file" accept="audio/*" onchange="admin.saveSettings(false)">
                    </div>

                    <div class="form-group">
                        <label>Hlasitost sir√©ny: <span id="vol-signal-disp">50</span>%</label>
                        <input type="range" id="input-vol-signal" min="0" max="1" step="0.05" value="0.5"
                            oninput="document.getElementById('vol-signal-disp').innerText = Math.round(this.value * 100); admin.saveSettings(false)">
                    </div>

                    <div class="form-group">
                        <label>Hlasitost jingl≈Ø: <span id="vol-anthem-disp">50</span>%</label>
                        <input type="range" id="input-vol-anthem" min="0" max="1" step="0.05" value="0.5"
                            oninput="document.getElementById('vol-anthem-disp').innerText = Math.round(this.value * 100); admin.saveSettings(false)">
                    </div>

                    <div class="form-group" style="padding-top: 10px; margin-top: 10px; border-top: 1px solid #444;">
                        <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
                            <input type="checkbox" id="input-show-footer" onchange="admin.saveSettings(false)"
                                style="width:auto;" checked>
                            Patiƒçka s informacemi
                        </label>
                    </div>

                    <button class="btn-full" style="margin-top:20px; background: var(--accent-blue);"
                        onclick="admin.saveSettings()">Ulo≈æit v≈°echna nastaven√≠</button>
                    <button class="btn-full btn-red" style="margin-top:10px;" onclick="admin.resetApp()">Resetovat celou
                        aplikaci</button>
                </div>
            </div>
        </div>


        <div id="admin-footer">
            <div id="admin-footer-progress">-</div>
            <div id="admin-footer-end">-</div>
            <div id="admin-footer-time">-</div>
        </div>
    </div> <!-- END of #app-container -->

    <!-- CLEAN PROJECTION LAYOUT -->
    <div id="projection-layout">
        <div id="p-row-top" class="p-row">
            <div id="p-match-title">...</div>
            <div id="p-phase-name">...</div>
            <div id="p-timer">00:00</div>
        </div>

        <div id="p-row-mid" class="p-row">
            <div id="p-match-content">
                <div class="p-team">
                    <div class="p-team-name" id="p-home-name">DOM√ÅC√ç</div>
                    <img id="p-home-logo" class="p-team-logo" src="">
                </div>
                <div id="p-score-box">
                    <span id="p-home-score">0</span>
                    <span id="p-score-sep">:</span>
                    <span id="p-guest-score">0</span>
                </div>
                <div class="p-team">
                    <div class="p-team-name" id="p-guest-name">HOST√â</div>
                    <img id="p-guest-logo" class="p-team-logo" src="">
                </div>
            </div>
            <div id="p-event-content"></div>
        </div>

        <div id="p-row-bot" class="p-row">
            <div id="p-upcoming-header">
                <div></div>
                <div style="text-align:center;">N√ÅSLEDUJE</div>
                <div style="text-align:right;">ROZHODƒå√ç</div>
            </div>
            <div style="padding: 0 4vw; width: 100%; box-sizing: border-box;">
                <table class="p-sched-table">
                    <tbody id="p-upcoming-body"></tbody>
                </table>
            </div>
        </div>

        <div id="p-row-footer" class="p-row">
            <div id="p-footer-progress">Z√°pas: - / -</div>
            <div id="p-footer-end" class="p-footer-center">Konec: --:--</div>
            <div id="p-footer-time" class="p-footer-right">00:00:00</div>
        </div>
    </div>

    <script>
        let projectionWindow = null;
        const syncChannel = new BroadcastChannel('scoreboard_sync');
        // --- DATA STRUCTURES ---
        const PHASES = [
            { id: 0, name: "Nastupuje", timeKey: 'setup' },
            { id: 1, name: "1. Poloƒças", timeKey: 'play' },
            { id: 2, name: "P≈ôest√°vka", timeKey: 'break' },
            { id: 3, name: "2. Poloƒças", timeKey: 'play' }
        ];

        const SCHEDULE_TEMPLATES = {
            2: [[1, 2, "Z√°kladn√≠ skupina"]],
            3: [[1, 2, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"]],
            4: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"]],
            5: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"]],
            6: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [5, 6, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 6, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [1, 6, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [3, 6, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"], [4, 6, "Z√°kladn√≠ skupina"]],
            7: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [5, 6, "Z√°kladn√≠ skupina"], [1, 7, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [6, 7, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"], [4, 7, "Z√°kladn√≠ skupina"], [1, 6, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [2, 7, "Z√°kladn√≠ skupina"], [4, 6, "Zoladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [3, 7, "Z√°kladn√≠ skupina"], [2, 6, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [5, 7, "Z√°kladn√≠ skupina"], [3, 6, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"]],
            8: [[1, 2, "Z√°kladn√≠ skupina"], [3, 4, "Z√°kladn√≠ skupina"], [5, 6, "Z√°kladn√≠ skupina"], [7, 8, "Z√°kladn√≠ skupina"], [1, 4, "Z√°kladn√≠ skupina"], [2, 5, "Z√°kladn√≠ skupina"], [3, 6, "Z√°kladn√≠ skupina"], [1, 7, "Z√°kladn√≠ skupina"], [5, 8, "Z√°kladn√≠ skupina"], [4, 6, "Z√°kladn√≠ skupina"], [2, 3, "Z√°kladn√≠ skupina"], [5, 7, "Z√°kladn√≠ skupina"], [1, 8, "Z√°kladn√≠ skupina"], [2, 6, "Z√°kladn√≠ skupina"], [4, 7, "Z√°kladn√≠ skupina"], [3, 5, "Z√°kladn√≠ skupina"], [1, 6, "Z√°kladn√≠ skupina"], [2, 8, "Z√°kladn√≠ skupina"], [3, 7, "Z√°kladn√≠ skupina"], [4, 5, "Z√°kladn√≠ skupina"], [6, 8, "Z√°kladn√≠ skupina"], [1, 3, "Z√°kladn√≠ skupina"], [2, 7, "Z√°kladn√≠ skupina"], [4, 8, "Z√°kladn√≠ skupina"], [1, 5, "Z√°kladn√≠ skupina"], [6, 7, "Z√°kladn√≠ skupina"], [3, 8, "Z√°kladn√≠ skupina"], [2, 4, "Z√°kladn√≠ skupina"]],
            "8_groups": [
                [1, 2, "Skupina A"], [5, 6, "Skupina B"], [3, 4, "Skupina A"], [7, 8, "Skupina B"],
                [1, 3, "Skupina A"], [5, 7, "Skupina B"], [2, 4, "Skupina A"], [6, 8, "Skupina B"],
                [1, 4, "Skupina A"], [5, 8, "Skupina B"], [2, 3, "Skupina A"], [6, 7, "Skupina B"],
                ["4. ze sk. A", "4. ze sk. B", "o 7. m√≠sto"],
                ["1. ze sk. A", "2. ze sk. B", "Semifin√°le 1"],
                ["3. ze sk. A", "3. ze sk. B", "o 5. m√≠sto"],
                ["1. ze sk. B", "2. ze sk. A", "Semifin√°le 2"],
                ["Pora≈æen√Ω SF1", "Pora≈æen√Ω SF2", "o 3. m√≠sto"],
                ["V√≠tƒõz SF1", "V√≠tƒõz SF2", "Fin√°le"]
            ],
            "9_groups": [
                [1, 2, "Skupina A"], [5, 6, "Skupina B"], [3, 4, "Skupina A"], [7, 8, "Skupina B"],
                [1, 3, "Skupina A"], [5, 9, "Skupina B"], [2, 4, "Skupina A"], [6, 7, "Skupina B"],
                [1, 4, "Skupina A"], [8, 9, "Skupina B"], [2, 3, "Skupina A"], [5, 7, "Skupina B"],
                [6, 8, "Skupina B"], [7, 9, "Skupina B"], [5, 8, "Skupina B"], [6, 9, "Skupina B"],
                ["4. ze sk. A", "4. ze sk. B", "Sk. o 7.-9. m√≠sto"],
                ["1. ze sk. A", "2. ze sk. B", "Semifin√°le 1"],
                ["4. ze sk. A", "5. ze sk. B", "Sk. o 7.-9. m√≠sto"],
                ["1. ze sk. B", "2. ze sk. A", "Semifin√°le 2"],
                ["4. ze sk. B", "5. ze sk. B", "Sk. o 7.-9. m√≠sto"],
                ["3. ze sk. A", "3. ze sk. B", "o 5. m√≠sto"],
                ["Pora≈æen√Ω SF1", "Pora≈æen√Ω SF2", "o 3. m√≠sto"],
                ["V√≠tƒõz SF1", "V√≠tƒõz SF2", "Fin√°le"]
            ],
            "10_groups": [
                [1, 2, "Skupina A"], [6, 7, "Skupina B"], [3, 4, "Skupina A"], [8, 9, "Skupina B"],
                [1, 5, "Skupina A"], [6, 10, "Skupina B"], [2, 3, "Skupina A"], [7, 8, "Skupina B"],
                [4, 5, "Skupina A"], [9, 10, "Skupina B"], [1, 3, "Skupina A"], [6, 8, "Skupina B"],
                [2, 4, "Skupina A"], [7, 9, "Skupina B"], [3, 5, "Skupina A"], [8, 10, "Skupina B"],
                [1, 4, "Skupina A"], [6, 9, "Skupina B"], [2, 5, "Skupina A"], [7, 10, "Skupina B"],
                ["5. ze sk. A", "5. ze sk. B", "o 9. m√≠sto"],
                ["1. ze sk. A", "2. ze sk. B", "Semifin√°le 1"],
                ["4. ze sk. A", "4. ze sk. B", "o 7. m√≠sto"],
                ["1. ze sk. B", "2. ze sk. A", "Semifin√°le 2"],
                ["3. ze sk. A", "3. ze sk. B", "o 5. m√≠sto"],
                ["Pora≈æen√Ω SF1", "Pora≈æen√Ω SF2", "o 3. m√≠sto"],
                ["V√≠tƒõz SF1", "V√≠tƒõz SF2", "Fin√°le"]
            ],
            "11_groups": [
                [1, 2, "Skupina A"], [6, 7, "Skupina B"], [3, 4, "Skupina A"], [8, 9, "Skupina B"],
                [1, 5, "Skupina A"], [10, 11, "Skupina B"], [2, 3, "Skupina A"], [6, 9, "Skupina B"],
                [4, 5, "Skupina A"], [7, 11, "Skupina B"], [1, 3, "Skupina A"], [8, 10, "Skupina B"],
                [2, 4, "Skupina A"], [6, 11, "Skupina B"], [3, 5, "Skupina A"], [7, 9, "Skupina B"],
                [1, 4, "Skupina A"], [6, 8, "Skupina B"], [2, 5, "Skupina A"], [7, 10, "Skupina B"],
                [9, 11, "Skupina B"], [6, 10, "Skupina B"], [8, 11, "Skupina B"], [9, 10, "Skupina B"], [7, 8, "Skupina B"],
                ["4. ze sk. A", "5. ze sk. B", "Sk. o 8.-11. m√≠sto"],
                ["1. ze sk. A", "2. ze sk. B", "Semifin√°le 1"],
                ["5. ze sk. A", "6. ze sk. B", "Sk. o 8.-11. m√≠sto"],
                ["1. ze sk. B", "2. ze sk. A", "Semifin√°le 2"],
                ["4. ze sk. A", "6. ze sk. B", "Sk. o 8.-11. m√≠sto"],
                ["3. ze sk. A", "3. ze sk. B", "o 5. m√≠sto"],
                ["5. ze sk. A", "5. ze sk. B", "Sk. o 8.-11. m√≠sto"],
                ["4. ze sk. B", "5. ze sk. B", "o 7. m√≠sto"],
                ["4. ze sk. A", "5. ze sk. B", "Sk. o 8.-11. m√≠sto"],
                ["Pora≈æen√Ω SF1", "Pora≈æen√Ω SF2", "o 3. m√≠sto"],
                ["5. ze sk. A", "6. ze sk. B", "Sk. o 8.-11. m√≠sto"],
                ["V√≠tƒõz SF1", "V√≠tƒõz SF2", "Fin√°le"]
            ],
            "12_groups": [
                [1, 2, "Skupina A"], [7, 8, "Skupina B"], [3, 4, "Skupina A"], [9, 10, "Skupina B"],
                [5, 6, "Skupina A"], [11, 12, "Skupina B"], [1, 4, "Skupina A"], [7, 10, "Skupina B"],
                [2, 6, "Skupina A"], [8, 12, "Skupina B"], [3, 5, "Skupina A"], [9, 11, "Skupina B"],
                [1, 6, "Skupina A"], [7, 12, "Skupina B"], [4, 5, "Skupina A"], [10, 11, "Skupina B"],
                [2, 3, "Skupina A"], [8, 9, "Skupina B"], [1, 5, "Skupina A"], [7, 11, "Skupina B"],
                [3, 6, "Skupina A"], [9, 12, "Skupina B"], [2, 4, "Skupina A"], [8, 10, "Skupina B"],
                [1, 3, "Skupina A"], [7, 9, "Skupina B"], [2, 5, "Skupina A"], [8, 11, "Skupina B"],
                [4, 6, "Skupina A"], [10, 12, "Skupina B"],
                ["6. ze sk. A", "6. ze sk. B", "o 11. m√≠sto"],
                ["1. ze sk. A", "2. ze sk. B", "Semifin√°le 1"],
                ["5. ze sk. A", "5. ze sk. B", "o 9. m√≠sto"],
                ["1. ze sk. B", "2. ze sk. A", "Semifin√°le 2"],
                ["4. ze sk. A", "4. ze sk. B", "o 7. m√≠sto"],
                ["Pora≈æen√Ω SF1", "Pora≈æen√Ω SF2", "o 3. m√≠sto"],
                ["3. ze sk. A", "3. ze sk. B", "o 5. m√≠sto"],
                ["V√≠tƒõz SF1", "V√≠tƒõz SF2", "Fin√°le"]
            ],
            "12_groups_rr": [
                [1, 2, "Skupina A"], [5, 6, "Skupina B"], [9, 10, "Skupina C"],
                [3, 4, "Skupina A"], [7, 8, "Skupina B"], [11, 12, "Skupina C"],
                [1, 3, "Skupina A"], [5, 7, "Skupina B"], [9, 11, "Skupina C"],
                [2, 4, "Skupina A"], [6, 8, "Skupina B"], [10, 12, "Skupina C"],
                [1, 4, "Skupina A"], [5, 8, "Skupina B"], [9, 12, "Skupina C"],
                [2, 3, "Skupina A"], [6, 7, "Skupina B"], [10, 11, "Skupina C"],
                ["4. ze sk. A", "4. ze sk. B", "o 9.-12. m√≠sto"],
                ["1. ze sk. A", "1. ze sk. B", "o 1.-4. m√≠sto"],
                ["4. ze sk. C", "Best of 3rd", "o 9.-12. m√≠sto"],
                ["1. ze sk. C", "Best of 2nd", "o 1.-4. m√≠sto"],
                ["2. ze sk. A", "2. ze sk. B", "o 5.-8. m√≠sto"],
                ["4. ze sk. A", "4. ze sk. C", "o 9.-12. m√≠sto"],
                ["1. ze sk. A", "1. ze sk. C", "o 1.-4. m√≠sto"],
                ["2. ze sk. C", "2. Best 3rd", "o 5.-8. m√≠sto"],
                ["4. ze sk. B", "Best of 3rd", "o 9.-12. m√≠sto"],
                ["1. ze sk. B", "Best of 2nd", "o 1.-4. m√≠sto"],
                ["2. ze sk. A", "2. ze sk. C", "o 5.-8. m√≠sto"],
                ["4. ze sk. A", "Best of 3rd", "o 9.-12. m√≠sto"],
                ["1. ze sk. A", "Best of 2nd", "o 1.-4. m√≠sto"],
                ["2. ze sk. B", "2. Best 3rd", "o 5.-8. m√≠sto"],
                ["4. ze sk. B", "4. ze sk. C", "o 9.-12. m√≠sto"],
                ["2. ze sk. A", "2. Best 3rd", "o 5.-8. m√≠sto"],
                ["2. ze sk. B", "2. ze sk. C", "o 5.-8. m√≠sto"],
                ["1. ze sk. B", "1. ze sk. C", "o 1.-4. m√≠sto"],
                ["1. ze sk. C", "Best of 2nd", "o 1.-4. m√≠sto"]
            ],
            "13_groups": [
                [1, 2, "Skupina A"], [5, 6, "Skupina B"], [9, 10, "Skupina C"], [3, 4, "Skupina A"],
                [7, 8, "Skupina B"], [11, 12, "Skupina C"], [1, 3, "Skupina A"], [5, 7, "Skupina B"],
                [9, 13, "Skupina C"], [2, 4, "Skupina A"], [6, 8, "Skupina B"], [10, 11, "Skupina C"],
                [1, 4, "Skupina A"], [5, 8, "Skupina B"], [12, 13, "Skupina C"], [2, 3, "Skupina A"],
                [6, 7, "Skupina B"], [9, 11, "Skupina C"], [10, 13, "Skupina C"], [9, 12, "Skupina C"],
                [11, 13, "Skupina C"], [10, 12, "Skupina C"],
                ["T√Ωm 9-13", "T√Ωm 9-13", "o 9.-13. m√≠sto"],
                ["1. ze sk. A", "Playoff Slot", "Semifin√°le 1"],
                ["T√Ωm 5-8", "T√Ωm 5-8", "o 5.-8. m√≠sto"],
                ["1. ze sk. B", "Playoff Slot", "Semifin√°le 2"],
                ["T√Ωm 9-13", "T√Ωm 9-13", "o 9.-13. m√≠sto"],
                ["Pora≈æen√Ω SF1", "Pora≈æen√Ω SF2", "o 3. m√≠sto"],
                ["V√≠tƒõz SF1", "V√≠tƒõz SF2", "Fin√°le"]
            ],
            "13_groups_rr": [
                [1, 2, "Skupina A"], [5, 6, "Skupina B"], [9, 10, "Skupina C"], [3, 4, "Skupina A"],
                [7, 8, "Skupina B"], [11, 12, "Skupina C"], [1, 3, "Skupina A"], [5, 7, "Skupina B"],
                [13, 9, "Skupina C"], [11, 10, "Skupina C"], [1, 4, "Skupina A"], [5, 8, "Skupina B"],
                [12, 13, "Skupina C"], [9, 11, "Skupina C"], [10, 13, "Skupina C"], [9, 12, "Skupina C"],
                [11, 13, "Skupina C"], [10, 12, "Skupina C"], [2, 3, "Skupina A"], [6, 7, "Skupina B"],
                ["4. ze sk. A", "4. ze sk. B", "o 9.-13. m√≠sto"],
                ["1. ze sk. A", "1. ze sk. B", "o 1.-4. m√≠sto"],
                ["2. ze sk. A", "2. ze sk. B", "o 5.-8. m√≠sto"],
                ["T√Ωm o 9.-13.", "T√Ωm o 9.-13.", "o 9.-13. m√≠sto"],
                ["Fin√°lov√Ω blok", "Fin√°lov√Ω blok", "o 1.-4. m√≠sto"],
                ["V√≠tƒõz SF", "V√≠tƒõz SF", "Fin√°le"]
            ],
            "14_groups_rr": [
                [1, 2, "Skupina A"], [5, 6, "Skupina B"], [10, 11, "Skupina C"], [3, 4, "Skupina A"],
                [7, 8, "Skupina B"], [12, 13, "Skupina C"], [1, 3, "Skupina A"], [9, 5, "Skupina B"],
                [14, 10, "Skupina C"], [2, 4, "Skupina A"], [6, 7, "Skupina B"], [11, 12, "Skupina C"],
                [1, 4, "Skupina A"], [8, 9, "Skupina B"], [13, 14, "Skupina C"], [2, 3, "Skupina A"],
                [5, 7, "Skupina B"], [10, 12, "Skupina C"], [6, 8, "Skupina B"], [11, 13, "Skupina C"],
                [5, 8, "Skupina B"], [10, 13, "Skupina C"], [6, 9, "Skupina B"], [11, 14, "Skupina C"],
                [7, 9, "Skupina B"], [12, 14, "Skupina C"],
                ["T√Ωm 9-14", "T√Ωm 9-14", "o 9.-14. m√≠sto"],
                ["1. ze sk. A", "1. ze sk. B", "o 1.-4. m√≠sto"],
                ["T√Ωm 5-8", "T√Ωm 5-8", "o 5.-8. m√≠sto"],
                ["1. ze sk. C", "T√Ωm 2.m√≠sto", "o 1.-4. m√≠sto"],
                ["T√Ωm 9-14", "T√Ωm 9-14", "o 9.-14. m√≠sto"],
                ["V√≠tƒõzov√© SF", "V√≠tƒõzov√© SF", "Fin√°le"]
            ],
            "15_groups_rr": [
                [1, 2, "Skupina A"], [6, 7, "Skupina B"], [11, 12, "Skupina C"], [3, 4, "Skupina A"],
                [8, 9, "Skupina B"], [13, 14, "Skupina C"], [1, 5, "Skupina A"], [6, 10, "Skupina B"],
                [11, 15, "Skupina C"], [2, 3, "Skupina A"], [7, 8, "Skupina B"], [12, 13, "Skupina C"],
                [4, 5, "Skupina A"], [9, 10, "Skupina B"], [14, 15, "Skupina C"], [1, 3, "Skupina A"],
                [6, 8, "Skupina B"], [11, 13, "Skupina C"], [2, 4, "Skupina A"], [7, 9, "Skupina B"],
                [12, 14, "Skupina C"], [3, 5, "Skupina A"], [8, 10, "Skupina B"], [13, 15, "Skupina C"],
                [1, 4, "Skupina A"], [6, 9, "Skupina B"], [11, 14, "Skupina C"], [2, 5, "Skupina A"],
                [7, 10, "Skupina B"], [12, 15, "Skupina C"],
                ["T√Ωm 11-15", "T√Ωm 11-15", "o 11.-15. m√≠sto"],
                ["1. ze sk. A", "1. ze sk. B", "o 1.-5. m√≠sto"],
                ["T√Ωm 6-10", "T√Ωm 6-10", "o 6.-10. m√≠sto"],
                ["1. ze sk. C", "T√Ωm 1.-5.", "o 1.-5. m√≠sto"],
                ["T√Ωm o um√≠stƒõn√≠", "T√Ωm o um√≠stƒõn√≠", "o um√≠stƒõn√≠"],
                ["V√≠tƒõzov√© SF", "V√≠tƒõzov√© SF", "Fin√°le"]
            ]
        };

        let state = {
            isProjectionMode: window.location.search.includes('projection'),
            tournamentName: "",
            times: { setup: 10, play: 420, break: 105 }, // in seconds
            teams: [],
            teamLogos: {}, // Mapping team name to Base64
            teamAnthems: {}, // Mapping team name to Base64 (MP3)
            volSignal: 0.5,
            volAnthem: 0.5,
            referees: [],
            currentMatch: {
                title: "",
                homeName: "Dom√°c√≠",
                guestName: "Host√©",
                homeScore: 0,
                guestScore: 0,
                referee: "",
                phaseIndex: 0, // 0-3
                isEvent: false,
                duration: 600
            },
            audioData: null, // Base64 string of the audio file
            timer: {
                running: false,
                timeLeft: 0,
                lastTick: 0,
                targetEndTime: 0
            },
            pendingEditIndex: -1, // Tracks which match is being edited
            schedule: [],
            activeMatchIndex: -1, // Track which match from schedule is active
            theme: "dark", // Default to dark for better initial projection appearance
            poTransitionActive: false,
            poTransitionData: null,
            poTransitionDelay: 10,
            volMusic: 0.5,
            musicPlaylist: [], // { name: string, handle: FileSystemFileHandle }
            musicAutoEnabled: false,
            musicMode: 'continuous', // 'continuous' or 'random'
            musicFadeDuration: 1,
            musicAutoChangeStrategy: 'continuous', // 'continuous', 'per-step', 'per-match'
            musicPreviousPhase: -1, // Track previous phase for direction detection
            selectedIndices: [], // Track selected matches
            tournamentStartTime: null, // Timestamp when first timer starts
            playTimeAccumulated: 0, // Seconds of actual play time (halves) completed
            showFooter: true,
            scheduleModificationMode: 'append' // 'append' or 'replace'
        };


        let musicAudioA = new Audio();
        let musicAudioB = new Audio();
        let currentMusicAudio = musicAudioA; // Which one is currently playing
        let currentAnthemAudio = null;
        let currentMusicIndex = -1;
        let directoryHandle = null;

        let poTransitionTimeoutID = null;

        // --- CORE LOGIC CLASS ---
        const game = {
            init: () => {
                if (state.isProjectionMode) {
                    document.body.classList.add('mode-projection');

                    console.log("Projection: INIT starting");

                    ui.updateProjection();

                    // HANDLER for both BroadcastChannel and Direct window messages
                    const handleSync = (receivedState) => {
                        if (!receivedState || typeof receivedState !== 'object') return;
                        if (receivedState === 'REQUEST_SYNC') return; // Ignore strings

                        const mode = state.isProjectionMode;
                        Object.assign(state, receivedState);
                        state.isProjectionMode = mode;

                        // Data received
                        ui.updateProjection();
                    };

                    // 1. BroadcastChannel Listener (for OBS / different origins)
                    syncChannel.onmessage = (event) => handleSync(event.data);

                    // 2. Window Message Listener (for window.open direct communication)
                    window.addEventListener('message', (event) => handleSync(event.data));

                    // Request immediate sync from admin
                    syncChannel.postMessage('REQUEST_SYNC');

                    // Initial update for clock
                    setInterval(() => {
                        const now = new Date();
                        const dateStr = now.getFullYear() + '-' + (now.getMonth() + 1).toString().padStart(2, '0') + '-' + now.getDate().toString().padStart(2, '0');
                        const timeEl = document.getElementById('p-footer-time');
                        if (timeEl) timeEl.innerText = `${dateStr}\u00A0\u00A0\u00A0\u00A0${now.toLocaleTimeString('cs-CZ')}`;
                    }, 1000);
                    return;
                }

                try {
                    admin.loadFromStorage();
                    ui.renderSchedule();
                    ui.render();

                    // Listen for sync requests from projection windows
                    syncChannel.onmessage = (event) => {
                        if (event.data === 'REQUEST_SYNC') {
                            game.syncProjection();
                        }
                    };

                    setInterval(() => game.tick(), 100);
                    setInterval(() => ui.updateAdminFooter(), 1000);
                } catch (e) {
                    console.error("Initialization error:", e);
                }
            },

            tick: () => {
                if (!state.timer.running) return;

                const now = Date.now();
                const remainingMs = state.timer.targetEndTime - now;
                const newTimeLeft = Math.max(0, Math.floor(remainingMs / 1000));

                // Track play time accumulation
                if (state.currentMatch.phaseIndex === 1 || state.currentMatch.phaseIndex === 3) {
                    const elapsedSinceLastTick = (now - state.timer.lastTick) / 1000;
                    state.playTimeAccumulated += elapsedSinceLastTick;
                }
                state.timer.lastTick = now;

                if (newTimeLeft !== state.timer.timeLeft) {
                    state.timer.timeLeft = newTimeLeft;

                    if (state.timer.timeLeft <= 0) {
                        state.timer.timeLeft = 0;
                        game.toggleTimer(); // Stop at 0

                        // Play signal only for 1. Poloƒças (1) and 2. Poloƒças (3)
                        if (state.currentMatch.phaseIndex === 1 || state.currentMatch.phaseIndex === 3) {
                            game.playSignal();
                        }
                    }

                    ui.updateTimer();
                    game.syncProjection();
                    ui.updateAdminFooter();
                }
            },

            toggleTimer: () => {
                state.timer.running = !state.timer.running;
                if (state.timer.running) {
                    state.timer.lastTick = Date.now();
                    state.timer.targetEndTime = Date.now() + (state.timer.timeLeft * 1000) - 1;
                    // Set tournament start time if not already set
                    if (state.tournamentStartTime === null) {
                        state.tournamentStartTime = Date.now();
                    }
                    // Immediate first tick to reflect visual change (e.g. 7:00 -> 6:59)
                    game.tick();
                } else {
                    // When pausing, state.timer.timeLeft is already up to date from tick()
                    // but we capture the exact remaining time (float) to preserve precision for resume
                    const remainingMs = state.timer.targetEndTime - Date.now();
                    state.timer.timeLeft = Math.max(0, remainingMs / 1000);
                }
                ui.updateTimerBtn();
                game.syncProjection();
            },

            getPhaseCount: () => {
                return state.currentMatch.isEvent ? 1 : PHASES.length;
            },

            resetTimer: () => {
                state.timer.running = false;
                if (state.currentMatch.isEvent) {
                    state.timer.timeLeft = state.currentMatch.duration || 600;
                } else {
                    const currentPhase = PHASES[state.currentMatch.phaseIndex];
                    state.timer.timeLeft = state.times[currentPhase.timeKey];
                }
                state.timer.targetEndTime = Date.now() + (state.timer.timeLeft * 1000);

                ui.updateTimer();
                ui.updateTimerBtn();
                game.syncProjection();
            },

            adjustTime: (seconds) => {
                state.timer.timeLeft += seconds;
                if (state.timer.timeLeft < 0) state.timer.timeLeft = 0;
                if (state.timer.running) {
                    state.timer.targetEndTime += (seconds * 1000);
                }
                ui.updateTimer();
                game.syncProjection();
            },

            manualTimeEntry: () => {
                const el = document.getElementById('main-timer');
                const val = el.textContent.trim();
                const parts = val.split(':');
                if (parts.length === 2) {
                    const m = parseInt(parts[0]);
                    const s = parseInt(parts[1]);
                    if (!isNaN(m) && !isNaN(s)) {
                        state.timer.timeLeft = (m * 60) + s;
                        if (state.timer.running) {
                            state.timer.targetEndTime = Date.now() + (state.timer.timeLeft * 1000);
                        }
                    }
                }
                ui.updateTimer();
                game.syncProjection();
            },

            adjustScore: (team, delta, playSound = false) => {
                const isHome = team === 'home';
                if (isHome) {
                    state.currentMatch.homeScore += delta;
                    if (state.currentMatch.homeScore < 0) state.currentMatch.homeScore = 0;
                } else {
                    state.currentMatch.guestScore += delta;
                    if (state.currentMatch.guestScore < 0) state.currentMatch.guestScore = 0;
                }

                if (playSound && delta > 0) {
                    const teamName = isHome ? state.currentMatch.homeName : state.currentMatch.guestName;
                    game.playTeamAnthem(teamName);
                }

                ui.updateScores();
                game.syncProjection();
            },

            playTeamAnthem: (teamName) => {
                const audioData = state.teamAnthems[teamName];
                if (audioData) {
                    if (currentAnthemAudio) {
                        currentAnthemAudio.pause();
                        currentAnthemAudio = null;
                    }

                    // P≈ôeru≈°it hudbu na pozad√≠, pokud hraje
                    if (!currentMusicAudio.paused) {
                        currentMusicAudio.pause();
                        clearInterval(music.fadeInterval);
                        music.fadeInterval = null;
                    }

                    currentAnthemAudio = new Audio(audioData);
                    currentAnthemAudio.volume = state.volAnthem || 1.0;
                    currentAnthemAudio.play().catch(e => console.warn("Anthem play failed:", e));
                }
            },

            triggerPoTransition: (snapshot) => {
                if (poTransitionTimeoutID) clearTimeout(poTransitionTimeoutID);

                state.poTransitionData = snapshot;
                state.poTransitionActive = true;

                poTransitionTimeoutID = setTimeout(() => {
                    state.poTransitionActive = false;
                    state.poTransitionData = null;
                    game.syncProjection();
                }, (state.poTransitionDelay || 10) * 1000);
            },

            step: (direction) => {
                let newPhaseIndex = state.currentMatch.phaseIndex + direction;
                const phaseCount = game.getPhaseCount();

                // Moving Forward past last phase -> Next Match
                if (newPhaseIndex >= phaseCount) {
                    if (game.loadMatchByRelativeIndex(1)) {
                        // Match loaded, transition handled inside loadMatchByRelativeIndex
                        return;
                    } else {
                        // No next match, stay at end
                        // BUT still save the result of the current last match!
                        if (!state.currentMatch.isEvent && state.activeMatchIndex !== -1 && state.schedule[state.activeMatchIndex]) {
                            state.schedule[state.activeMatchIndex].homeScore = state.currentMatch.homeScore;
                            state.schedule[state.activeMatchIndex].guestScore = state.currentMatch.guestScore;
                            ui.renderSchedule();
                            admin.saveToStorage();
                            alert("Konec turnaje (nebo posledn√≠ z√°pas). V√Ωsledek ulo≈æen.");
                        }
                        newPhaseIndex = phaseCount - 1;
                    }
                }

                // Moving Backward before first phase -> Prev Match
                if (newPhaseIndex < 0) {
                    if (game.loadMatchByRelativeIndex(-1)) {
                        // Match loaded, phase set inside that function (to last)
                        return;
                    } else {
                        newPhaseIndex = 0;
                    }
                }

                if (newPhaseIndex !== state.currentMatch.phaseIndex) {
                    game.setPhase(newPhaseIndex, true);
                }
            },

            setPhase: (index, resetTime) => {
                // P≈ôeru≈°it prodlevu/blik√°n√≠, pokud zaƒç√≠n√° poloƒças (index 1 nebo 3)
                if ((index === 1 || index === 3) && state.poTransitionActive) {
                    if (poTransitionTimeoutID) clearTimeout(poTransitionTimeoutID);
                    state.poTransitionActive = false;
                    state.poTransitionData = null;
                }

                state.currentMatch.phaseIndex = index;
                if (resetTime) {
                    game.resetTimer();
                }

                // Auto music control
                const previousPhase = state.musicPreviousPhase;
                state.musicPreviousPhase = index; // Update for next time

                if (index === 0 || index === 2) {
                    music.resumeAuto(index, previousPhase); // Pass current and previous phase
                } else {
                    music.pauseAuto(); // Pause (not stop)
                }

                ui.renderPhase();
                game.syncProjection();
            },

            // Returns true if match change was successful
            loadMatchByRelativeIndex: (offset) => {
                // Auto-Save Score of currently active match before switching
                if (state.activeMatchIndex !== -1 && state.schedule[state.activeMatchIndex]) {
                    state.schedule[state.activeMatchIndex].homeScore = state.currentMatch.homeScore;
                    state.schedule[state.activeMatchIndex].guestScore = state.currentMatch.guestScore;
                }

                let targetIndex = state.activeMatchIndex;
                if (targetIndex === -1) {
                    if (offset > 0) targetIndex = 0;
                } else {
                    targetIndex += offset;
                }

                if (targetIndex >= 0 && targetIndex < state.schedule.length) {
                    // Capture snapshot for PO delay only when moving to NEXT match
                    let snapshot = null;
                    if (offset > 0) {
                        snapshot = JSON.parse(JSON.stringify(state));
                    }

                    admin.loadMatch(targetIndex, false, snapshot);

                    // Check if we should change track when loading new match
                    if (state.musicAutoChangeStrategy === 'per-match' && state.musicAutoEnabled) {
                        music.startNewTrack();
                    }

                    if (offset < 0) {
                        game.setPhase(game.getPhaseCount() - 1, true);
                    } else {
                        game.setPhase(0, true);
                    }
                    return true;
                }
                return false;
            },

            getTelemetry: () => {
                const now = new Date();
                const dateStr = now.getFullYear() + '-' + (now.getMonth() + 1).toString().padStart(2, '0') + '-' + now.getDate().toString().padStart(2, '0');
                const timeStr = now.toLocaleTimeString('cs-CZ');
                const fullTimeStr = `${dateStr}\u00A0\u00A0\u00A0\u00A0${timeStr}`;

                const currentIdx = state.activeMatchIndex;
                const totalItems = (state.schedule || []).length;
                const progressStr = `Pr√°vƒõ se hraje: ${currentIdx + 1} z ${totalItems}`;

                // Extrapolation logic
                let learnedOverhead = 60; // Default seed
                if (state.tournamentStartTime && state.activeMatchIndex > 0) {
                    const realElapsed = (Date.now() - state.tournamentStartTime) / 1000;
                    const playElapsed = state.playTimeAccumulated || 0;
                    const totalOverhead = Math.max(0, realElapsed - playElapsed);
                    learnedOverhead = totalOverhead / state.activeMatchIndex;
                    // Clamp to reasonable range (10s to 10 mins)
                    learnedOverhead = Math.max(10, Math.min(600, learnedOverhead));
                }

                let remainingSeconds = state.timer.running
                    ? (state.timer.targetEndTime - Date.now()) / 1000
                    : state.timer.timeLeft;

                // Current item progress
                if (!state.currentMatch.isEvent) {
                    const curPhase = state.currentMatch.phaseIndex;
                    const playDur = state.times.play || 420;
                    if (curPhase === 0) { // Setup
                        remainingSeconds += (playDur * 2) + (learnedOverhead / 2); // 2 halves + break
                    } else if (curPhase === 1) { // 1. Polocas
                        remainingSeconds += playDur + (learnedOverhead / 2); // 2nd half + break
                    } else if (curPhase === 2) { // Break
                        remainingSeconds += playDur; // 2nd half
                    }
                    // ph 3 (2. Polocas) is just timeLeft
                }

                // Upcoming items
                (state.schedule || []).slice(currentIdx + 1).forEach(m => {
                    if (m.type === 'event') {
                        remainingSeconds += (m.duration || 600);
                    } else {
                        remainingSeconds += ((state.times.play || 420) * 2) + learnedOverhead;
                    }
                });

                const endTime = new Date(now.getTime() + remainingSeconds * 1000);
                const endStr = `P≈ôedpokl√°dan√Ω konec: ${endTime.toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' })}`;

                return {
                    progress: progressStr,
                    end: endStr,
                    time: fullTimeStr
                };
            },

            syncProjection: () => {
                const payload = { ...state, telemetry: game.getTelemetry() };
                // Send to BroadcastChannel for all listeners (OBS, other tabs)
                syncChannel.postMessage(JSON.parse(JSON.stringify(payload)));

                // Legacy window.postMessage for the specific window opened via button
                if (projectionWindow && !projectionWindow.closed) {
                    projectionWindow.postMessage(JSON.parse(JSON.stringify(payload)), '*');
                }
                ui.updateAdminFooter();
            },

            reorderSchedule: (fromIndex, toIndex) => {
                const item = state.schedule.splice(fromIndex, 1)[0];
                state.schedule.splice(toIndex, 0, item);

                // Adjust active match index if needed
                if (state.activeMatchIndex === fromIndex) {
                    state.activeMatchIndex = toIndex;
                } else if (state.activeMatchIndex > fromIndex && state.activeMatchIndex <= toIndex) {
                    state.activeMatchIndex--;
                } else if (state.activeMatchIndex < fromIndex && state.activeMatchIndex >= toIndex) {
                    state.activeMatchIndex++;
                }

                ui.renderSchedule();
                admin.saveToStorage();
            },

            playSignal: () => {
                // P≈ôeru≈°it aktu√°lnƒõ hraj√≠c√≠ jingle, pokud nƒõjak√Ω hraje
                if (currentAnthemAudio) {
                    currentAnthemAudio.pause();
                    currentAnthemAudio = null;
                }

                // P≈ôeru≈°it hudbu na pozad√≠, pokud hraje
                if (!currentMusicAudio.paused) {
                    currentMusicAudio.pause();
                    clearInterval(music.fadeInterval);
                    music.fadeInterval = null;
                }

                if (state.audioData) {
                    try {
                        const snd = new Audio(state.audioData);
                        snd.volume = state.volSignal || 1.0;
                        snd.play().catch(e => console.error("Audio play failed:", e));
                    } catch (err) {
                        console.error("Invalid audio data", err);
                    }
                }
            }
        };

        // --- ADMIN HELPERS ---
        const admin = {
            saveSettings: (showAlert = true) => {
                state.tournamentName = document.getElementById('input-tournament-name').value;

                state.times.setup = Math.max(0, parseInt(document.getElementById('time-setup').value || 10));
                state.times.play = Math.max(0, parseInt(document.getElementById('time-play').value || 420));
                state.times.break = Math.max(0, parseInt(document.getElementById('time-break').value || 105));

                // Save teams from dynamic list
                state.teams = [];
                const teamInputs = document.querySelectorAll('.team-name-input');
                teamInputs.forEach(input => {
                    const id = input.dataset.id;
                    const name = input.value.trim();
                    if (id) {
                        state.teams.push({ id, name: name || "Dru≈æstvo" });
                    }
                });

                // Save referees from dynamic list
                state.referees = [];
                const refInputs = document.querySelectorAll('.ref-name-input');
                refInputs.forEach(input => {
                    const id = input.dataset.id;
                    const name = input.value.trim();
                    if (id) {
                        state.referees.push({ id, name: name || "Rozhodƒç√≠" });
                    }
                });

                state.volSignal = parseFloat(document.getElementById('input-vol-signal').value);
                state.volAnthem = parseFloat(document.getElementById('input-vol-anthem').value);
                state.showFooter = document.getElementById('input-show-footer').checked;
                state.theme = document.getElementById('input-theme').value;
                state.poTransitionDelay = Math.max(1, Math.min(30, parseInt(document.getElementById('input-po-delay').value || 10)));

                const fileInput = document.getElementById('input-audio-file');
                if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    if (file.size > 2 * 1024 * 1024) { // 2MB limit check
                        alert("Soubor je p≈ô√≠li≈° velk√Ω (>2MB). Zvolte men≈°√≠ MP3.");
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        state.audioData = e.target.result;
                        finishSave();
                    };
                    reader.readAsDataURL(file);
                } else {
                    finishSave();
                }

                function finishSave() {
                    admin.saveToStorage();
                    ui.fillSelects();
                    ui.renderSchedule();
                    admin.renderIdentityInputs(); // Refresh labels
                    ui.updateFooterVisibility();
                    game.resetTimer();
                    game.syncProjection();
                    if (showAlert) alert("Nastaven√≠ ulo≈æeno.");
                }
            },

            renderIdentityInputs: () => {
                // Teams
                const teamList = document.getElementById('teams-input-list');
                teamList.innerHTML = "";
                state.teams.forEach((team, idx) => {
                    admin.renderIdentityRow(teamList, team, idx, 'team');
                });

                // Referees
                const refList = document.getElementById('referees-input-list');
                refList.innerHTML = "";
                state.referees.forEach((ref, idx) => {
                    admin.renderIdentityRow(refList, ref, idx, 'ref');
                });
            },

            renderIdentityRow: (container, item, index, type) => {
                const div = document.createElement('div');
                div.style.display = "flex";
                div.style.gap = "5px";
                div.style.alignItems = "center";

                const label = document.createElement('span');
                label.style.width = "80px";
                label.style.fontSize = "0.8em";
                label.style.color = "#888";
                label.innerText = (type === 'team' ? "Dru≈æstvo " : "Rozhodƒç√≠ ") + (index + 1);

                const input = document.createElement('input');
                input.type = "text";
                input.className = type === 'team' ? "team-name-input" : "ref-name-input";
                input.dataset.id = item.id;
                input.value = item.name;
                input.maxLength = 20;
                input.style.flex = "1";
                input.oninput = () => {
                    item.name = input.value;
                    if (type === 'team') {
                        admin.renderLogoSettings();
                        ui.updateNames();
                    }
                    ui.fillSelects();
                    ui.renderSchedule();
                    admin.saveToStorage(); // Auto-save on name change
                };

                const removeBtn = document.createElement('button');
                removeBtn.className = "small-btn btn-red";
                removeBtn.innerText = "x";
                removeBtn.onclick = () => {
                    if (type === 'team') {
                        state.teams = state.teams.filter(t => t.id !== item.id);
                    } else {
                        state.referees = state.referees.filter(r => r.id !== item.id);
                    }
                    admin.renderIdentityInputs();
                    admin.renderLogoSettings();
                    admin.saveToStorage(); // Auto-save on removal
                };

                div.appendChild(label);
                div.appendChild(input);
                div.appendChild(removeBtn);
                container.appendChild(div);
            },

            addTeamSlot: () => {
                const id = "team_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                state.teams.push({ id, name: "" });
                admin.renderIdentityInputs();
                admin.saveToStorage();
            },

            addRefereeSlot: () => {
                const id = "ref_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
                state.referees.push({ id, name: "" });
                admin.renderIdentityInputs();
                admin.saveToStorage();
            },

            propagateRenames: (oldList, newList, type) => {
                // This helper is largely deprecated but kept for manual logic if needed.
                // ID-based system handles renames implicitly.
            },

            resetApp: () => {
                if (confirm("Opravdu chcete vymazat v≈°echna data aplikace (t√Ωmy, rozpis, zvuk)? Tuto akci nelze vz√≠t zpƒõt.")) {
                    localStorage.removeItem('scoreboardState');
                    location.reload();
                }
            },

            getTeamName: (id) => {
                const t = state.teams.find(x => x.id === id);
                return t ? t.name : (id ? id : "T√Ωm");
            },

            getRefName: (id) => {
                if (!id) return "-";
                const r = state.referees.find(x => x.id === id);
                return r ? r.name : id;
            },

            updateCurrentMatch: () => {
                // Manually updating from input fields is deprecated as fields were removed.
                // Keeping function stub if needed for future logic, or removing.
                // For now, let's just sync projection if called.
                ui.updateNames();
                game.syncProjection();
            },

            generateScheduleFromTemplate: () => {
                const count = parseInt(document.getElementById('sched-template-select').value);
                if (!count || !SCHEDULE_TEMPLATES[count]) return;

                if (state.teams.length < count) {
                    alert(`Pro toto sch√©ma je pot≈ôeba definovat alespo≈à ${count} dru≈æstev. Aktu√°lnƒõ jich m√°te ${state.teams.length}.`);
                    return;
                }

                let appendMode = (state.scheduleModificationMode === 'append');

                // Prepare
                if (!appendMode) {
                    state.schedule = [];
                    state.activeMatchIndex = -1;
                }

                const startIdx = state.schedule.length;
                const pairs = SCHEDULE_TEMPLATES[count];
                const defaultDuration = (state.times.play * 2) + state.times.break;

                pairs.forEach((pair, idx) => {
                    // Resolve home team
                    let home = pair[0];
                    if (typeof home === 'number') {
                        home = state.teams[home - 1].id;
                    }

                    // Resolve guest team
                    let guest = pair[1];
                    if (typeof guest === 'number') {
                        guest = state.teams[guest - 1].id;
                    }

                    // Resolve title (optional 3rd element)
                    const title = pair[2] || `Z√°pas ${startIdx + idx + 1}`;

                    state.schedule.push({
                        type: 'match',
                        title: title,
                        home: home,
                        guest: guest,
                        referee: "",
                        homeScore: 0,
                        guestScore: 0,
                        phaseIndex: 0,
                        duration: defaultDuration
                    });
                });

                admin.saveSettings(false); // Silent save
                ui.renderSchedule();
                game.syncProjection();
                alert(`Rozpis pro ${count} dru≈æstev byl ${appendMode ? 'p≈ôid√°n' : 'vygenerov√°n'}.`);
            },

            addMatch: () => {
                const type = document.getElementById('sched-type').value;
                const isEvent = type === 'event';
                const titleSel = document.getElementById('sched-title');
                const customTitle = document.getElementById('sched-custom-title').value.trim();
                const title = (isEvent || customTitle) ? (customTitle || titleSel.value) : titleSel.value;

                const match = {
                    type,
                    title,
                    home: isEvent ? "" : document.getElementById('sched-home').value,
                    guest: isEvent ? "" : document.getElementById('sched-guest').value,
                    referee: isEvent ? "" : document.getElementById('sched-referee').value,
                    duration: isEvent ? parseInt(document.getElementById('sched-duration').value || 600) : null
                };
                state.schedule.push(match);
                admin.clearSchedInputs();
                admin.toggleScheduleForm(false); // Hide after add
                ui.renderSchedule();
                admin.saveToStorage();
            },

            toggleScheduleForm: (forceShow) => {
                const f = document.getElementById('sched-form-container');
                const btn = document.getElementById('btn-toggle-sched-form');

                let show = forceShow !== undefined ? forceShow : (f.style.display === 'none');

                f.style.display = show ? 'block' : 'none';
                if (btn) {
                    btn.innerHTML = show ? '<b style="font-weight: 900;">-</b> Zav≈ô√≠t formul√°≈ô' : '<b style="font-weight: 900;">+</b> P≈ôidat z√°pas';
                }

                if (show) {
                    const form = document.getElementById('sched-form-container');
                    const header = document.querySelector('#acc-schedule h4');
                    if (state.pendingEditIndex === -1 && form && header) {
                        // Move back to top (below header) if adding new
                        header.after(form);
                        admin.clearSchedInputs();
                    }
                }
            },

            toggleAddMode: () => {
                const f = document.getElementById('sched-form-container');
                const isVisible = f.style.display !== 'none';
                const isAdding = state.pendingEditIndex === -1;

                if (isVisible && isAdding) {
                    // Already adding - hide it
                    admin.toggleScheduleForm(false);
                } else {
                    // Closed or editing - switch to add mode
                    state.pendingEditIndex = -1;
                    admin.toggleScheduleForm(true);
                    ui.renderSchedule(); // Refresh highlighting
                }
            },

            editScheduleMatch: (index) => {
                state.pendingEditIndex = index;
                const m = state.schedule[index];
                const type = m.type || 'match';
                document.getElementById('sched-type').value = type;

                // Title handling
                const titleSel = document.getElementById('sched-title');
                const customInput = document.getElementById('sched-custom-title');
                let found = false;
                for (let i = 0; i < titleSel.options.length; i++) {
                    if (titleSel.options[i].value === m.title) {
                        titleSel.selectedIndex = i;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    customInput.value = m.title;
                    customInput.style.display = 'block';
                    titleSel.style.display = 'none';
                } else {
                    customInput.style.display = 'none';
                    titleSel.style.display = 'block';
                }

                document.getElementById('sched-home').value = m.home || "";
                document.getElementById('sched-guest').value = m.guest || "";
                document.getElementById('sched-referee').value = m.referee || "";
                document.getElementById('sched-home-score').value = (m.homeScore !== undefined && m.homeScore !== null) ? m.homeScore : "";
                document.getElementById('sched-guest-score').value = (m.guestScore !== undefined && m.guestScore !== null) ? m.guestScore : "";
                document.getElementById('sched-duration').value = m.duration || 600;

                admin.onSchedTypeChange(); // UI Sync

                // Toggle buttons
                document.getElementById('sched-controls-add').style.display = 'none';
                document.getElementById('sched-controls-edit').style.display = 'flex';

                // Ensure form section is open
                admin.toggleScheduleForm(true);

                // Open accordion if closed
                const acc = document.getElementById('acc-schedule');
                if (!acc.classList.contains('open')) acc.classList.add('open');

                ui.renderSchedule(); // RE-RENDER to move form and highlight match
            },

            saveEditedMatch: () => {
                if (state.pendingEditIndex > -1) {
                    const type = document.getElementById('sched-type').value;
                    const isEvent = type === 'event';
                    const titleSel = document.getElementById('sched-title');
                    const customTitle = document.getElementById('sched-custom-title').value.trim();
                    const title = (isEvent || customTitle) ? (customTitle || titleSel.value) : titleSel.value;

                    let hScore = document.getElementById('sched-home-score').value;
                    let gScore = document.getElementById('sched-guest-score').value;

                    // Validation: Ensure non-negative
                    let parsedH = hScore !== "" ? parseInt(hScore) : null;
                    let parsedG = gScore !== "" ? parseInt(gScore) : null;

                    if (parsedH !== null && parsedH < 0) parsedH = 0;
                    if (parsedG !== null && parsedG < 0) parsedG = 0;

                    state.schedule[state.pendingEditIndex] = {
                        type,
                        title,
                        home: isEvent ? "" : document.getElementById('sched-home').value,
                        guest: isEvent ? "" : document.getElementById('sched-guest').value,
                        referee: isEvent ? "" : document.getElementById('sched-referee').value,
                        homeScore: isEvent ? null : parsedH,
                        guestScore: isEvent ? null : parsedG,
                        duration: isEvent ? parseInt(document.getElementById('sched-duration').value || 600) : null
                    };
                    admin.cancelEdit(); // Reset UI
                    ui.renderSchedule();
                    admin.saveToStorage();
                    admin.toggleScheduleForm(false); // Hide
                }
            },

            deleteMatch: () => {
                if (state.pendingEditIndex > -1 && confirm("Opravdu smazat tento z√°pas?")) {
                    state.schedule.splice(state.pendingEditIndex, 1);
                    // Adjust active index if needed
                    if (state.activeMatchIndex === state.pendingEditIndex) state.activeMatchIndex = -1;
                    else if (state.activeMatchIndex > state.pendingEditIndex) state.activeMatchIndex--;

                    admin.cancelEdit();
                    ui.renderSchedule();
                    admin.saveToStorage();
                    admin.toggleScheduleForm(false); // Hide
                }
            },

            cancelEdit: () => {
                state.pendingEditIndex = -1;
                ui.renderSchedule(); // Re-render to clear highlights
                admin.clearSchedInputs();
                document.getElementById('sched-controls-add').style.display = 'block';
                document.getElementById('sched-controls-edit').style.display = 'none';
                admin.toggleScheduleForm(false); // Hide
            },

            clearSchedInputs: () => {
                document.getElementById('sched-type').value = "match";
                document.getElementById('sched-title').selectedIndex = 0;
                document.getElementById('sched-title').style.display = 'block';
                document.getElementById('sched-custom-title').value = "";
                document.getElementById('sched-custom-title').style.display = 'none';
                document.getElementById('sched-home').value = "";
                document.getElementById('sched-guest').value = "";
                document.getElementById('sched-referee').value = "";
                document.getElementById('sched-home-score').value = "";
                document.getElementById('sched-guest-score').value = "";
                document.getElementById('sched-duration').value = 600;
                admin.onSchedTypeChange();

                // CRITIAL FIX: Ensure dropdowns are populated if empty (e.g. after refresh)
                if (document.getElementById('sched-home').options.length <= 1) {
                    ui.fillSelects();
                }
            },

            setScheduleMode: (mode) => {
                document.querySelectorAll('.sched-section').forEach(s => s.classList.remove('active'));
                document.querySelectorAll('.sched-tab-btn').forEach(b => b.classList.remove('active'));

                document.getElementById(`sched-section-${mode}`).classList.add('active');
                document.getElementById(`tab-sched-${mode}`).classList.add('active');
            },

            setModificationMode: (mode) => {
                state.scheduleModificationMode = mode;
                document.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(`mode-sched-${mode}`).classList.add('active');
            },

            handleScheduleImport: (input) => {
                if (!input.files || !input.files[0]) return;
                const file = input.files[0];
                const mode = state.scheduleModificationMode === 'replace' ? 'overwrite' : 'append';

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const sheetName = workbook.SheetNames[0];
                        const sheet = workbook.Sheets[sheetName];
                        const json = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                        if (json.length < 1) {
                            alert("Soubor je pr√°zdn√Ω nebo neƒçiteln√Ω.");
                            return;
                        }

                        const newMatches = [];
                        let startRow = 0;
                        if (json[0] && json[0].length >= 2) {
                            const firstRowStr = json[0].join(" ").toLowerCase();
                            if (firstRowStr.includes("t√Ωm") || firstRowStr.includes("host") || firstRowStr.includes("z√°pas") || firstRowStr.includes("skupina")) {
                                startRow = 1;
                            }
                        }

                        let addedTeams = 0;
                        let addedRefs = 0;

                        for (let i = startRow; i < json.length; i++) {
                            const row = json[i];
                            if (!row || row.length < 2) continue;

                            const title = String(row[0] || "Z√°pas").trim();
                            const home = String(row[1] || "").trim();
                            const guest = String(row[2] || "").trim();
                            const ref = String(row[3] || "").trim();
                            const duration = parseInt(row[4] || 600);

                            if (!home && !guest && !title) continue;

                            newMatches.push({
                                type: 'match',
                                title: title,
                                home: home,
                                guest: guest,
                                referee: ref,
                                homeScore: null,
                                guestScore: null,
                                duration: duration
                            });

                            if (home && admin.ensureIdentityExists(home, 'team')) addedTeams++;
                            if (guest && admin.ensureIdentityExists(guest, 'team')) addedTeams++;
                            if (ref && admin.ensureIdentityExists(ref, 'ref')) addedRefs++;
                        }

                        if (mode === 'overwrite') {
                            state.schedule = newMatches;
                            state.activeMatchIndex = -1;
                        } else {
                            state.schedule = [...state.schedule, ...newMatches];
                        }

                        ui.renderSchedule();
                        admin.saveToStorage();
                        admin.renderIdentityInputs(); // Refresh lists
                        alert(`Importov√°no ${newMatches.length} z√°pas≈Ø.\n(P≈ôid√°no ${addedTeams} nov√Ωch t√Ωm≈Ø a ${addedRefs} rozhodƒç√≠ch)`);
                        input.value = "";
                    } catch (err) {
                        console.error(err);
                        alert("Chyba p≈ôi ƒçten√≠ souboru. Ujistƒõte se, ≈æe je to platn√Ω Excel nebo CSV.");
                    }
                };
                reader.readAsArrayBuffer(file);
            },

            ensureIdentityExists: (name, type) => {
                if (!name || name === "-" || name.toLowerCase() === "volno") return false;
                const list = type === 'team' ? state.teams : state.referees;
                const exists = list.some(item => item.name.toLowerCase() === name.toLowerCase());
                if (!exists) {
                    const id = (type === 'team' ? "team_" : "ref_") + Date.now() + "_" + Math.floor(Math.random() * 1000);
                    list.push({ id, name });
                    return true;
                }
                return false;
            },

            onSchedTypeChange: () => {
                const type = document.getElementById('sched-type').value;
                const isEvent = type === 'event';
                document.getElementById('sched-match-fields').style.display = isEvent ? 'none' : 'block';
                document.getElementById('sched-event-fields').style.display = isEvent ? 'block' : 'none';

                // Show custom title input for events, or allow toggle for match?
                // Let's force custom title for events.
                const titleSel = document.getElementById('sched-title');
                const customInput = document.getElementById('sched-custom-title');
                if (isEvent) {
                    titleSel.style.display = 'none';
                    customInput.style.display = 'block';
                } else {
                    titleSel.style.display = 'block';
                    customInput.style.display = 'none';
                }
            },

            moveMatch: (from, to) => {
                game.reorderSchedule(from, to);
            },

            renderLogoSettings: () => {
                const container = document.getElementById('team-logo-list');
                const teams = state.teams;

                if (teams.length === 0) {
                    container.innerHTML = '<div style="color:#666; font-size:0.8em;">P≈ôidejte dru≈æstva pro nahr√°n√≠ vlajek, log a jingles...</div>';
                    return;
                }

                container.innerHTML = '<small style="color:#aaa; display:block; margin-bottom:10px;">Dru≈æstva: vlajky, loga, jingly</small>';
                teams.forEach(teamObj => {
                    const team = teamObj.id;
                    const displayName = teamObj.name || "Dru≈æstvo";
                    const row = document.createElement('div');
                    row.style = 'display:flex; align-items:center; gap:10px; margin-bottom:8px; border-bottom:1px solid #444; padding-bottom:5px;';

                    const logoSrc = state.teamLogos[team] || '';
                    const hasAnthem = !!state.teamAnthems[team];

                    row.innerHTML = `
                        <div style="flex:1; font-size:0.9em; overflow:hidden; text-overflow:ellipsis;">${displayName}</div>
                        <img src="${logoSrc}" style="width:30px; height:30px; object-fit:contain; background:#444; border-radius:3px; display:${logoSrc ? 'block' : 'none'}">
                        
                        <input type="file" accept="image/*" style="display:none" id="logo-file-${team}" onchange="admin.handleLogoUpload('${team}', this)">
                        <button class="small-btn" onclick="document.getElementById('logo-file-${team}').click()" title="Nahr√°t Logo">üñºÔ∏è</button>
                        
                        <input type="file" accept="audio/*" style="display:none" id="anthem-file-${team}" onchange="admin.handleAnthemUpload('${team}', this)">
                        <button class="small-btn ${hasAnthem ? 'btn-green' : ''}" onclick="document.getElementById('anthem-file-${team}').click()" title="Nahr√°t Jingle">üéµ</button>
                    `;
                    container.appendChild(row);
                });
            },

            handleAnthemUpload: (teamName, input) => {
                if (input.files && input.files[0]) {
                    const file = input.files[0];
                    if (file.size > 1024 * 1024) {
                        alert("Jingle je p≈ô√≠li≈° velk√Ω (max 1MB).");
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        state.teamAnthems[teamName] = e.target.result;
                        admin.renderLogoSettings();
                    };
                    reader.readAsDataURL(file);
                }
            },

            handleLogoUpload: (teamName, input) => {
                if (input.files && input.files[0]) {
                    const file = input.files[0];
                    if (file.size > 500 * 1024) {
                        alert("Logo je p≈ô√≠li≈° velk√© (max 500KB).");
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        state.teamLogos[teamName] = e.target.result;
                        admin.renderLogoSettings();
                        ui.updateLogos();
                        game.syncProjection();
                    };
                    reader.readAsDataURL(file);
                }
            },

            loadMatch: (index, resetPhase = false, snapshot = null) => {
                // Handle PO transition
                if (snapshot) {
                    game.triggerPoTransition(snapshot);
                } else if (state.poTransitionActive) {
                    // Manual load - cancel transition
                    if (poTransitionTimeoutID) clearTimeout(poTransitionTimeoutID);
                    state.poTransitionActive = false;
                    state.poTransitionData = null;
                }

                const m = state.schedule[index];
                state.activeMatchIndex = index;
                state.currentMatch.isEvent = (m.type === 'event');
                state.currentMatch.title = m.title || "";
                state.currentMatch.homeName = m.home || "";
                state.currentMatch.guestName = m.guest || "";
                state.currentMatch.homeScore = m.homeScore || 0;
                state.currentMatch.guestScore = m.guestScore || 0;
                state.currentMatch.duration = m.duration || 600;

                ui.updateNames();
                ui.updateScores();
                ui.renderSchedule(); // update active highlight

                if (resetPhase) {
                    game.setPhase(0, true);
                }
            },

            toggleSelection: (index, isShift, isCtrl, silent = false) => {
                if (index < 0 || index >= state.schedule.length) return;

                // Cancel edit if clicking a different item (single click)
                if (!isShift && !isCtrl && state.pendingEditIndex !== -1) {
                    if (state.pendingEditIndex !== index) {
                        state.pendingEditIndex = -1;
                        admin.clearSchedInputs();
                        admin.toggleScheduleForm(false);
                    } else {
                        // Clicking the same item that's being edited - close it
                        state.pendingEditIndex = -1;
                        admin.clearSchedInputs();
                        admin.toggleScheduleForm(false);
                        ui.renderSchedule();
                        return; // Done
                    }
                }

                if (isShift && state.selectedIndices.length > 0) {
                    const last = state.selectedIndices[state.selectedIndices.length - 1];
                    const start = Math.min(last, index);
                    const end = Math.max(last, index);
                    // Add the range to current selection
                    for (let i = start; i <= end; i++) {
                        if (!state.selectedIndices.includes(i)) state.selectedIndices.push(i);
                    }
                } else if (isCtrl) {
                    const idx = state.selectedIndices.indexOf(index);
                    if (idx > -1) state.selectedIndices.splice(idx, 1);
                    else state.selectedIndices.push(index);
                } else {
                    state.selectedIndices = [index];
                }
                state.selectedIndices.sort((a, b) => a - b);
                if (!silent) ui.renderSchedule();
            },

            moveSelected: (direction) => {
                if (state.selectedIndices.length === 0) return;

                // Direction: -1 (up), 1 (down)
                // Need to move items without stepping on each other
                const indices = [...state.selectedIndices].sort((a, b) => direction > 0 ? b - a : a - b);

                let movedAny = false;
                const newSelection = [];

                indices.forEach(idx => {
                    const targetIdx = idx + direction;
                    if (targetIdx >= 0 && targetIdx < state.schedule.length) {
                        const item = state.schedule.splice(idx, 1)[0];
                        state.schedule.splice(targetIdx, 0, item);
                        newSelection.push(targetIdx);
                        movedAny = true;

                        // Adjust active match index
                        if (state.activeMatchIndex === idx) state.activeMatchIndex = targetIdx;
                        else if (direction > 0 && state.activeMatchIndex > idx && state.activeMatchIndex <= targetIdx) state.activeMatchIndex--;
                        else if (direction < 0 && state.activeMatchIndex < idx && state.activeMatchIndex >= targetIdx) state.activeMatchIndex++;
                    } else {
                        newSelection.push(idx);
                    }
                });

                if (movedAny) {
                    state.selectedIndices = newSelection.sort((a, b) => a - b);
                    ui.renderSchedule();
                    admin.saveToStorage();
                }
            },

            deleteSelected: () => {
                if (state.selectedIndices.length === 0) return;
                if (!confirm(`Opravdu smazat vybran√© z√°pasy (${state.selectedIndices.length})?`)) return;

                const indices = [...state.selectedIndices].sort((a, b) => b - a);
                indices.forEach(idx => {
                    state.schedule.splice(idx, 1);
                    if (state.activeMatchIndex === idx) state.activeMatchIndex = -1;
                    else if (state.activeMatchIndex > idx) state.activeMatchIndex--;
                });

                state.selectedIndices = [];
                state.pendingEditIndex = -1;
                ui.renderSchedule();
                admin.saveToStorage();
            },

            resetSelectedScores: () => {
                if (state.selectedIndices.length === 0) return;
                state.selectedIndices.forEach(idx => {
                    if (state.schedule[idx]) {
                        state.schedule[idx].homeScore = null;
                        state.schedule[idx].guestScore = null;
                    }
                });
                ui.renderSchedule();
                admin.saveToStorage();
                game.syncProjection();
            },

            loadSelected: () => {
                if (state.selectedIndices.length === 0) return;
                admin.loadMatch(state.selectedIndices[0], true);
            },

            editSelected: () => {
                if (state.selectedIndices.length === 0) return;
                admin.editScheduleMatch(state.selectedIndices[0]);
            },

            moveMatchesTo: (indices, targetIdx) => {
                if (!indices || indices.length === 0) return;

                // Sort indices to move items in correct order
                indices.sort((a, b) => a - b);

                // Keep track of the active match
                const activeMatch = state.activeMatchIndex > -1 ? state.schedule[state.activeMatchIndex] : null;

                // Extract items to be moved
                const itemsToMove = indices.map(idx => state.schedule[idx]);

                // Create new schedule by removing items and inserting at target
                const remainingItems = state.schedule.filter((_, idx) => !indices.includes(idx));

                // Calculate actual insertion point in the remaining items array
                // We need to count how many items before targetIdx were removed
                let actualInsertIdx = targetIdx;
                let removedBefore = indices.filter(idx => idx < targetIdx).length;
                actualInsertIdx -= removedBefore;

                // Ensure bounds
                actualInsertIdx = Math.max(0, Math.min(actualInsertIdx, remainingItems.length));

                remainingItems.splice(actualInsertIdx, 0, ...itemsToMove);
                state.schedule = remainingItems;

                // Update active match index if it exists
                if (activeMatch) {
                    state.activeMatchIndex = state.schedule.indexOf(activeMatch);
                }

                // Update selected indices to point to the new positions
                state.selectedIndices = [];
                for (let i = 0; i < itemsToMove.length; i++) {
                    state.selectedIndices.push(actualInsertIdx + i);
                }

                ui.renderSchedule();
                admin.saveToStorage();
            },

            deselectAll: () => {
                if (state.selectedIndices.length > 0) {
                    state.selectedIndices = [];
                    ui.renderSchedule();
                }
            },

            saveToStorage: () => {
                localStorage.setItem('scoreboardState', JSON.stringify(state));
            },

            loadFromStorage: () => {
                const loaded = localStorage.getItem('scoreboardState');
                if (loaded) {
                    const parsed = JSON.parse(loaded);
                    state.tournamentName = parsed.tournamentName || "";
                    if (parsed.times) {
                        state.times = parsed.times;
                        // FIX: If user has stuck '2' values, force new defaults
                        if (state.times.play === 2 || state.times.play === 5) state.times.play = 420;
                        if (state.times.break === 2 || state.times.break === 5) state.times.break = 105;
                        if (state.times.setup === 2 || state.times.setup === 5) state.times.setup = 10;
                    }
                    if (parsed.teams) state.teams = parsed.teams;
                    if (parsed.teamLogos) state.teamLogos = parsed.teamLogos;
                    if (parsed.teamAnthems) state.teamAnthems = parsed.teamAnthems;
                    if (typeof parsed.volSignal !== 'undefined') state.volSignal = parsed.volSignal;
                    if (typeof parsed.volAnthem !== 'undefined') state.volAnthem = parsed.volAnthem;
                    if (parsed.referees) state.referees = parsed.referees;
                    if (parsed.schedule) state.schedule = parsed.schedule;
                    if (parsed.audioData) state.audioData = parsed.audioData;
                    if (parsed.theme) state.theme = parsed.theme;
                    if (typeof parsed.musicAutoEnabled !== 'undefined') state.musicAutoEnabled = parsed.musicAutoEnabled;
                    if (parsed.musicMode) state.musicMode = parsed.musicMode;
                    if (typeof parsed.musicFadeDuration !== 'undefined') state.musicFadeDuration = parsed.musicFadeDuration;
                    if (parsed.musicPlaylistOrder) state.musicPlaylistOrder = parsed.musicPlaylistOrder;
                    if (parsed.musicAutoChangeStrategy) state.musicAutoChangeStrategy = parsed.musicAutoChangeStrategy;

                    if (typeof parsed.tournamentStartTime !== 'undefined') state.tournamentStartTime = parsed.tournamentStartTime;
                    if (typeof parsed.playTimeAccumulated !== 'undefined') state.playTimeAccumulated = parsed.playTimeAccumulated;

                    // MIGRATION: Strings -> Objects with IDs
                    if (state.teams.length > 0 && typeof state.teams[0] === 'string') {
                        const teamMap = {};
                        const oldTeamsArr = [...state.teams];
                        state.teams = oldTeamsArr.map((name, i) => {
                            const id = "team_legacy_" + i;
                            teamMap[name] = id;
                            return { id, name };
                        });
                        // Migrate logos/anthems
                        const newLogos = {};
                        const newAnthems = {};
                        Object.keys(state.teamLogos).forEach(oldName => {
                            if (teamMap[oldName]) newLogos[teamMap[oldName]] = state.teamLogos[oldName];
                        });
                        Object.keys(state.teamAnthems).forEach(oldName => {
                            if (teamMap[oldName]) newAnthems[teamMap[oldName]] = state.teamAnthems[oldName];
                        });
                        state.teamLogos = newLogos;
                        state.teamAnthems = newAnthems;
                        // Migrate schedule references
                        state.schedule.forEach(m => {
                            if (teamMap[m.home]) m.home = teamMap[m.home];
                            if (teamMap[m.guest]) m.guest = teamMap[m.guest];
                        });
                        // Migrate current match
                        if (teamMap[state.currentMatch.homeName]) state.currentMatch.homeName = teamMap[state.currentMatch.homeName];
                        if (teamMap[state.currentMatch.guestName]) state.currentMatch.guestName = teamMap[state.currentMatch.guestName];
                    }

                    if (state.referees.length > 0 && typeof state.referees[0] === 'string') {
                        const refMap = {};
                        const oldRefsArr = [...state.referees];
                        state.referees = oldRefsArr.map((name, i) => {
                            const id = "ref_legacy_" + i;
                            refMap[name] = id;
                            return { id, name };
                        });
                        // Migrate schedule
                        state.schedule.forEach(m => {
                            if (refMap[m.referee]) m.referee = refMap[m.referee];
                        });
                        // Migrate current
                        if (refMap[state.currentMatch.referee]) state.currentMatch.referee = refMap[state.currentMatch.referee];
                    }
                }

                admin.renderIdentityInputs();

                // Keyboard Selection Listeners
                window.addEventListener('keydown', (e) => {
                    if (e.shiftKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                        // Don't scroll if we are in the list
                        if (state.selectedIndices.length === 0) {
                            admin.toggleSelection(0, false);
                        } else {
                            const last = state.selectedIndices[state.selectedIndices.length - 1];
                            const next = last + (e.key === 'ArrowUp' ? -1 : 1);
                            if (next >= 0 && next < state.schedule.length) {
                                e.preventDefault();
                                admin.toggleSelection(next, true);
                            }
                        }
                    }
                });

                // Deselect on click outside match items
                const schedContent = document.getElementById('acc-schedule');
                if (schedContent) {
                    schedContent.addEventListener('click', (e) => {
                        // If click is directly on the accordion content or the list (not on items or toolbar buttons)
                        const target = e.target;
                        const isMatchItem = target.closest('.match-item');
                        const isToolbar = target.closest('.schedule-toolbar');
                        const isForm = target.closest('#sched-form-container');

                        if (!isMatchItem && !isToolbar && !isForm) {
                            admin.deselectAll();
                        }
                    });
                }

                // Set Inputs
                document.getElementById('input-tournament-name').value = state.tournamentName;
                document.getElementById('time-setup').value = state.times.setup;
                document.getElementById('time-play').value = state.times.play;
                document.getElementById('time-break').value = state.times.break;

                // Volume Controls
                document.getElementById('input-vol-signal').value = state.volSignal || 1.0;
                document.getElementById('vol-signal-disp').innerText = Math.round((state.volSignal || 1.0) * 100);
                document.getElementById('input-vol-anthem').value = state.volAnthem || 1.0;
                document.getElementById('vol-anthem-disp').innerText = Math.round((state.volAnthem || 1.0) * 100);
                document.getElementById('input-theme').value = state.theme || "light";
                document.getElementById('input-po-delay').value = state.poTransitionDelay || 10;
                document.getElementById('input-show-footer').checked = (state.showFooter !== false);
                ui.updateFooterVisibility();

                // Music Settings
                const elAuto = document.getElementById('input-music-auto');
                if (elAuto) elAuto.checked = state.musicAutoEnabled;
                const elMode = document.getElementById('input-music-mode');
                if (elMode) elMode.value = state.musicMode || 'continuous';
                const elFade = document.getElementById('input-music-fade');
                if (elFade) elFade.value = state.musicFadeDuration || 1;
                const elFadeDisp = document.getElementById('fade-dur-disp');
                if (elFadeDisp) elFadeDisp.innerText = state.musicFadeDuration || 1;

                const elAutoChange = document.getElementById('input-music-auto-change');
                if (elAutoChange) elAutoChange.value = state.musicAutoChangeStrategy || 'continuous';

                const volSlider = document.getElementById('input-vol-music');
                if (volSlider) volSlider.value = state.volMusic || 0.5;

                const elVolDisp = document.getElementById('vol-music-disp');
                if (elVolDisp) elVolDisp.innerText = Math.round((state.volMusic || 0.5) * 100);

                admin.renderLogoSettings();
                ui.fillSelects();
                ui.renderSchedule();
                ui.updateProjection();
                game.resetTimer();

                // Update projection URL display
                const urlDisp = document.getElementById('projection-url-display');
                if (urlDisp) urlDisp.value = window.location.origin + window.location.pathname + '?projection';

                // Init music handle if exists
                music.getHandle().then(h => {
                    if (h) {
                        directoryHandle = h;
                        music.listTracks(); // Try to list if access is already granted (though browser usually blocks this)
                        document.getElementById('music-list').innerHTML = `<li style="color:#4caf50; font-size:0.8em; text-align:center; padding:10px;">Slo≈æka nalezena. Kliknƒõte na 'Vybrat slo≈æku' pro obnoven√≠ p≈ô√≠stupu.</li>`;
                    }
                });
            }
        };

        const music = {
            fadeInterval: null,
            async openDB() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open("MusicDB", 1);
                    req.onupgradeneeded = () => req.result.createObjectStore("handles");
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            async saveHandle(handle) {
                const db = await music.openDB();
                const tx = db.transaction("handles", "readwrite");
                tx.objectStore("handles").put(handle, "lastDirectory");
            },
            async getHandle() {
                try {
                    const db = await music.openDB();
                    const tx = db.transaction("handles", "readonly");
                    const req = tx.objectStore("handles").get("lastDirectory");
                    return new Promise(resolve => {
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve(null);
                    });
                } catch (e) { return null; }
            },
            async pickDirectory() {
                try {
                    directoryHandle = await window.showDirectoryPicker();
                    await music.saveHandle(directoryHandle);
                    await music.listTracks();
                } catch (e) { console.warn("Picker error:", e); }
            },
            async listTracks() {
                if (!directoryHandle) return;
                state.musicPlaylist = [];
                try {
                    for await (const entry of directoryHandle.values()) {
                        if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.mp3')) {
                            state.musicPlaylist.push({ name: entry.name, handle: entry });
                        }
                    }
                    state.musicPlaylist.sort((a, b) => a.name.localeCompare(b.name));
                    ui.renderMusic();
                    const mc = document.getElementById('music-controls');
                    const mp = document.getElementById('music-mini-panel');
                    if (mc) mc.style.display = 'block';
                    if (mp) mp.style.display = 'flex';
                } catch (e) {
                    alert("Nutno znovu povolit p≈ô√≠stup ke slo≈æce s hudbou.");
                }
            },
            toggle() {
                if (currentMusicAudio.paused) {
                    if (currentMusicIndex === -1 && state.musicPlaylist.length > 0) {
                        music.play(0);
                    } else {
                        currentMusicAudio.play();
                        music.fadeIn();
                    }
                } else {
                    music.fadeOut();
                }
            },
            next() {
                if (state.musicPlaylist.length === 0) return;
                let targetIndex;
                if (state.musicMode === 'random') {
                    targetIndex = Math.floor(Math.random() * state.musicPlaylist.length);
                } else {
                    targetIndex = currentMusicIndex + 1;
                    if (targetIndex >= state.musicPlaylist.length) targetIndex = 0;
                }
                // Crossfade if music is playing and fade duration > 0
                if (!currentMusicAudio.paused && state.musicFadeDuration > 0) {
                    music.crossfadeTo(targetIndex);
                } else {
                    music.play(targetIndex);
                }
            },
            prev() {
                if (state.musicPlaylist.length === 0) return;
                let targetIndex;
                if (state.musicMode === 'random') {
                    targetIndex = Math.floor(Math.random() * state.musicPlaylist.length);
                } else {
                    targetIndex = currentMusicIndex - 1;
                    if (targetIndex < 0) targetIndex = state.musicPlaylist.length - 1;
                }
                // Crossfade if music is playing and fade duration > 0
                if (!currentMusicAudio.paused && state.musicFadeDuration > 0) {
                    music.crossfadeTo(targetIndex);
                } else {
                    music.play(targetIndex);
                }
            },
            setVolume(val) {
                state.volMusic = parseFloat(val);
                if (!music.fadeInterval && !music.crossfadeInterval) {
                    currentMusicAudio.volume = state.volMusic;
                }
                const disp = document.getElementById('vol-music-disp');
                if (disp) disp.innerText = Math.round(state.volMusic * 100);
                admin.saveToStorage();
            },
            setAutoEnabled(val) {
                state.musicAutoEnabled = val;
                admin.saveToStorage();
            },
            setMode(val) {
                state.musicMode = val;
                admin.saveToStorage();
            },
            setFadeDuration(val) {
                state.musicFadeDuration = parseFloat(val);
                document.getElementById('fade-dur-disp').innerText = state.musicFadeDuration;
                admin.saveToStorage();
            },
            setAutoChangeStrategy(val) {
                state.musicAutoChangeStrategy = val;
                admin.saveToStorage();
            },
            fadeIn() {
                clearInterval(music.fadeInterval);
                if (state.musicFadeDuration === 0) {
                    currentMusicAudio.volume = state.volMusic;
                    return;
                }
                currentMusicAudio.volume = 0;
                const step = state.volMusic / (state.musicFadeDuration * 20);
                music.fadeInterval = setInterval(() => {
                    currentMusicAudio.volume = Math.min(state.volMusic, currentMusicAudio.volume + step);
                    if (currentMusicAudio.volume >= state.volMusic) {
                        clearInterval(music.fadeInterval);
                        music.fadeInterval = null;
                    }
                }, 50);
            },
            fadeOut() {
                clearInterval(music.fadeInterval);
                if (state.musicFadeDuration === 0) {
                    currentMusicAudio.pause();
                    return;
                }
                const step = currentMusicAudio.volume / (state.musicFadeDuration * 20);
                music.fadeInterval = setInterval(() => {
                    currentMusicAudio.volume = Math.max(0, currentMusicAudio.volume - step);
                    if (currentMusicAudio.volume <= 0) {
                        clearInterval(music.fadeInterval);
                        music.fadeInterval = null;
                        currentMusicAudio.pause();
                    }
                }, 50);
            },
            startAuto() {
                if (!state.musicAutoEnabled || state.musicPlaylist.length === 0) return;
                // Start a new track from beginning (only when first entering auto mode)
                if (state.musicMode === 'random') {
                    const idx = Math.floor(Math.random() * state.musicPlaylist.length);
                    music.play(idx, true);
                } else {
                    if (currentMusicIndex === -1) music.play(0, true);
                    else music.play(currentMusicIndex, true);
                }
            },
            resumeAuto(phaseIndex, previousPhase) {
                if (!state.musicAutoEnabled || state.musicPlaylist.length === 0) return;

                // Check if we should start a new track based on strategy
                const shouldStartNew = (
                    currentMusicIndex === -1 || // No track loaded
                    (state.musicAutoChangeStrategy === 'per-step' && (phaseIndex === 0 || phaseIndex === 2)) // New track per step
                );

                if (shouldStartNew) {
                    // Start new track only if not already playing or if strategy requires it
                    music.startNewTrack();
                } else if (currentMusicAudio.paused) {
                    // Resume from where it was paused
                    currentMusicAudio.play().then(() => {
                        music.fadeIn();
                    }).catch(e => console.warn("Resume failed, likely interupted:", e));
                }
            },
            startNewTrack() {
                // Start a new track (used by both auto strategies)
                if (state.musicMode === 'random') {
                    const idx = Math.floor(Math.random() * state.musicPlaylist.length);
                    music.play(idx, true);
                } else {
                    let nextIdx = currentMusicIndex + 1;
                    if (nextIdx >= state.musicPlaylist.length) nextIdx = 0;
                    music.play(nextIdx, true);
                }
            },
            pauseAuto() {
                if (!state.musicAutoEnabled) return;
                // Pause (not stop) - will resume from this position
                if (!currentMusicAudio.paused) {
                    music.fadeOut();
                }
            },
            stopAuto() {
                if (!state.musicAutoEnabled) return;
                music.fadeOut();
            },
            reorder(fromIndex, toIndex) {
                const item = state.musicPlaylist.splice(fromIndex, 1)[0];
                state.musicPlaylist.splice(toIndex, 0, item);
                state.musicPlaylistOrder = state.musicPlaylist.map(t => t.name);
                admin.saveToStorage();
                ui.renderMusic();
            },
            crossfadeTo(index) {
                // True crossfade: both tracks play simultaneously
                clearInterval(music.crossfadeInterval);

                // Determine which audio element to use for the new track
                const oldAudio = currentMusicAudio;
                const newAudio = (currentMusicAudio === musicAudioA) ? musicAudioB : musicAudioA;

                // Load and start the new track
                music.loadTrack(newAudio, index).then(() => {
                    newAudio.volume = 0;
                    newAudio.play();

                    // Crossfade: old fades out, new fades in
                    const steps = state.musicFadeDuration * 20;
                    const oldStep = oldAudio.volume / steps;
                    const newStep = state.volMusic / steps;
                    let stepCount = 0;

                    music.crossfadeInterval = setInterval(() => {
                        stepCount++;
                        oldAudio.volume = Math.max(0, oldAudio.volume - oldStep);
                        newAudio.volume = Math.min(state.volMusic, newAudio.volume + newStep);

                        if (stepCount >= steps) {
                            clearInterval(music.crossfadeInterval);
                            music.crossfadeInterval = null;
                            oldAudio.pause();
                            oldAudio.volume = state.volMusic; // Reset for next use
                            currentMusicAudio = newAudio; // Switch active audio
                        }
                    }, 50);
                }).catch(e => {
                    console.error("Crossfade error:", e);
                });
            },
            async loadTrack(audioElement, index) {
                const track = state.musicPlaylist[index];
                const file = await track.handle.getFile();
                const url = URL.createObjectURL(file);
                audioElement.src = url;
                currentMusicIndex = index;
                document.getElementById('current-track-name').textContent = track.name;
                ui.renderMusic();
            },
            async play(index, isAuto = false) {
                if (index < 0 || index >= state.musicPlaylist.length) return;
                try {
                    await music.loadTrack(currentMusicAudio, index);

                    // CRITICAL: Double check if we are still in a musical phase after async load
                    // Musical phases are 0 (Nastupuje) and 2 (P≈ôest√°vka)
                    const pIdx = state.currentMatch.phaseIndex;
                    const isMusicalPhase = (pIdx === 0 || pIdx === 2);

                    if (isAuto && !isMusicalPhase) {
                        console.log("Music play cancelled: current phase is not musical", pIdx);
                        return;
                    }

                    if (isAuto || state.musicFadeDuration > 0) {
                        currentMusicAudio.volume = 0;
                        currentMusicAudio.play().then(() => {
                            music.fadeIn();
                        }).catch(e => console.warn("Auto play interupted:", e));
                    } else {
                        currentMusicAudio.volume = state.volMusic;
                        currentMusicAudio.play().catch(e => console.warn("Manual play failed:", e));
                    }
                } catch (e) {
                    console.error("Play error:", e);
                    if (!isAuto) alert("Chyba p≈ôi p≈ôehr√°v√°n√≠.");
                }
            }
        };


        // Event listeners for both audio elements
        musicAudioA.addEventListener('ended', () => {
            if (currentMusicAudio === musicAudioA) music.next();
        });
        musicAudioB.addEventListener('ended', () => {
            if (currentMusicAudio === musicAudioB) music.next();
        });

        // Update indicator when either audio plays/pauses
        musicAudioA.addEventListener('play', () => {
            if (currentMusicAudio === musicAudioA) ui.updateMusicIndicatorState();
        });
        musicAudioA.addEventListener('pause', () => {
            if (currentMusicAudio === musicAudioA) ui.updateMusicIndicatorState();
        });
        musicAudioB.addEventListener('play', () => {
            if (currentMusicAudio === musicAudioB) ui.updateMusicIndicatorState();
        });
        musicAudioB.addEventListener('pause', () => {
            if (currentMusicAudio === musicAudioB) ui.updateMusicIndicatorState();
        });

        // --- UI DRAWING ---
        const ui = {
            updateFooterVisibility: () => {
                const footer = document.getElementById('admin-footer');
                if (footer) {
                    footer.style.display = state.showFooter ? 'grid' : 'none';
                    document.body.style.paddingBottom = state.showFooter ? '55px' : '20px';
                }
            },
            updateAdminFooter: () => {
                const telemetry = game.getTelemetry();
                const prog = document.getElementById('admin-footer-progress');
                const end = document.getElementById('admin-footer-end');
                const time = document.getElementById('admin-footer-time');
                if (prog) prog.innerText = telemetry.progress;
                if (end) end.innerText = telemetry.end;
                if (time) time.innerText = telemetry.time;
            },
            render: () => {
                ui.renderPhase();
                ui.updateScores();
                ui.updateNames();
                ui.updateTimer();
                ui.updateTimerBtn();
                ui.renderSchedule();
                ui.renderMusic();
            },

            renderMusic: () => {
                const list = document.getElementById('music-list');
                const container = document.getElementById('music-controls');
                if (state.musicPlaylist.length === 0) {
                    list.innerHTML = `<li style="color:#666; font-size:0.8em; text-align:center; padding:10px;">Slo≈æka nebyla vybr√°na nebo neobsahuje MP3</li>`;
                    container.style.display = 'none';
                    return;
                }
                container.style.display = 'block';
                list.innerHTML = "";
                state.musicPlaylist.forEach((track, idx) => {
                    const li = document.createElement('li');
                    li.className = "match-item" + (idx === currentMusicIndex ? " active-match" : "");
                    li.style.display = "flex";
                    li.style.alignItems = "center";
                    li.style.padding = "5px 10px";
                    li.draggable = true;
                    li.dataset.index = idx;

                    li.innerHTML = `
                        <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; cursor:move;">${track.name}</span>
                        <span style="font-size:1.2em; cursor:pointer;" onclick="event.stopPropagation(); music.play(${idx})">${idx === currentMusicIndex && !currentMusicAudio.paused ? '‚ô´' : '‚ñ∂'}</span>
                    `;

                    // Drag & Drop
                    li.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', idx);
                        li.style.opacity = '0.5';
                    });
                    li.addEventListener('dragend', () => li.style.opacity = '1');
                    li.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        li.classList.add('drag-over');
                    });
                    li.addEventListener('dragleave', () => li.classList.remove('drag-over'));
                    li.addEventListener('drop', (e) => {
                        e.preventDefault();
                        li.classList.remove('drag-over');
                        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                        const toIdx = idx;
                        if (fromIdx !== toIdx) {
                            music.reorder(fromIdx, toIdx);
                        }
                    });

                    li.onclick = () => music.play(idx);
                    list.appendChild(li);
                });
            },

            renderPhase: () => {
                const isEvent = state.currentMatch.isEvent;
                const phaseControls = document.getElementById('phase-controls');
                const eventLabel = document.getElementById('event-label');

                if (isEvent) {
                    if (phaseControls) phaseControls.style.display = 'none';
                    if (eventLabel) {
                        eventLabel.style.display = 'block';
                        eventLabel.textContent = state.currentMatch.title;
                    }
                    // Hide score controls for events
                    document.getElementById('home-team-panel').style.visibility = 'hidden';
                    document.getElementById('guest-team-panel').style.visibility = 'hidden';
                } else {
                    if (phaseControls) phaseControls.style.display = 'flex';
                    if (eventLabel) eventLabel.style.display = 'none';
                    document.querySelectorAll('.phase-btn').forEach(btn => {
                        btn.classList.toggle('active', parseInt(btn.dataset.phase) === state.currentMatch.phaseIndex);
                    });
                    // Show score controls for matches
                    document.getElementById('home-team-panel').style.visibility = 'visible';
                    document.getElementById('guest-team-panel').style.visibility = 'visible';
                }
                ui.updateMatchInfo();
            },

            updateMatchInfo: () => {
                const infoDiv = document.getElementById('match-info-display');
                if (state.activeMatchIndex > -1 && state.schedule[state.activeMatchIndex]) {
                    const m = state.schedule[state.activeMatchIndex];
                    infoDiv.textContent = `${state.activeMatchIndex + 1}. ${m.title || ""}`;
                } else {
                    infoDiv.textContent = state.tournamentName || "Z√°pas";
                }
            },

            updateScores: () => {
                document.getElementById('home-score-disp').textContent = state.currentMatch.homeScore;
                document.getElementById('guest-score-disp').textContent = state.currentMatch.guestScore;
            },

            updateNames: () => {
                document.getElementById('home-name-disp').textContent = admin.getTeamName(state.currentMatch.homeName);
                document.getElementById('guest-name-disp').textContent = admin.getTeamName(state.currentMatch.guestName);
                ui.updateLogos();
            },

            updateLogos: () => {
                const hImg = document.getElementById('home-logo-disp');
                const gImg = document.getElementById('guest-logo-disp');

                const hLogo = state.teamLogos[state.currentMatch.homeName];
                const gLogo = state.teamLogos[state.currentMatch.guestName];

                if (hLogo) {
                    hImg.src = hLogo;
                    hImg.style.display = 'block';
                } else {
                    hImg.style.display = 'none';
                }

                if (gLogo) {
                    gImg.src = gLogo;
                    gImg.style.display = 'block';
                } else {
                    gImg.style.display = 'none';
                }
            },

            updateTimer: () => {
                const m = Math.floor(state.timer.timeLeft / 60).toString().padStart(2, '0');
                const s = Math.floor(state.timer.timeLeft % 60).toString().padStart(2, '0');
                document.getElementById('main-timer').textContent = `${m}:${s}`;
            },

            updateTimerBtn: () => {
                const btn = document.getElementById('btn-timer-toggle');
                const tDisp = document.getElementById('main-timer');
                const up = document.getElementById('btn-time-up');
                const down = document.getElementById('btn-time-down');

                if (state.timer.running) {
                    btn.textContent = "‚è∏"; // Pause
                    btn.classList.remove('btn-green');
                    btn.classList.add('btn-yellow');
                    tDisp.contentEditable = "false";
                    if (up) up.disabled = true;
                    if (down) down.disabled = true;
                } else {
                    btn.textContent = "‚ñ∂"; // Play
                    btn.classList.remove('btn-yellow');
                    btn.classList.add('btn-green');
                    tDisp.contentEditable = "true";
                    if (up) up.disabled = false;
                    if (down) down.disabled = false;
                }
            },

            fillSelects: () => {
                // Teams
                const teamSelects = ['sched-home', 'sched-guest'];
                teamSelects.forEach(id => {
                    const sel = document.getElementById(id);
                    if (!sel) return;
                    const currentVal = sel.value;
                    sel.innerHTML = '<option value="">-- Vyber Dru≈æstvo --</option>';
                    state.teams.forEach(t => {
                        sel.innerHTML += `<option value="${t.id}">${t.name}</option>`;
                    });
                    // Only restore value if it still exists in the list or is empty
                    if (state.teams.includes(currentVal) || currentVal === "") sel.value = currentVal;
                });

                // Referees
                const refSelects = ['sched-referee'];
                refSelects.forEach(id => {
                    const sel = document.getElementById(id);
                    if (!sel) return;
                    const currentVal = sel.value;
                    sel.innerHTML = '<option value="">-- Vyber Rozhodƒç√≠ho --</option>';
                    state.referees.forEach(r => {
                        sel.innerHTML += `<option value="${r.id}">${r.name}</option>`;
                    });
                    if (state.referees.includes(currentVal) || currentVal === "") sel.value = currentVal;
                });
            },

            renderSchedule: () => {
                const list = document.getElementById('match-queue');
                const form = document.getElementById('sched-form-container');
                const header = document.querySelector('#acc-schedule h4'); // Po≈ôad√≠:

                // Move form back to safe spot (below header) before clearing
                if (form && header) {
                    header.after(form);
                }

                list.innerHTML = "";
                state.schedule.forEach((m, idx) => {
                    const li = document.createElement('li');
                    li.className = "match-item";
                    li.draggable = true;
                    li.dataset.index = idx;
                    li.title = "Dvojklik pro editaci, Ta≈æen√≠m zmƒõ≈à po≈ôad√≠";

                    // Double Click to Edit
                    li.addEventListener('dblclick', (e) => {
                        admin.editScheduleMatch(idx);
                    });

                    // Drag Events
                    li.addEventListener('dragstart', (e) => {
                        // If we are dragging an item that's part of a selection, move the whole selection
                        // If not, select just this item and move it
                        if (!state.selectedIndices.includes(idx)) {
                            // IMPORTANT: Use silent mode to avoid re-rendering and destroying the dragged element
                            admin.toggleSelection(idx, false, false, true);
                            li.classList.add('selected-match');
                        }

                        e.dataTransfer.effectAllowed = 'move';
                        // Store the indices as a JSON string
                        const data = JSON.stringify(state.selectedIndices);
                        e.dataTransfer.setData('text/plain', data);

                        // Set a drag image if multiple items are selected? (Browser default is usually fine)
                        li.style.opacity = '0.5';
                    });

                    li.addEventListener('dragend', (e) => {
                        li.style.opacity = '1';
                        // Remove drop indicator styles from all items
                        document.querySelectorAll('.match-item').forEach(item => {
                            item.classList.remove('drop-indicator-top', 'drop-indicator-bottom');
                        });
                    });

                    li.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';

                        // Remove indicators from all items first
                        document.querySelectorAll('.match-item').forEach(item => {
                            item.classList.remove('drop-indicator-top', 'drop-indicator-bottom');
                        });

                        // Calculate if mouse is in top or bottom half of item
                        const rect = li.getBoundingClientRect();
                        const relY = e.clientY - rect.top;

                        if (relY > rect.height / 2) {
                            li.classList.add('drop-indicator-bottom');
                        } else {
                            li.classList.add('drop-indicator-top');
                        }
                    });

                    li.addEventListener('dragleave', (e) => {
                        li.classList.remove('drop-indicator-top', 'drop-indicator-bottom');
                    });

                    li.addEventListener('drop', (e) => {
                        e.preventDefault();
                        li.classList.remove('drop-indicator-top', 'drop-indicator-bottom');

                        try {
                            const indices = JSON.parse(e.dataTransfer.getData('text/plain'));
                            let toIndex = idx;

                            // Calculate if we should insert AFTER the target item
                            // This allows reaching the end of the list when dropping on the bottom half of the last item
                            const rect = li.getBoundingClientRect();
                            const relY = e.clientY - rect.top;
                            if (relY > rect.height / 2) {
                                toIndex++;
                            }

                            // If it's just one index and it's same as target, do nothing
                            if (Array.isArray(indices)) {
                                admin.moveMatchesTo(indices, toIndex);
                            } else if (typeof indices === 'number') {
                                // Fallback for old single-item behavior if any
                                admin.moveMatch(indices, toIndex);
                            }
                        } catch (err) {
                            console.error("Drop error", err);
                        }
                    });

                    if (idx === state.activeMatchIndex) {
                        li.classList.add('active-match');
                    }
                    if (idx === state.pendingEditIndex) {
                        li.classList.add('editing-match');
                    }
                    if (state.selectedIndices.includes(idx)) {
                        li.classList.add('selected-match');
                    }

                    const isEvent = m.type === 'event';
                    let hasScore = (m.homeScore !== undefined && m.homeScore !== null && m.guestScore !== undefined && m.guestScore !== null);
                    let scoreDisplay = hasScore ? `${m.homeScore}:${m.guestScore}` : "-:-";

                    if (isEvent) {
                        const durMin = Math.floor((m.duration || 600) / 60);
                        li.innerHTML = `
                            <div style="flex:1; display:grid; grid-template-columns: 120px 1fr 15px 1fr 60px 1fr; align-items:center; font-size:0.85em; gap:5px; padding-right:10px; overflow:hidden;">
                                <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><b>${idx + 1}.</b> ${m.title || "Ud√°lost"}</div>
                                <div style="grid-column: 2 / 5; text-align:center; color:#aaa; white-space:nowrap;">‚è± ${durMin}m</div>
                                <div></div>
                                <div></div>
                            </div>
                        `;
                    } else {
                        li.innerHTML = `
                            <div style="flex:1; display:grid; grid-template-columns: 120px 1fr 15px 1fr 60px 1fr; align-items:center; font-size:0.85em; gap:5px; padding-right:10px; overflow:hidden;">
                                <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><b>${idx + 1}.</b> ${m.title}</div>
                                <div style="text-align:right; font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${admin.getTeamName(m.home)}</div>
                                <div style="text-align:center; color:#888;">:</div>
                                <div style="text-align:left; font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${admin.getTeamName(m.guest)}</div>
                                <div style="text-align:center; ${hasScore ? 'font-weight:900; color:var(--accent-green);' : 'font-weight:300; color:#fff;'}">${scoreDisplay}</div>
                                <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:#aaa; font-style:italic;">${admin.getRefName(m.referee)}</div>
                            </div>
                        `;
                    }

                    li.onclick = (e) => {
                        admin.toggleSelection(idx, e.shiftKey, e.ctrlKey);
                    };

                    list.appendChild(li);
                });

                // If editing, move form to the correct spot (below item)
                if (state.pendingEditIndex > -1 && form) {
                    const targetLi = list.querySelector(`.match-item[data-index="${state.pendingEditIndex}"]`);
                    if (targetLi) {
                        targetLi.after(form);
                    }
                }
            },

            updateMusicIndicatorState: () => {
                const btnMini = document.getElementById('btn-music-toggle-mini');
                if (btnMini) {
                    if (!currentMusicAudio.paused) {
                        btnMini.classList.add('active');
                        btnMini.innerText = '‚ô´';
                    } else {
                        btnMini.classList.remove('active');
                        btnMini.innerText = '‚ô´';
                    }
                }
                // Also update the note symbols in the music playlist list
                ui.renderMusic();
            },

            updateProjection: () => {
                try {
                    if (!state.isProjectionMode) return;
                    console.log("UI: updateProjection start");

                    const usedState = (state.poTransitionActive && state.poTransitionData) ? state.poTransitionData : state;
                    const isBlinking = state.poTransitionActive;

                    const PHASES_LIST = ["Nastupuje", "1. Poloƒças", "P≈ôest√°vka", "2. Poloƒças"];
                    const matchData = usedState.currentMatch || { title: "Z√°pas", homeName: "Dom√°c√≠", guestName: "Host√©", homeScore: 0, guestScore: 0, phaseIndex: 0 };
                    const teamLogos = usedState.teamLogos || {};
                    const teams = usedState.teams || [];
                    const referees = usedState.referees || [];

                    const getTName = (id) => {
                        const t = teams.find(x => x.id === id);
                        return t ? t.name : (id || "T√Ωm");
                    };
                    const getRName = (id) => {
                        const r = referees.find(x => x.id === id);
                        return r ? r.name : (id || "-");
                    };

                    // Update Theme
                    document.body.classList.toggle('theme-dark', usedState.theme === 'dark');
                    document.body.classList.toggle('theme-light', usedState.theme !== 'dark');

                    // Update Top Row
                    const titleEl = document.getElementById('p-match-title');
                    if (titleEl) titleEl.innerText = matchData.title || "";

                    const isEventMode = !!matchData.isEvent;
                    const phaseNameEl = document.getElementById('p-phase-name');
                    if (phaseNameEl) {
                        phaseNameEl.innerText = isEventMode ? "" : (PHASES_LIST[matchData.phaseIndex] || "");
                        phaseNameEl.classList.toggle('p-row-blink', isBlinking);
                    }

                    const timerEl = document.getElementById('p-timer');
                    if (timerEl) {
                        const m = Math.floor(usedState.timer.timeLeft / 60).toString().padStart(2, '0');
                        const s = Math.floor(usedState.timer.timeLeft % 60).toString().padStart(2, '0');
                        timerEl.innerText = m + ":" + s;
                    }

                    // Main View Mode (Match vs Event)
                    const matchCont = document.getElementById('p-match-content');
                    if (matchCont) matchCont.style.display = isEventMode ? 'none' : 'grid';
                    const eventCont = document.getElementById('p-event-content');
                    if (eventCont) {
                        eventCont.style.display = isEventMode ? 'flex' : 'none';
                        if (isEventMode) {
                            let title = usedState.currentMatch.title || "Ud√°lost";
                            if (title.length > 20) title = title.substring(0, 17) + "...";
                            eventCont.innerText = title;
                            eventCont.classList.toggle('p-row-blink', isBlinking);
                        }
                    }

                    if (!isEventMode) {
                        const hn = document.getElementById('p-home-name');
                        if (hn) hn.innerText = getTName(matchData.homeName);
                        const gn = document.getElementById('p-guest-name');
                        if (gn) gn.innerText = getTName(matchData.guestName);
                        const hs = document.getElementById('p-home-score');
                        if (hs) hs.innerText = matchData.homeScore;
                        const gs = document.getElementById('p-guest-score');
                        if (gs) gs.innerText = matchData.guestScore;

                        const scoreBox = document.getElementById('p-score-box');
                        if (scoreBox) scoreBox.classList.toggle('p-row-blink', isBlinking);

                        const hi = document.getElementById('p-home-logo');
                        if (hi) {
                            const hl = teamLogos[matchData.homeName];
                            if (hl) { hi.src = hl; hi.style.display = 'block'; } else { hi.style.display = 'none'; }
                        }
                        const gi = document.getElementById('p-guest-logo');
                        if (gi) {
                            const gl = teamLogos[matchData.guestName];
                            if (gl) { gi.src = gl; gi.style.display = 'block'; } else { gi.style.display = 'none'; }
                        }
                    }

                    // Upcoming Matches
                    const upcomingBody = document.getElementById('p-upcoming-body');
                    if (upcomingBody) {
                        upcomingBody.innerHTML = "";
                        const nextItems = (usedState.schedule || []).slice(usedState.activeMatchIndex + 1, usedState.activeMatchIndex + 5);
                        nextItems.forEach((match, idx) => {
                            const tr = document.createElement('tr');
                            tr.className = 'p-sched-row';
                            const isItemEvent = match.type === 'event';

                            if (isItemEvent) {
                                const durMin = Math.floor((match.duration || 600) / 60);
                                tr.innerHTML = `
                                    <td class="p-sched-col-match">${usedState.activeMatchIndex + 1 + idx + 1}. ${match.title || "Ud√°lost"}</td>
                                    <td class="p-sched-col-teams" style="text-align:center; color:var(--accent-blue);">
                                        <div style="font-weight:900; letter-spacing:1px; text-transform:uppercase;">‚è± ${durMin} min</div>
                                    </td>
                                    <td class="p-sched-col-refs"></td>
                                `;
                            } else {
                                const hLogo = teamLogos[match.home];
                                const gLogo = teamLogos[match.guest];

                                tr.innerHTML = `
                                    <td class="p-sched-col-match">${usedState.activeMatchIndex + 1 + idx + 1}. ${match.title || "Z√°pas"}</td>
                                    <td class="p-sched-col-teams">
                                        <div class="p-teams-flex">
                                            <div class="p-teams-side-home">
                                                <span>${getTName(match.home)}</span>
                                                <img src="${hLogo || ''}" class="p-mini-logo" style="display:${hLogo ? 'inline-block' : 'none'}">
                                            </div>
                                            <div class="p-teams-sep">:</div>
                                            <div class="p-teams-side-guest">
                                                <img src="${gLogo || ''}" class="p-mini-logo" style="display:${gLogo ? 'inline-block' : 'none'}">
                                                <span>${getTName(match.guest)}</span>
                                            </div>
                                        </div>
                                    </td>
                                    <td class="p-sched-col-refs">${getRName(match.referee)}</td>
                                `;
                            }
                            upcomingBody.appendChild(tr);
                        });
                    }

                    // Footer Visibility & Telemetry
                    const footer = document.getElementById('p-row-footer');
                    const layout = document.getElementById('projection-layout');
                    if (footer && layout) {
                        const fv = (usedState.showFooter !== false);
                        footer.style.display = fv ? 'grid' : 'none';
                        layout.style.gridTemplateRows = fv ? '18vh 48vh 30vh 4vh' : '18vh 48vh 34vh 0vh';

                        if (usedState.telemetry) {
                            const progEl = document.getElementById('p-footer-progress');
                            if (progEl) progEl.innerText = usedState.telemetry.progress;
                            const endEl = document.getElementById('p-footer-end');
                            if (endEl) endEl.innerText = usedState.telemetry.end;
                            // Time is updated locally by setInterval in game.init for smoother experience
                        }
                    }
                    // Final consistency check
                    const existingLayout = document.getElementById('projection-layout');
                    if (existingLayout) {
                        console.log("UI: layout height", existingLayout.offsetHeight, "rows", existingLayout.style.gridTemplateRows);
                    }
                } catch (err) {
                    console.error("UI Update Error:", err);
                }
            }
        };

        // --- UTILS ---
        function toggleAccordion(id) {
            const content = document.getElementById(id);
            if (content.classList.contains('open')) {
                content.classList.remove('open');
            } else {
                content.classList.add('open');
                // Force render if schedule is opened to ensure it is up to date/visible
                if (id === 'acc-schedule') {
                    ui.renderSchedule();
                }
            }
        }

        function openProjectionWindow() {
            const url = window.location.origin + window.location.pathname + '?projection';
            projectionWindow = window.open(url, "ScoreboardProjection", "width=800,height=600");
            if (!projectionWindow) {
                alert("Vyskakovac√≠ okno bylo zablokov√°no. Pros√≠m povolte jej pro tuto str√°nku.");
            } else {
                game.syncProjection();
            }
        }

        // Legacy implementation removed.

        // Initial Sync for Admin/Main view
        game.syncProjection();


        // Music Audio Events for Indicator stability
        // (Already set up above for both audio elements)

        // --- INIT ---
        window.addEventListener('load', game.init);

    </script>
</body>

</html>